<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp.Workspaces</name>
    </assembly>
    <members>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Classification.ClassificationHelpers.GetClassification(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determine the classification type for a given token.
            </summary>
            <param name="token">The token.</param>
            <returns>The correct syntactic classification for the token.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Classification.Worker">
            <summary>
            Worker is an utility class that can classify a list of tokens or a tree within a
            requested span The implementation is generic and can produce any kind of classification
            artifacts T T is normally either ClassificationSpan or a Tuple (for testing purposes) 
            and constructed via provided factory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator.ShiftTrivia(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Moves the trailing trivia from the node's previous token to the end of the node
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator.RequiresLocalDeclarationType">
            <summary>
            C# always requires a type to be present with a local declaration.  (Even if that type is
            <c>var</c>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGeneration.CSharpSyntaxGenerator.ParenthesizeLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Parenthesize the left hand size of a member access, invocation or element access expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper.IsTypeApparentInAssignmentExpression(Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.UseVarPreference,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Analyzes if type information is obvious to the reader by simply looking at the assignment expression.
            </summary>
            <remarks>
            <paramref name="typeInDeclaration"/> accepts null, to be able to cater to codegen features
            that are about to generate a local declaration and do not have this information to pass in.
            Things (like analyzers) that do have a local declaration already, should pass this in.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper.IsPossibleCreationMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Looks for types that have static methods that return the same type as the container.
            e.g: int.Parse, XElement.Load, Tuple.Create etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper.IsPossibleConversionMethod(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            If we have a method ToXXX and its return type is also XXX, then type name is apparent
            e.g: Convert.ToString.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.TypeStyleHelper.IsContainerTypeEqualToReturnType(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <remarks>
            If there are type arguments on either side of assignment, we match type names instead of type equality 
            to account for inferred generic type arguments.
            e.g: Tuple.Create(0, true) returns Tuple&lt;X,y&gt; which isn't the same as type Tuple.
            otherwise, we match for type equivalence
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Cannot_retrieve_the_Span_of_a_null_syntax_reference">
            <summary>
              Looks up a localized string similar to Cannot retrieve the Span of a null syntax reference..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Code_block_preferences">
            <summary>
              Looks up a localized string similar to Code-block preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Expected_string_or_char_literal">
            <summary>
              Looks up a localized string similar to Expected string or char literal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Expression_bodied_members">
            <summary>
              Looks up a localized string similar to Expression-bodied members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Implement_Interface">
            <summary>
              Looks up a localized string similar to Implement Interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Indentation_preferences">
            <summary>
              Looks up a localized string similar to Indentation preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Namespace_can_not_be_added_in_this_destination">
            <summary>
              Looks up a localized string similar to Namespace can not be added in this destination..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.No_available_location_found_to_add_statements_to">
            <summary>
              Looks up a localized string similar to No available location found to add statements to..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Node_does_not_descend_from_root">
            <summary>
              Looks up a localized string similar to Node does not descend from root..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Node_not_in_parent_s_child_list">
            <summary>
              Looks up a localized string similar to Node not in parent&apos;s child list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Null_checking_preferences">
            <summary>
              Looks up a localized string similar to Null-checking preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Only_attributes_constructor_initializers_expressions_or_statements_can_be_made_explicit">
            <summary>
              Looks up a localized string similar to Only attributes, constructor initializers, expressions or statements can be made explicit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Pattern_matching_preferences">
            <summary>
              Looks up a localized string similar to Pattern matching preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Remove_and_Sort_Usings">
            <summary>
              Looks up a localized string similar to R&amp;emove and Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Sort_Usings">
            <summary>
              Looks up a localized string similar to &amp;Sort Usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Space_preferences">
            <summary>
              Looks up a localized string similar to Space preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Trivia_is_not_associated_with_token">
            <summary>
              Looks up a localized string similar to Trivia is not associated with token.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.using_directive_preferences">
            <summary>
              Looks up a localized string similar to &apos;using&apos; directive preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.var_preferences">
            <summary>
              Looks up a localized string similar to var preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpWorkspaceResources.Wrapping_preferences">
            <summary>
              Looks up a localized string similar to Wrapping preferences.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Editing.CSharpImportAdder.Rewriter._namespaceMembers">
            <summary>
            A hashset containing the short names of all namespace members 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Editing.CSharpImportAdder.Rewriter._extensionMethods">
            <summary>
            A hashset containing the short names of all extension methods
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ArgumentSyntaxExtensions.DetermineParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the parameter to which this argument is passed. If <paramref name="allowParams"/>
            is true, the last parameter will be returned if it is params parameter and the index of
            the specified argument is greater than the number of parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.AttributeArgumentSyntaxExtensions.DetermineParameter(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the parameter to which this argument is passed. If <paramref name="allowParams"/>
            is true, the last parameter will be returned if it is params parameter and the index of
            the specified argument is greater than the number of parameters.
            </summary>
            <remarks>
            Returns null if the <paramref name="argument"/> is a named argument.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions.TryGetSemicolonToken(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax)">
            <summary>
            Available if <paramref name="node"/> is <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions.TryWithSemicolonToken(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Available if <paramref name="node"/> is <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.BasePropertyDeclarationSyntaxExtensions.TryWithExpressionBody(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>
            Available if <paramref name="node"/> is <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.CSharpSyntaxContext.IsAwaitStatementContext(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Is this a possible position for an await statement (`await using` or `await foreach`)?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions.IsPossibleTupleContext(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxToken,System.Int32)">
            <summary>
            Are you possibly typing a tuple type or expression?
            This is used to suppress colon as a completion trigger (so that you can type element names).
            This is also used to recommend some keywords (like var).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions.IsPossibleDeconstructionDesignation(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Are you possibly in the designation part of a deconstruction?
            This is used to enter suggestion mode (suggestions become soft-selected).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ContextQuery.SyntaxTreeExtensions.UnwrapPossibleTuple(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            If inside a parenthesized or tuple expression, unwrap the nestings and return the container.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.CastIfPossible(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Int32,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Adds to <paramref name="targetType"/> if it does not contain an anonymous
            type and binds to the same type at the given <paramref name="position"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ExpressionSyntaxExtensions.IsExpressionOfArgumentInDeconstruction(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            If this declaration or identifier is part of a deconstruction, find the deconstruction.
            If found, returns either an assignment expression or a foreach variable statement.
            Returns null otherwise.
            
            copied from SyntaxExtensions.GetContainingDeconstruction
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.ITypeSymbolExtensions.TypeSyntaxGeneratorVisitor.AddGlobalAlias(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>
            We always unilaterally add "global::" to all named types/namespaces.  This
            will then be trimmed off if possible by calls to 
            <see cref="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Extensions.OperatorPrecedence">
            <summary>
            Operator precedence classes from section 7.3.1 of the C# language specification.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions.DecomposeName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax@,System.String@,System.Int32@)">
            <summary>
            Decomposes a name or member access expression into its component parts.
            </summary>
            <param name="expression">The name or member access expression.</param>
            <param name="qualifier">The qualifier (or left-hand-side) of the name expression. This may be null if there is no qualifier.</param>
            <param name="name">The name of the expression.</param>
            <param name="arity">The number of generic type parameters.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions.GenerateNameForArgument(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an argument node, tries to generate an appropriate name that can be used for that
            argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SemanticModelExtensions.GenerateNameForExpression(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Given an expression node, tries to generate an appropriate name that can be used for
            that expression. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxKindExtensions.Contains(Microsoft.CodeAnalysis.CSharp.SyntaxKind[],Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Determine if the given <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> array contains the given kind.
            </summary>
            <param name="kinds">Array to search</param>
            <param name="kind">Sought value</param>
            <returns>True if <paramref name = "kinds"/> contains the value<paramref name= "kind"/>.</returns>
            <remarks>PERF: Not using Array.IndexOf here because it results in a call to IndexOf on the
            default EqualityComparer for SyntaxKind.The default comparer for SyntaxKind is the
            ObjectEqualityComparer which results in boxing allocations.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.GetEnclosingUsingDirectives(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the list of using directives that affect <paramref name="node"/>. The list will be returned in
            top down order.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Returns true if the passed in node contains an interleaved pp directive.
            
            i.e. The following returns false:
            
              void Goo() {
            #if true
            #endif
              }
            
            #if true
              void Goo() {
              }
            #endif
            
            but these return true:
            
            #if true
              void Goo() {
            #endif
              }
            
              void Goo() {
            #if true
              }
            #endif
            
            #if true
              void Goo() {
            #else
              }
            #endif
            
            i.e. the method returns true if it contains a PP directive that belongs to a grouping
            constructs (like #if/#endif or #region/#endregion), but the grouping construct isn't
            entirely contained within the span of the node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Similar to <see cref="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.ContainsInterleavedDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)"/> except that the span to check
            for interleaved directives can be specified separately to the node passed in.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.SplitNodesOnPreprocessorBoundaries``1(System.Collections.Generic.IEnumerable{``0},System.Threading.CancellationToken)">
            <summary>
            Breaks up the list of provided nodes, based on how they are interspersed with pp
            directives, into groups.  Within these groups nodes can be moved around safely, without
            breaking any pp constructs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.ChildThatContainsPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Int32@)">
            <summary>
            Returns child node or token that contains given position.
            </summary>
            <remarks>
            This is a copy of <see cref="M:Microsoft.CodeAnalysis.SyntaxNode.ChildThatContainsPosition(System.Int32)"/> that also returns the index of the child node.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxNodeExtensions.GetAllPrecedingTriviaToPreviousToken(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.SourceText,System.Boolean)">
            <summary>
            Returns all of the trivia to the left of this token up to the previous token (concatenates
            the previous token's trailing trivia and this token's leading trivia).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions.IsFirstTokenOnLine(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Determines whether the given SyntaxToken is the first token on a line in the specified SourceText.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions.GetAllTrailingTrivia(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Retrieves all trivia after this token, including it's trailing trivia and
            the leading trivia of the next token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions.FindLastTokenOfPartialGenericName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Lexically, find the last token that looks like it's part of this generic name.
            </summary>
            <param name="genericIdentifier">The "name" of the generic identifier, last token before
            the "&amp;"</param>
            <returns>The last token in the name</returns>
            <remarks>This is related to the code in <see cref="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTreeExtensions.IsInPartiallyWrittenGeneric(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTokenExtensions.CouldBeKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns true if this token is something that looks like a C# keyword. This includes 
            actual keywords, contextual keywords, and even 'var' and 'dynamic'
            </summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.SyntaxTriviaListExtensions.TakeRange(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32,System.Int32)">
            <summary>
            Takes an INCLUSIVE range of trivia from the trivia list. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Extensions.TypeSyntaxExtensions.IsTypeInferred(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Determines whether the specified TypeSyntax is actually 'var'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.FindSymbols.CSharpDeclaredSymbolInfoFactoryService.GetSuffix(System.Char,System.Char,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax})">
            <summary>
            Builds up the suffix to show for something with parameters in navigate-to.
            While it would be nice to just use the compiler SymbolDisplay API for this,
            it would be too expensive as it requires going back to Symbols (which requires
            creating compilations, etc.) in a perf sensitive area.
            
            So, instead, we just build a reasonable suffix using the pure syntax that a 
            user provided.  That means that if they wrote "Method(System.Int32 i)" we'll 
            show that as "Method(System.Int32)" not "Method(int)".  Given that this is
            actually what the user wrote, and it saves us from ever having to go back to
            symbols/compilations, this is well worth it, even if it does mean we have to
            create our own 'symbol display' logic here.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions.LeftMost">
            Placed in the Zeroth column of the text editor
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions.OneLess">
            Placed at one less indent to the current context
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.LabelPositionOptions.NoIndent">
            Placed at the same indent as the current context
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions.Single">
            Single Spacing
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions.Ignore">
            Ignore Formatting
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Formatting.BinaryOperatorSpacingOptions.Remove">
            Remove Spacing
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Formatting.FormattingResult">
            <summary>
            this holds onto changes made by formatting engine.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Formatting.TriviaDataFactory">
            <summary>
            trivia factory.
            
            it will cache some commonly used trivia to reduce memory footprint and heap allocation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Formatting.TriviaDataFactory.ComplexTrivia">
            <summary>   
            represents a general trivia between two tokens. slightly more expensive than others since it
            needs to calculate stuff unlike other cases
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Formatting.FormattingHelpers.IsOpenParenInVarDeconstructionDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Checks whether currentToken is the opening paren of a deconstruction-declaration in var form, such as <c>var (x, y) = ...</c>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Formatting.FormattingHelpers.IsCommaInTupleExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Check whether the currentToken is a comma and is a delimiter between arguments inside a tuple expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Formatting.SyntaxKindEx">
            <summary>
            This class allows the Code Style layer to light up support for new language features when available at runtime
            while compiling against an older version of the Roslyn assemblies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryServiceFactory.CSharpSyntaxTreeFactoryService.PathSyntaxReference">
            <summary>
            Represents a syntax reference that doesn't actually hold onto the 
            referenced node.  Instead, enough data is held onto so that the node
            can be recovered and returned if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryServiceFactory.CSharpSyntaxTreeFactoryService.NullSyntaxReference">
            <summary>
            Represents a syntax reference that was passed a null
            reference to a node. In this case, we just hold onto the
            weak tree reference and throw if any invalid properties
            are accessed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryServiceFactory.CSharpSyntaxTreeFactoryService.PositionalSyntaxReference">
            <summary>
            Represents a syntax reference that doesn't actually hold onto the 
            referenced node.  Instead, enough data is held onto so that the node
            can be recovered and returned if necessary.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTreeFactoryServiceFactory.CSharpSyntaxTreeFactoryService.RecoverableSyntaxTree">
            <summary>
            Represents a syntax tree that only has a weak reference to its 
            underlying data.  This way it can be passed around without forcing
            the underlying full tree to stay alive.  Think of it more as a 
            key that can be used to identify a tree rather than the tree itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the top most enclosing statement or CrefSyntax as target to call MakeExplicit on.
            It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
            statement of this lambda.
            </summary>
            <param name="token">The token to get the complexification target for.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Rename.CSharpRenameConflictLanguageService.GetSemanticModelForNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Gets the semantic model for the given node.
            If the node belongs to the syntax tree of the original semantic model, then returns originalSemanticModel.
            Otherwise, returns a speculative model.
            The assumption for the later case is that span start position of the given node in it's syntax tree is same as
            the span start of the original node in the original syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Simplification.CSharpSimplificationService.NodesAndTokensToReduceComputer.Compute(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Boolean})">
            <summary>
            Computes a list of nodes and tokens that need to be reduced in the given syntax root.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Simplification.CSharpInferredMemberNameReducer">
            <summary>
            Complexify makes inferred names explicit for tuple elements and anonymous type members. This
            class considers which ones of those can be simplified (after the refactoring was done).
            If the inferred name of the member matches, the explicit name (from Complexify) can be removed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.AbstractCSharpSimplifier`2">
            <summary>
            Contains helpers used by several simplifier subclasses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.AbstractCSharpSimplifier`2.GetPredefinedKeywordKind(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns the predefined keyword kind for a given <see cref="T:Microsoft.CodeAnalysis.SpecialType"/>.
            </summary>
            <param name="specialType">The <see cref="T:Microsoft.CodeAnalysis.SpecialType"/> of this type.</param>
            <returns>The keyword kind for a given special type, or SyntaxKind.None if the type name is not a predefined type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.ExpressionSimplifier.IsReplacementCandidate(Microsoft.CodeAnalysis.ISymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Determines if <paramref name="speculativeSymbols"/> and <paramref name="speculativeNamespacesAndTypes"/>
            together contain a superset of the symbols in <paramref name="actualSymbol"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.ExpressionSimplifier.CandidateSymbolEqualityComparer">
            <summary>
            Compares symbols by their original definition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.ExpressionSimplifier.IsMemberAccessADynamicInvocation(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            Tells if the Member access is the starting part of a Dynamic Invocation
            </summary>
            <param name="memberAccess"></param>
            <param name="semanticModel"></param>
            <returns>Return true, if the member access is the starting point of a Dynamic Invocation</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Simplification.Simplifiers.NameSimplifier.IsPartOfNamespaceDeclarationName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Checks if the SyntaxNode is a name of a namespace declaration. To be a namespace name, the syntax
            must be parented by an namespace declaration and the node itself must be equal to the declaration's Name
            property.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult.IsStylePreferred">
            <summary>
            Whether or not converting would transition the code to the style the user prefers. i.e. if the user likes
            <c>var</c> for everything, and you have <c>int i = 0</c> then <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult.IsStylePreferred"/> will be
            <see langword="true"/>. However, if the user likes <c>var</c> for everything and you have <c>var i = 0</c>,
            then it's still possible to convert that, it would just be <see langword="false"/> for
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult.IsStylePreferred"/> because it goes against the user's preferences.
            </summary>
            <remarks>
            <para>In general, most features should only convert the type if <see cref="F:Microsoft.CodeAnalysis.CSharp.Utilities.TypeStyleResult.IsStylePreferred"/> is
            <see langword="true"/>. The one exception is the refactoring, which is explicitly there to still let people
            convert things quickly, even if it's going against their stated style.</para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper.State.IsTypeApparentInDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.CodeStyle.TypeStyle.UseVarPreference,System.Threading.CancellationToken)">
            <summary>
            Returns true if type information could be gleaned by simply looking at the given statement.
            This typically means that the type name occurs in right hand side of an assignment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper.State.IsPredefinedTypeInDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel)">
            <summary>
            checks if the type represented by the given symbol is one of the
            simple types defined in the compiler.
            </summary>
            <remarks>
            From the IDE perspective, we also include object and string to be simplified
            to var. <see cref="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsPredefinedType(Microsoft.CodeAnalysis.CSharp.SyntaxKind)"/> considers string
            and object but the compiler's implementation of IsIntrinsicType does not.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.CSharpTypeStyleHelper.State.IsMadeOfSpecialTypes(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Returns true for type that are arrays/nullable/pointer types of special types
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseExplicitTypeHelper.AssignmentSupportsStylePreference(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Analyzes the assignment expression and rejects a given declaration if it is unsuitable for explicit typing.
            </summary>
            <returns>
            false, if explicit typing cannot be used.
            true, otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.CSharpUseImplicitTypeHelper.AssignmentSupportsStylePreference(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Analyzes the assignment expression and rejects a given declaration if it is unsuitable for implicit typing.
            </summary>
            <returns>
            false, if implicit typing cannot be used.
            true, otherwise.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Utilities.FormattingRangeHelper">
            <summary>
            this help finding a range of tokens to format based on given ending token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer">
            <summary>
            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
            Given an expression node from a syntax tree and a new expression from a different syntax tree,
            it replaces the expression with the new expression to create a speculated syntax tree.
            It uses the original tree's semantic model to create a speculative semantic model and verifies that
            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.#ctor(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Creates a semantic analyzer for speculative syntax replacement.
            </summary>
            <param name="expression">Original expression to be replaced.</param>
            <param name="newExpression">New expression to replace the original expression.</param>
            <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="skipVerificationForReplacedNode">
            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
            This could be the case when custom verifications are required to be done by the caller or
            semantics of the replaced expression are different from the original expression.
            </param>
            <param name="failOnOverloadResolutionFailuresInOriginalCode">
            True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.ReplacementChangesSemanticsOfUnchangedLambda(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Determines whether performing the syntax replacement in one of the sibling nodes of the given lambda expressions will change the lambda binding semantics.
            This is done by first determining the lambda parameters whose type differs in the replaced lambda node.
            For each of these parameters, we find the descendant identifier name nodes in the lambda body and check if semantics of any of the parenting nodes of these
            identifier nodes have changed in the replaced lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Utilities.SpeculationAnalyzer.ReplacementBreaksBoxingInConditionalExpression(Microsoft.CodeAnalysis.TypeInfo,Microsoft.CodeAnalysis.TypeInfo,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Checks if the conversion might change the resultant boxed type.
            Similar boxing checks are performed elsewhere, but in this case we need to perform the check on the entire conditional expression.
            This will make sure the resultant cast is proper for the type of the conditional expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference">
            <summary>
            Defines the known values for <see cref="F:Microsoft.CodeAnalysis.CSharp.CodeStyle.CSharpCodeStyleOptions.PreferBraces"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.None">
            <summary>
            Braces are allowed, but not preferred.
            </summary>
            <remarks>
            <para>The value <c>0</c> is important for serialization compatibility in
            <see cref="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1.FromXElement(System.Xml.Linq.XElement)"/>. Prior to the use of this enum, the serialized value
            was the <see cref="T:System.Boolean"/> value <see langword="false"/>.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.Always">
             <summary>
             <para>Braces are preferred where allowed except in the following limited situations:</para>
            
             <list type="bullet">
             <item><description>Braces are not required for the embedded statement of an <c>else</c> clause when the embedded statement is an <c>if</c> statement.</description></item>
             <item><description>In a sequence of consecutive <c>using</c> statements, only the last statement requires braces.</description></item>
             <item><description>In a sequence of consecutive <c>lock</c> statements, only the last statement requires braces.</description></item>
             <item><description>In a sequence of consecutive <c>fixed</c> statements, only the last statement requires braces.</description></item>
             </list>
             </summary>
             <remarks>
             <para>The value <c>1</c> is important for serialization compatibility in
             <see cref="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1.FromXElement(System.Xml.Linq.XElement)"/>. Prior to the use of this enum, the serialized value
             was the <see cref="T:System.Boolean"/> value <see langword="true"/>.</para>
             </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.WhenMultiline">
             <summary>
             <para>Braces are always allowed, and generally preferred except in limited situations involving single-line
             statements and expressions:</para>
            
             <list type="bullet">
             <item><description>Braces may be omitted in the cases described for <see cref="F:Microsoft.CodeAnalysis.CodeStyle.PreferBracesPreference.Always"/>.</description></item>
             <item><description>Braces may be omitted when the entire statement is placed on one line.</description></item>
             <item><description>For a statement that contains one or more embedded statements, braces may be omitted when
             every embedded statement fits on one line, and the part preceding the embedded statement is placed on one
             line. If any embedded statement uses braces, braces are preferred for all embedded statements of the same
             parent statement. For the purposes of evaluating this rule, if the embedded statement following an
             <c>else</c> keyword is an if statement, the embedded statements of the nested if statement are treated as
             children of the parent statement of the <c>else</c> keyword.</description></item>
             </list>
             </summary>
        </member>
    </members>
</doc>
