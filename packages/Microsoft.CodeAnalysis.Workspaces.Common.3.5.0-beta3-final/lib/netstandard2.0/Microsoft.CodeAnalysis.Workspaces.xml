<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.Workspaces</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.AddImports.AddImportPlacement">
            <summary>
            Specifies the desired placement of added imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImports.AddImportPlacement.InsideNamespace">
            <summary>
            Place imports inside the namespace definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.AddImports.AddImportPlacement.OutsideNamespace">
            <summary>
            Place imports outside the namespace definition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImports.IAddImportsService.HasExistingImport(Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the tree already has an existing import syntactically equivalent to
            <paramref name="import"/> in scope at <paramref name="contextLocation"/>.  This includes
            global imports for VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AddImports.IAddImportsService.GetImportContainer(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a context location in a provided syntax tree, returns the appropriate container
            that <paramref name="import"/> should be added to.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.Annotation">
            <summary>
            The annotation normally used on nodes to request case correction.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans of any nodes annotated with the provided
            annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the provided spans.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Case correct only things that don't require semantic information
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrectAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Case corrects all names found in the spans in the provided document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService.CaseCorrect(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Case corrects only things that don't require semantic information
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.ClassificationTypeNames.AdditiveTypeNames">
            <summary>
            Additive classifications types supply additional context to other classifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.ClassifierHelper.GetClassifiedSpansAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Classifies the provided <paramref name="span"/> in the given <paramref name="document"/>.
            This will do this using an appropriate <see cref="T:Microsoft.CodeAnalysis.Classification.IClassificationService"/>
            if that can be found.  <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/> will be returned if this
            fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddLexicalClassifications(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.List{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  Classification should be
            performed as quickly as possible, and should process the text in a lexical fashion.
            This allows classification results to be shown to the user when a file is opened before
            any additional compiler information is available for the text.
            
            Important: The classification should not consider the context the text exists in, and how
            that may affect the final classifications.  This may result in incorrect classification
            (i.e. identifiers being classified as keywords).  These incorrect results will be patched
            up when the lexical results are superseded by the calls to AddSyntacticClassifications.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSyntacticClassificationsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.List{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  The syntax of the document 
            can be accessed to provide more correct classifications.  For example, the syntax can
            be used to determine if a piece of text that looks like a keyword should actually be
            considered an identifier in its current context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AddSemanticClassificationsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.List{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            Produce the classifications for the span of text specified.  Semantics of the language
            can be used to provide richer information for constructs where syntax is insufficient.
            For example, semantic information can be used to determine if an identifier should be
            classified as a type, structure, or something else entirely. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.IClassificationService.AdjustStaleClassification(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Classification.ClassifiedSpan)">
            <summary>
            Adjust a classification from a previous version of text accordingly based on the current
            text.  For example, if a piece of text was classified as an identifier in a previous version,
            but a character was added that would make it into a keyword, then indicate that here.
            
            This allows the classified to quickly fix up old classifications as the user types.  These
            adjustments are allowed to be incorrect as they will be superseded by calls to get the
            syntactic and semantic classifications for this version later.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxNodeTypes">
            <summary>
            The syntax node types this classifier is able to classify
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxTokenKinds">
            <summary>
            The syntax token kinds this classifier is able to classify
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            This method will be called for all nodes that match the types specified by the <see cref="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxNodeTypes"/> property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.AddClassifications(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.Classification.ClassifiedSpan},System.Threading.CancellationToken)">
            <summary>
            This method will be called for all tokens that match the kinds specified by the <see cref="P:Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier.SyntaxTokenKinds"/> property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate a conflict may exist that requires user understanding and acknowledgment before taking action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.NavigationAnnotation">
            <summary>
            Apply this annotation to an appropriate Syntax element to request that it should be 
            navigated to by the user after a code action is applied.  If present the host should
            try to place the user's caret at the beginning of the element.
            </summary>
            <remarks>
            By using a <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/> this navigation location will be resilient
            to the transformations performed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> infrastructure.  
            Namely it will be resilient to the formatting, reduction or case correction that
            automatically occures.  This allows a code action to specify a desired location for
            the user caret to be placed without knowing what actual position that location will
            end up at when the action is finally applied.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.RenameAnnotation">
            <summary>
            Apply this annotation to an appropriate SyntaxNode to request that it should be renamed by the user after the action.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.WarningAnnotation">
            <summary>
            Apply this annotation to a SyntaxNode to indicate that a warning message should be presented to the user.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeAction">
            <summary>
            An action produced by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Title">
            <summary>
            A short title describing the action that may appear in a menu.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey">
             <summary>
             Two code actions are treated as equivalent if they have equal non-null <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values and were generated
             by the same <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> or <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
             </summary>
             <remarks>
             Equivalence of code actions affects some Visual Studio behavior. For example, if multiple equivalent
             code actions result from code fixes or refactorings for a single Visual Studio light bulb instance,
             the light bulb UI will present only one code action from each set of equivalent code actions.
             Additionally, a Fix All operation will apply only code actions that are equivalent to the original code action.
            
             If two code actions that could be treated as equivalent do not have equal <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values, Visual Studio behavior
             may be less helpful than would be optimal. If two code actions that should be treated as distinct have
             equal <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> values, Visual Studio behavior may appear incorrect.
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.Tags">
            <summary>
            Descriptive tags from <see cref="T:Microsoft.CodeAnalysis.Tags.WellKnownTags"/>.
            These tags may influence how the item is displayed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations that define the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsCoreAsync(Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker,System.Threading.CancellationToken)">
            <summary>
            The sequence of operations that define the code action.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            The sequence of operations used to construct a preview.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that includes custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputePreviewOperationsAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that has a set of preview operations that are different
            than the operations produced by <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.ComputeOperationsAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionAsync(System.Threading.CancellationToken)">
            <summary>
            Computes all changes for an entire solution.
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes more than one document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedDocumentAsync(System.Threading.CancellationToken)">
            <summary>
            Computes changes for a single document.
            Override this method if you want to implement a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> subclass that changes a single document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetChangedSolutionInternalAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>
            used by batch fixer engine to get new solution
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessAsync(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CodeActions.CodeActionOperation},System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.
            </summary>
            <param name="operations">A list of operations.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A new list of operations with post processing steps applied to any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>'s.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
             Apply post processing steps to solution changes, like formatting and simplification.
            </summary>
            <param name="changedSolution">The solution changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.PostProcessChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Apply post processing steps to a single document:
              Reducing nodes annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation"/>
              Formatting nodes annotated with <see cref="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation"/>
            </summary>
            <param name="document">The document changed by the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>A document with the post processing changes applied.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.IsApplicable(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Called by the CodeActions on the UI thread to determine if the CodeAction is still
            applicable and should be presented to the user.  CodeActions can override this if they
            need to do any final checking that must be performed on the UI thread (for example
            accessing and querying the Visual Studio DTE).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Document}},System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> for a change to a single <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            Use this factory when the change is expensive to compute and should be deferred until requested.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="createChangedDocument">Function to create the <see cref="T:Microsoft.CodeAnalysis.Document"/>.</param>
            <param name="equivalenceKey">Optional value used to determine the equivalence of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with other <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>s. See <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.Solution}},System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> for a change to more than one <see cref="T:Microsoft.CodeAnalysis.Document"/> within a <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            Use this factory when the change is expensive to compute and should be deferred until requested.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.</param>
            <param name="createChangedSolution">Function to create the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.</param>
            <param name="equivalenceKey">Optional value used to determine the equivalence of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> with other <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>s. See <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.Create(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Boolean)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> representing a group of code actions.
            </summary>
            <param name="title">Title of the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> group.</param>
            <param name="nestedActions">The code actions within the group.</param>
            <param name="isInlinable"><see langword="true"/> to allow inlining the members of the group into the parent;
            otherwise, <see langword="false"/> to require that this group appear as a group with nested actions.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that can vary with user specified options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)">
            <summary>
            Gets the options to use with this code action.
            This method is guaranteed to be called on the UI thread.
            </summary>
            <param name="cancellationToken">A cancellation token.</param>
            <returns>An implementation specific object instance that holds options for applying the code action.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>'s for this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> given the specified options.
            </summary>
            <param name="options">An object instance returned from a prior call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.ComputeOperationsAsync(System.Object,System.Threading.CancellationToken)">
            <summary>
            Override this method to compute the operations that implement this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>.
            </summary>
            <param name="options">An object instance returned from a call to <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions.GetOptions(System.Threading.CancellationToken)"/>.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/> for applying solution changes to a workspace.
            <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/> may return at most one
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>. Hosts may provide custom handling for 
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>s, but if a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> requires custom
            host behavior not supported by a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>, then instead:
            <list type="bullet">
            <description><text>Implement a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> and <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>s</text></description>
            <description><text>Do not return any <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> from <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetOperationsAsync(System.Threading.CancellationToken)"/></text></description>
            <description><text>Directly apply any workspace edits</text></description>
            <description><text>Handle any custom host behavior</text></description>
            <description><text>Produce a preview for <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.GetPreviewOperationsAsync(System.Threading.CancellationToken)"/> 
              by creating a custom <see cref="T:Microsoft.CodeAnalysis.CodeActions.PreviewOperation"/> or returning a single <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/>
              to use the built-in preview mechanism</text></description>
            </list>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation">
            <summary>
            Represents a single operation of a multi-operation code action.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title">
            <summary>
            A short title describing of the effect of the operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Apply(Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Called by the host environment to apply the effect of the operation.
            This method is guaranteed to be called on the UI thread.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.ApplyDuringTests">
            <summary>
            Operations may make all sorts of changes that may not be appropriate during testing
            (like popping up UI). So, by default, we don't apply them unless the operation asks
            for that to happen.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation">
            <summary>
            A code action operation for requesting a document be opened in the host environment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeActions.PreviewOperation">
            <summary>
            Represents a preview operation for generating a custom user preview for the operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeActions.PreviewOperation.GetPreviewAsync(System.Threading.CancellationToken)">
            <summary>
            Gets a custom preview control for the operation.
            If preview is null and <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title"/> is non-null, then <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation.Title"/> is used to generate the preview.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetPreviousTokenStartPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper start position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNextTokenEndPosition(Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Get the proper end position based on the span marker type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.AnnotateNodeForTextSpans(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Inject annotations into the node so that it can re-calculate spans for each code cleaner after each tree transformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetNonOverlappingSpans(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Make sure annotations are positioned outside of any spans. If not, merge two adjacent spans to one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetTokensAroundSpan(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
             <summary>
             Retrieves four tokens around span like below.
            
             [previousToken][startToken][SPAN][endToken][nextToken]
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.GetSpanAlignedToTokens(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            Adjust provided span to align to either token's start position or end position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) right of given position
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Find closest token (including one in structured trivia) left of given position
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType">
            <summary>
            Enum that indicates type of span marker
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.Normal">
            <summary>
            Normal case
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.BeginningOfFile">
            <summary>
            Span starts at the beginning of the tree
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarkerType.EndOfFile">
            <summary>
            Span ends at the end of the tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker">
            <summary>
            Internal annotation type to mark span location in the tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.Type">
            <summary>
            Indicates the current marker type
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService.SpanMarker.OppositeMarkerType">
            <summary>
            Indicates how to find the other side of the span marker if it is missing
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner">
            <summary>
            Static CodeCleaner class that provides default code cleaning behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.GetDefaultProviders(Microsoft.CodeAnalysis.Document)">
            <summary>
            Return default code cleaners for a given document.
            
            This can be modified and given to the Cleanup method to provide different cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the whole document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Cleans up the document marked with the provided annotation.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the document.
            Optionally you can provide your own options and code cleaners. Otherwise, the default will be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided span in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            Clean up the provided spans in the node.
            This will only cleanup stuff that doesn't require semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService">
            <summary>
            Internal code cleanup service interface.
            
            This is not supposed to be used directly. It just provides a way to get the right service from each language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.GetDefaultProviders">
            <summary>
            Returns the default code cleaners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider},System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider">
            <summary>
            Specifies the exact type of the code cleanup exported.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider">
            <summary>
            A code cleaner that requires semantic information to do its job.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.Name">
            <summary>
            Returns the name of this provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.CleanupAsync(Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            This should apply its code clean up logic to the spans of the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider.CleanupAsync(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            This will run all provided code cleaners in an order that is given to the method.
            
            This will do cleanups that don't require any semantic information
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider">
            <summary>
            Helper class that implements <see cref="T:Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider"/> using delegates passed to its constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix">
            <summary>
            Represents a single fix. This is essentially a tuple
            that holds on to a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> and the set of
            <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s that this <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> will fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic">
            <summary>
            This is the diagnostic that will show up in the preview pane header when a particular fix
            is selected in the light bulb menu. We also group all fixes with the same <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>
            together (into a single SuggestedActionSet) in the light bulb menu.
            </summary>
            <remarks>
            A given fix can fix one or more diagnostics. However, our light bulb UI (preview pane, grouping
            of fixes in the light bulb menu etc.) currently keeps things simple and pretends that
            each fix fixes a single <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>.
            
            Implementation-wise the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/> is always the first diagnostic that
            the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> supplied when registering the fix (<see 
            cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})"/>). This could change
            in the future, if we decide to change the UI to depict the true mapping between fixes and diagnostics
            or if we decide to use some other heuristic to determine the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFix.PrimaryDiagnostic"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory">
            <summary>
            Code fix category for code fixes provided by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.CodeStyle">
            <summary>
            Fixes code to adhere to code style.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.CodeQuality">
            <summary>
            Fixes code to improve code quality.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.Compile">
            <summary>
            Fixes code to fix compiler diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeFixes.CodeFixCategory.Custom">
            <summary>
            Custom category for fix.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext">
            <summary>
            Context for code fixes provided by a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Document">
            <summary>
            Document corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span"/> to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Project">
            <summary>
            Project corresponding to the diagnostics to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span">
            <summary>
            Text span within the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Document"/> to fix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics">
            <summary>
            Diagnostics to fix.
            NOTE: All the diagnostics in this collection have the same <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Span"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.CancellationToken">
            <summary>
            CancellationToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic},System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Document to fix.</param>
            <param name="span">Text span within the <paramref name="document"/> to fix.</param>
            <param name="diagnostics">
            Diagnostics to fix.
            All the diagnostics must have the same <paramref name="span"/>.
            Additionally, the <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of each diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
            <exception cref="T:System.ArgumentException">
            Throws this exception if the given <paramref name="diagnostics"/> is empty,
            has a null element or has an element whose span is not equal to <paramref name="span"/>.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Diagnostic,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic}},System.Threading.CancellationToken)">
            <summary>
            Creates a code fix context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)"/> method.
            </summary>
            <param name="document">Document to fix.</param>
            <param name="diagnostic">
            Diagnostic to fix.
            The <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> of this diagnostic must be in the set of the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> of the associated <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.
            </param>
            <param name="registerCodeFix">Delegate to register a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> fixing a subset of diagnostics.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.ArgumentNullException">Throws this exception if any of the arguments is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostic">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostics">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.RegisterCodeFix(Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Add supplied <paramref name="action"/> to the list of fixes that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the fix.</param>
            <param name="diagnostics">The subset of <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext.Diagnostics"/> being addressed / fixed by the <paramref name="action"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider">
            <summary>
            Implement this type to provide fixes for source code problems.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute"/> so the host environment can offer your fixes in a UI.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds">
            <summary>
            A list of diagnostic IDs that this provider can provide fixes for.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.RegisterCodeFixesAsync(Microsoft.CodeAnalysis.CodeFixes.CodeFixContext)">
            <summary>
            Computes one or more fixes for the specified <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext"/>.
            </summary>
            <param name="context">
            A <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixContext"/> containing context information about the diagnostics to fix.
            The context must only contain diagnostics with a <see cref="P:Microsoft.CodeAnalysis.Diagnostic.Id"/> included in the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> for the current provider.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.GetFixAllProvider">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that can fix all/multiple occurrences of diagnostics fixed by this code fix provider.
            Return null if the provider doesn't support fix all/multiple occurrences.
            Otherwise, you can return any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/> or implement your own fix all provider.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Name">
            <summary>
            Optional name of the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.Languages">
            <summary>
            The source languages this provider can provide fixes for.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify automatic application of a code fix provider.
            </summary>
            <param name="firstLanguage">One language to which the code fix provider applies.</param>
            <param name="additionalLanguages">Additional languages to which the code fix provider applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider">
            <summary>
            Helper class for "Fix all occurrences" code fix providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider.TryAddDocumentMergeChangesAsync(Microsoft.CodeAnalysis.IDocumentTextDifferencingService,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree{Microsoft.CodeAnalysis.Text.TextChange,Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider.TextChangeIntervalIntrospector},System.Threading.CancellationToken)">
            <summary>
            Try to merge the changes between <paramref name="newDocument"/> and <paramref name="oldDocument"/>
            into <paramref name="cumulativeChanges"/>. If there is any conflicting change in 
            <paramref name="newDocument"/> with existing <paramref name="cumulativeChanges"/>, then no
            changes are added
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext">
            <summary>
            Context for "Fix all occurrences" code fixes provided by a <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
            <summary>
            Context for "Fix all occurrences" code fixes provided by a <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.FixAllProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Solution">
            <summary>
            Solution to fix all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Project">
            <summary>
            Project within which fix all occurrences was triggered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Document">
            <summary>
            Document within which fix all occurrences was triggered.
            Can be null if the context was created using <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CodeFixProvider">
            <summary>
            Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.Scope">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds">
            <summary>
            Diagnostic Ids to fix.
            Note that <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document)"/>, <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project)"/> and <see cref="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project)"/> methods
            return only diagnostics whose IDs are contained in this set of Ids.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CodeActionEquivalenceKey">
            <summary>
            The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.CancellationToken">
            <summary>
            CancellationToken for fix all session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            Use this overload when applying fix all to a diagnostic with a source location.
            </summary>
            <param name="document">Document within which fix all occurrences was triggered.</param>
            <param name="codeFixProvider">Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.</param>
            <param name="scope"><see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.</param>
            <param name="codeActionEquivalenceKey">The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.</param>
            <param name="diagnosticIds">Diagnostic Ids to fix.</param>
            <param name="fixAllDiagnosticProvider">
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </param>
            <param name="cancellationToken">Cancellation token for fix all computation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.#ctor(Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider,Microsoft.CodeAnalysis.CodeFixes.FixAllScope,System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            Use this overload when applying fix all to a diagnostic with no source location, i.e. <see cref="P:Microsoft.CodeAnalysis.Location.None"/>.
            </summary>
            <param name="project">Project within which fix all occurrences was triggered.</param>
            <param name="codeFixProvider">Underlying <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider"/> which triggered this fix all.</param>
            <param name="scope"><see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/> to fix all occurrences.</param>
            <param name="codeActionEquivalenceKey">The <see cref="P:Microsoft.CodeAnalysis.CodeActions.CodeAction.EquivalenceKey"/> value expected of a <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> participating in this fix all.</param>
            <param name="diagnosticIds">Diagnostic Ids to fix.</param>
            <param name="fixAllDiagnosticProvider">
            <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider"/> to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </param>
            <param name="cancellationToken">Cancellation token for fix all computation.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets all the diagnostics in the given document filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets all the project-level diagnostics, i.e. diagnostics with no source location, in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets all the diagnostics in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            This includes both document-level diagnostics for all documents in the given project and project-level diagnostics, i.e. diagnostics with no source location, in the given project. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Boolean)">
            <summary>
            Gets all the project diagnostics in the given project filtered by <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticIds"/>.
            If <paramref name="includeAllDocumentDiagnostics"/> is false, then returns only project-level diagnostics which have no source location.
            Otherwise, returns all diagnostics in the project, including the document diagnostics for all documents in the given project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.WithCancellationToken(System.Threading.CancellationToken)">
            <summary>
            Gets a new <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/> with the given cancellationToken.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetDocumentDiagnosticsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics to fix in the given document in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetProjectDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Gets all the project-level diagnostics to fix, i.e. diagnostics with no source location, in the given project in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllContext.DiagnosticProvider.GetAllDiagnosticsAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Gets all the diagnostics to fix in the given project in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            This includes both document-level diagnostics for all documents in the given project and project-level diagnostics, i.e. diagnostics with no source location, in the given project. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllLogger">
            <summary>
            Fix all occurrences logging.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider">
            <summary>
            Implement this abstract type to provide fix all/multiple occurrences code fixes for source code problems.
            Alternatively, you can use any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetSupportedFixAllScopes">
            <summary>
            Gets the supported scopes for fixing all occurrences of a diagnostic.
            By default, it returns the following scopes:
            (a) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>
            (b) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/> and
            (c) <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetSupportedFixAllDiagnosticIds(Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider)">
            <summary>
            Gets the diagnostic IDs for which fix all occurrences is supported.
            By default, it returns <see cref="P:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.FixableDiagnosticIds"/> for the given <paramref name="originalCodeFixProvider"/>.
            </summary>
            <param name="originalCodeFixProvider">Original code fix provider that returned this fix all provider from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider.GetFixAllProvider"/> method.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider.GetFixAsync(Microsoft.CodeAnalysis.CodeFixes.FixAllContext)">
            <summary>
            Gets fix all occurrences fix for the given fixAllContext.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo">
            <summary>
            Contains computed information for a given <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>, such as supported diagnostic Ids and supported <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo.Create(System.Object)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo"/> for the given code fix provider or suppression fix provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo.CreateWithCodeFixer(Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo"/> for the given code fix provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo.CreateWithSuppressionFixer(Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider)">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo"/> for the given suppression fix provider.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllScope">
            <summary>
            Indicates scope for "Fix all occurrences" code fixes provided by each <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState.FixMultipleDiagnosticProvider">
            <summary>
            Diagnostic provider to fetch document/project diagnostics to fix in a <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllContext"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders">
            <summary>
            Contains well known implementations of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders.BatchFixer">
            <summary>
            Default batch fix all provider.
            This provider batches all the individual diagnostic fixes across the scope of fix all action,
            computes fixes in parallel and then merges all the non-conflicting fixes into a single fix all code action.
            This fixer supports fixes for the following fix all scopes:
            <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Document"/>, <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Project"/> and <see cref="F:Microsoft.CodeAnalysis.CodeFixes.FixAllScope.Solution"/>.
            </summary>
            <remarks>
            The batch fix all provider only batches operations (i.e. <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeActionOperation"/>) of type
            <see cref="T:Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation"/> present within the individual diagnostic fixes. Other types of
            operations present within these fixes are ignored.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider">
            <summary>
            Provides suppression or configuration code fixes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.IsFixableDiagnostic(Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Returns true if the given diagnostic can be configured, suppressed or unsuppressed by this provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Gets one or more add suppression, remove suppression, or configuration fixes for the specified diagnostics represented as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more potential <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>'es. It is also safe to return null if there are none.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixesAsync(Microsoft.CodeAnalysis.Project,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic},System.Threading.CancellationToken)">
            <summary>
            Gets one or more add suppression, remove suppression, or configuration fixes for the specified no-location diagnostics represented as a list of <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/>'s.
            </summary>
            <returns>A list of zero or more potential <see cref="T:Microsoft.CodeAnalysis.CodeFixes.CodeFix"/>'es. It is also safe to return null if there are none.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider.GetFixAllProvider">
            <summary>
            Gets an optional <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that can fix all/multiple occurrences of diagnostics fixed by this fix provider.
            Return null if the provider doesn't support fix all/multiple occurrences.
            Otherwise, you can return any of the well known fix all providers from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders"/> or implement your own fix all provider.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.CodeFixes.FixAllState,Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)">
             <summary>
             Whether or not this diagnostic should be included when performing a FixAll.  This is
             useful for providers that create multiple diagnostics for the same issue (For example,
             one main diagnostic and multiple 'faded out code' diagnostics).  FixAll can be invoked
             from any of those, but we'll only want perform an edit for only one diagnostic for each
             of those sets of diagnostics.
            
             This overload differs from <see cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)"/> in
             that it also passes along the <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/> in case that would be useful
             (for example if the <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllState.CodeActionEquivalenceKey"/> is used.  
            
             Only one of these two overloads needs to be overridden if you want to customize
             behavior.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.Diagnostic)">
             <summary>
             Whether or not this diagnostic should be included when performing a FixAll.  This is
             useful for providers that create multiple diagnostics for the same issue (For example,
             one main diagnostic and multiple 'faded out code' diagnostics).  FixAll can be invoked
             from any of those, but we'll only want perform an edit for only one diagnostic for each
             of those sets of diagnostics.
            
             By default, all diagnostics will be included in fix-all unless they are filtered out
             here. If only the diagnostic needs to be queried to make this determination, only this
             overload needs to be overridden.  However, if information from <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllState"/>
             is needed (for example <see cref="P:Microsoft.CodeAnalysis.CodeFixes.FixAllState.CodeActionEquivalenceKey"/>), then <see
             cref="M:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.IncludeDiagnosticDuringFixAll(Microsoft.CodeAnalysis.CodeFixes.FixAllState,Microsoft.CodeAnalysis.Diagnostic,System.Threading.CancellationToken)"/>
             should be overridden instead.
            
             Only one of these two overloads needs to be overridden if you want to customize
             behavior.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider.SyntaxEditorBasedFixAllProvider">
            <summary>
            A simple implementation of <see cref="T:Microsoft.CodeAnalysis.CodeFixes.FixAllProvider"/> that takes care of collecting
            all the diagnostics and fixes all documents in parallel.  The only functionality a 
            subclass needs to provide is how each document will apply all the fixes to all the 
            diagnostics in that document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService.FindMostRelevantNameSpaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Return the most relevant declaration to namespaceOrType,
            it will first search the context node contained within,
            then the declaration in the same file, then non auto-generated file,
            then all the potential location. Return null if no declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions">
            <summary>
            Options for controlling the code produced by the <see cref="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ContextLocation">
            <summary>
            A location used to determine the best place to generate a member.  This is only used for
            determining which part of a partial type to generate in.  If a type only has one part, or
            an API is used that specifies the type, then this is not used.  A part is preferred if
            it surrounds this context location. If no part surrounds this location then a part is
            preferred if it comes from the same SyntaxTree as this location.  If there is no
            such part, then any part may be used for generation.
            
            This option is not necessary if <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AfterThisLocation"/> or <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.BeforeThisLocation"/> are
            provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AfterThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated after this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it.
            
            If this option is provided, neither <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ContextLocation"/> nor <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.BeforeThisLocation"/> are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.BeforeThisLocation">
            <summary>
            A hint to the code generation service to specify where the generated code should be
            placed.  Code will be generated before this location if the location is valid in the type
            or symbol being generated into, and it is possible to generate the code after it. 
            
            If this option is provided, neither <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ContextLocation"/> nor <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AfterThisLocation"/> are
            needed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AddImports">
            <summary>
            True if the code generation service should add <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.AddImportsAnnotation"/>,
            and when not generating directly into a declaration, should try to automatically add imports to the file
            for any generated code.
            Defaults to true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.PlaceSystemNamespaceFirst">
            <summary>
            True if, when adding a System import, the import should be placed above non-System
            imports.  Defaults to true.  Only used if <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AddImports"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AdditionalImports">
            <summary>
            Contains additional imports to be automatically added.  This is useful for adding
            imports that are part of a list of statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateMembers">
            <summary>
            True if members of a symbol should also be generated along with the declaration.  If
            false, only the symbol's declaration will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.MergeNestedNamespaces">
            <summary>
            True if the code generator should merge namespaces which only contain other namespaces
            into a single declaration with a dotted name.  False if the nesting should be preserved
            and each namespace declaration should be nested and should only have a single non-dotted
            name.
            
            Merging can only occur if the namespace only contains a single member that is also a
            namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.MergeAttributes">
            <summary>
            True if the code generation should put multiple attributes in a single attribute
            declaration, or if should have a separate attribute declaration for each attribute.  For
            example, in C# setting this to True this would produce "[Goo, Bar]" while setting it to
            False would produce "[Goo][Bar]"
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateDefaultAccessibility">
            <summary>
            True if the code generator should always generate accessibility modifiers, even if they
            are the same as the defaults for that symbol.  For example, a private field in C# does
            not need its accessibility specified as it will be private by default.  However, if this
            option is set to true 'private' will still be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateMethodBodies">
            <summary>
            True if the code generator should generate empty bodies for methods along with the
            method declaration.  If false, only method declarations will be generated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.GenerateDocumentationComments">
            <summary>
            True if the code generator should generate documentation comments where available
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AutoInsertionLocation">
            <summary>
            True if the code generator should automatically attempt to choose the appropriate location
            to insert members.  If false and a generation location is not specified by AfterThisLocation,
            or BeforeThisLocation, members will be inserted at the end of the destination definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.SortMembers">
            <summary>
            If <see cref="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.AutoInsertionLocation"/> is <see langword="false"/>, determines if members will be
            sorted before being added to the end of the list of members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions.ReuseSyntax">
            <summary>
            True if the code generator should attempt to reuse the syntax of the constituent entities, such as members, access modifier tokens, etc. while attempting to generate code.
            If any of the member symbols have zero declaring syntax references (non-source symbols) OR two or more declaring syntax references (partial definitions), then syntax is not reused.
            If false, then the code generator will always synthesize a new syntax node and ignore the declaring syntax references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory">
            <summary>
            Generates symbols that describe declarations to be generated.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.IsCodeGenerationSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is purely a code generation symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateEventSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IEventSymbol},System.String,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Creates an event symbol that can be used to describe an event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePropertySymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IPropertySymbol},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,System.Boolean)">
            <summary>
            Creates a property symbol that can be used to describe a property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateFieldSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Object,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field symbol that can be used to describe a field declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConstructorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a constructor symbol that can be used to describe a constructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDestructorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a destructor symbol that can be used to describe a destructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateMethodSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IMethodSymbol},System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Creates a method symbol that can be used to describe a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateOperatorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData})">
            <summary>
            Creates a method symbol that can be used to describe an operator declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateConversionSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.IParameterSymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData})">
            <summary>
            Creates a method symbol that can be used to describe a conversion declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.RefKind,System.Boolean,Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Boolean,System.Boolean,System.Object)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateParameterSymbol(Microsoft.CodeAnalysis.IParameterSymbol,System.Nullable{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData}},System.Nullable{Microsoft.CodeAnalysis.RefKind},System.Nullable{System.Boolean},Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.Optional{System.String},System.Nullable{System.Boolean},System.Nullable{System.Boolean},Microsoft.CodeAnalysis.Optional{System.Object})">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameterSymbol(System.String,System.Int32)">
            <summary>
            Creates a parameter symbol that can be used to describe a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateTypeParameter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.VarianceKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeSymbol},Microsoft.CodeAnalysis.NullableAnnotation,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            Creates a type parameter symbol that can be used to describe a type parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates a pointer type symbol that can be used to describe a pointer type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.ITypeSymbol,System.Int32,Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Creates an array type symbol that can be used to describe an array type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAccessorSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an method type symbol that can be used to describe an accessor method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateAttributeData(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{System.String,Microsoft.CodeAnalysis.TypedConstant}})">
            <summary>
            Create attribute data that can be used in describing an attribute declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamedTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.TypeKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.INamedTypeSymbol},Microsoft.CodeAnalysis.SpecialType,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Creates a named type symbol that can be used to describe a named type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateDelegateTypeSymbol(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.AttributeData},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.RefKind,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ITypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.NullableAnnotation)">
            <summary>
            Creates a method type symbol that can be used to describe a delegate type declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory.CreateNamespaceSymbol(System.String,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},System.Collections.Generic.IList{Microsoft.CodeAnalysis.INamespaceOrTypeSymbol})">
            <summary>
            Creates a namespace symbol that can be used to describe a namespace declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator">
            <summary>
            A generator used for creating or modifying member declarations in source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.Annotation">
            <summary>
            Annotation placed on generated syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created event declaration node from the provided event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddEventDeclaration``1(``0,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with an event declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddFieldDeclaration``1(``0,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a field declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMethodDeclaration``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a method declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddPropertyDeclaration``1(``0,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a property declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclaration``1(``0,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with a named type declaration of the same signature as the specified symbol added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMemberDeclarations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with multiple member declarations of the same signatures as the specified symbols added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddParameterDeclarations``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with one or more parameter declarations of the same signature as the specified symbols added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddAttributes``1(``0,Microsoft.CodeAnalysis.Workspace,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AttributeData},System.Nullable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new declaration node with the specified attributes added to it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.AttributeData,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Removes the specified attribute node from the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Removes the specified attribute node from the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddStatements``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Create a new declaration node with one or more statements added to its body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddEventDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional event of the same signature as the specified event symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddFieldDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional field of the same signature as the specified field symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMethodDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional method of the same signature as the specified method symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddPropertyDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional property of the same signature as the specified property symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamedTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional named type of the same signature as the specified named type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace of the same signature as the specified namespace symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddNamespaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has an additional namespace or type of the same signature as the specified namespace or type symbol.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.AddMemberDeclarationsAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Create a new solution where the declaration of the destination symbol has additional members of the same signature as the specified member symbols.
            Returns the document in the new solution where the destination symbol is declared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator.CanAdd(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if additional declarations can be added to the destination symbol's declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created event declaration node from the provided event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateFieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created field declaration node from the provided field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateMethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created method declaration node from the provided method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreatePropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions)">
            <summary>
            Returns a newly created property declaration node from the provided property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamedTypeDeclaration(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created named type declaration node from the provided named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CreateNamespaceDeclaration(Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Returns a newly created namespace declaration node from the provided namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEvent``1(``0,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds an event into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddField``1(``0,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethod``1(``0,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddProperty``1(``0,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a property into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedType``1(``0,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespace``1(``0,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds members into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddParameters``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IParameterSymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the parameters to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddAttributes``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.AttributeData},System.Nullable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the attributes to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.RemoveAttribute``1(``0,Microsoft.CodeAnalysis.AttributeData,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Remove the given attribute from destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationModifiers``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the modifiers list for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationAccessibility``1(``0,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the accessibility modifiers for the given declaration node, retaining the trivia of the existing modifiers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationType``1(``0,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Update the type for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.UpdateDeclarationMembers``1(``0,System.Collections.Generic.IList{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Replace the existing members with the given newMembers for the given declaration node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddStatements``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds the statements to destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddEventAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IEventSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddFieldAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a field with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMethodAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a method with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddPropertyAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a property with the provided signature into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamedTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a named type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddNamespaceOrTypeAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds a namespace or type into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.AddMembersAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Adds all the provided members into destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.CanAddTo(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            <c>true</c> if destination is a location where other symbols can be added to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService.FindMostRelevantNameSpaceOrTypeDeclarationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions,System.Threading.CancellationToken)">
            <summary>
            Return the most relevant declaration to namespaceOrType,
            it will first search the context node contained within,
            then the declaration in the same file, then non auto-generated file,
            then all the potential location. Return null if no declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues">
            <summary>
            When we are generating literals, we sometimes want to emit code vs. the numeric literal. This class
            gives the constants for all ones we want to convert
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext">
            <summary>
            Context for code refactorings provided by a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Document">
            <summary>
            Document corresponding to the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Span"/> to refactor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Span">
            <summary>
            Text span within the <see cref="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.Document"/> to refactor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.CancellationToken">
            <summary>
            CancellationToken.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction},System.Threading.CancellationToken)">
            <summary>
            Creates a code refactoring context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.#ctor(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Action{Microsoft.CodeAnalysis.CodeActions.CodeAction,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan}},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a code refactoring context to be passed into <see cref="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.RegisterRefactoring(Microsoft.CodeAnalysis.CodeActions.CodeAction)">
            <summary>
            Add supplied <paramref name="action"/> to the list of refactorings that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the refactoring.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext.RegisterRefactoring(Microsoft.CodeAnalysis.CodeActions.CodeAction,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Add supplied <paramref name="action"/> applicable to <paramref name="applicableToSpan"/> to the list of refactorings that will be offered to the user.
            </summary>
            <param name="action">The <see cref="T:Microsoft.CodeAnalysis.CodeActions.CodeAction"/> that will be invoked to apply the refactoring.</param>
            <param name="applicableToSpan">The <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> within original document the <paramref name="action"/> is applicable to.</param>
            <remarks>
            <paramref name="applicableToSpan"/> should represent a logical section within the original document that the <paramref name="action"/> is 
            applicable to. It doesn't have to precisely represent the exact <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> that will get changed.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider">
            <summary>
            Inherit this type to provide source code refactorings.
            Remember to use <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute"/> so the host environment can offer your refactorings in a UI.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider.ComputeRefactoringsAsync(Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext)">
            <summary>
            Computes one or more refactorings for the specified <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/> implementation so that it can be discovered by the host.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Name">
            <summary>
            The name of the <see cref="T:Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider"/>.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.Languages">
            <summary>
            The source languages for which this provider can provide refactorings. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute.#ctor(System.String,System.String[])">
            <summary>
            Attribute constructor used to specify availability of a code refactoring provider.
            </summary>
            <param name="firstLanguage">One language to which the code refactoring provider applies.</param>
            <param name="additionalLanguages">Additional languages to which the code refactoring provider applies. See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers.TryGetCodeStyleValueAndOptionalNotification(System.String,System.String@,Microsoft.CodeAnalysis.CodeStyle.NotificationOption@)">
            <summary>
            Given an editor-config code-style-option, gives back the constituent parts of the 
            option.  For example, if the option is "true:error" then "true" will be returned
            in <paramref name="value"/> and <see cref="F:Microsoft.CodeAnalysis.CodeStyle.NotificationOption.Error"/> will be returned
            in <paramref name="notificationOpt"/>.  Note that users are allowed to not provide
            a NotificationOption, so <paramref name="notificationOpt"/> may be null.  The caller
            of this method must decide what to do in that case.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1">
            <summary>
            Represents a code style option and an associated notification option.  Supports
            being instantiated with T as a <see cref="T:System.Boolean"/> or an <c>enum type</c>.
            
            CodeStyleOption also has some basic support for migration a <see cref="T:System.Boolean"/> option
            forward to an <c>enum type</c> option.  Specifically, if a previously serialized
            bool-CodeStyleOption is then deserialized into an enum-CodeStyleOption then 'false' 
            values will be migrated to have the 0-value of the enum, and 'true' values will be
            migrated to have the 1-value of the enum.
            
            Similarly, enum-type code options will serialize out in a way that is compatible with 
            hosts that expect the value to be a boolean.  Specifically, if the enum value is 0 or 1
            then those values will write back as false/true.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.TrueWithSilentEnforcement">
            <remarks>
            When user preferences are not yet set for a style, we fall back to the default value.
            One such default(s), is that the feature is turned on, so that codegen consumes it,
            but with silent enforcement, so that the user is not prompted about their usage.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyFieldAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in field access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyPropertyAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in property access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyMethodAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in method access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.QualifyEventAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in event access expressions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Declarations
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Member Access Expression
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference">
            <remarks>
            Note: the order of this enum is important.  We originally only supported two values,
            and we encoded this as a bool with 'true = WhenPossible' and 'false = never'.  To
            preserve compatibility we map the false value to 0 and the true value to 1.  All new
            values go after these. 
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption">
            <summary>
            Offers different notification styles for enforcing
            a code style. Under the hood, it simply maps to <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/>
            </summary>
            <remarks>
            This also supports various properties for databinding.
            </remarks>
            <completionlist cref="T:Microsoft.CodeAnalysis.CodeStyle.NotificationOption"/>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedParametersPreference">
            <summary>
            Preferences for flagging unused parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference">
            <summary>
            Assignment preference for unused values from expression statements and assignments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AnalysisKind">
            <summary>
            enum for each analysis kind.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.Language">
            <summary>
            Language name (<see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>) or null if the diagnostic is not associated with source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.PropertiesForBuildDiagnostic">
            <summary>
            Properties for a diagnostic generated by an explicit build.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.GetTextSpan">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> if it exists, throws otherwise.
            
            Some diagnostic data such as those created from build have original line/column but not <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>.
            In those cases use <see cref="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.GetTextSpan(Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation,Microsoft.CodeAnalysis.Text.SourceText)"/> method instead to calculate span from original line/column.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.TryCreate(Microsoft.CodeAnalysis.DiagnosticDescriptor,System.String[],Microsoft.CodeAnalysis.Project,Microsoft.CodeAnalysis.Diagnostics.DiagnosticData@)">
            <summary>
            Create a host/VS specific diagnostic with the given descriptor and message arguments for the given project.
            Note that diagnostic created through this API cannot be suppressed with in-source suppression due to performance reasons (see the PERF remark below for details).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.DiagnosticData.IsBuildDiagnostic">
            <summary>
            Returns true if the diagnostic was generated by an explicit build, not live analysis.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.MappedFilePath">
            <summary>
            Null if path is not mapped and <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.OriginalFilePath"/> contains the actual path.
            Note that the value might be a relative path. In that case <see cref="F:Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation.OriginalFilePath"/> should be used
            as a base path for path resolution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Extensions.ToDiagnosticSeverity(Microsoft.CodeAnalysis.ReportDiagnostic)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> for a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value; otherwise,
            <see langword="null"/> if <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> does not contain a direct equivalent for
            <paramref name="reportDiagnostic"/>.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="reportDiagnostic"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Extensions.WithDefaultSeverity(Microsoft.CodeAnalysis.ReportDiagnostic,Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Applies a default severity to a <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.
            </summary>
            <param name="reportDiagnostic">The <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> value.</param>
            <param name="defaultSeverity">The default severity.</param>
            <returns>
            <para>If <paramref name="reportDiagnostic"/> is <see cref="F:Microsoft.CodeAnalysis.ReportDiagnostic.Default"/>, returns
            <paramref name="defaultSeverity"/>.</para>
            <para>-or-</para>
            <para>Otherwise, returns <paramref name="reportDiagnostic"/> if it has a non-default value.</para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Extensions.ToReportDiagnostic(Microsoft.CodeAnalysis.DiagnosticSeverity)">
            <summary>
            Returns the equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for a <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </summary>
            <param name="diagnosticSeverity">The <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.</param>
            <returns>
            The equivalent <see cref="T:Microsoft.CodeAnalysis.ReportDiagnostic"/> for the <see cref="T:Microsoft.CodeAnalysis.DiagnosticSeverity"/> value.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            If <paramref name="diagnosticSeverity"/> is not one of the expected values.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.IWorkspaceVenusSpanMappingService.GetAdjustedDiagnosticSpan(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Text.TextSpan@,Microsoft.CodeAnalysis.FileLinePositionSpan@,Microsoft.CodeAnalysis.FileLinePositionSpan@)">
            <summary>
            Given the original location of the diagnostic and the mapped line info based on line directives in source,
            apply any necessary adjustments to these diagnostic spans and returns the effective source span for the diagnostic.
            For example, for Venus, we might change the mapped location to be the location in the primary buffer.
            Additionally, if the secondary buffer location is outside visible user code, then the original location is also adjusted to be within visible user code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.WellKnownDiagnosticPropertyNames.Origin">
            <summary>
            Predefined name of diagnostic property which shows in what compilation stage the diagnostic is created. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.PascalCase">
            <summary>
            Each word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.CamelCase">
            <summary>
            Every word except the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.FirstUpper">
            <summary>
            Only the first word is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllUpper">
            <summary>
            Every character is capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization.AllLower">
            <summary>
            No characters are capitalized
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser._cache">
            <remarks>
            The dictionary we get from the VS editorconfig API uses the same dictionary object if there are no changes, so we can cache based on dictionary
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser.NamingRuleSubsetComparer.FirstIsSubset(Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@,Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule@)">
            <summary>
            Determines if <paramref name="x"/> matches a subset of the symbols matched by <paramref name="y"/>. The
            implementation determines which properties of <see cref="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule"/> are considered for this
            evaluation. The subset relation does not necessarily indicate a proper subset.
            </summary>
            <param name="x">The first naming rule.</param>
            <param name="y">The second naming rule.</param>
            <returns><see langword="true"/> if <paramref name="x"/> matches a subset of the symbols matched by
            <paramref name="y"/> on some implementation-defined properties; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules.IsInterfaceImplementation(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            This does not handle the case where a method in a base type implicitly implements an
            interface method on behalf of one of its derived types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences">
            <summary>
            Contains all information related to Naming Style Preferences.
            1. Symbol Specifications
            2. Name Style
            3. Naming Rule (points to Symbol Specification IDs)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState">
            <summary>
            An implementation of <see cref="T:Microsoft.CodeAnalysis.AdditionalText"/> for the compiler that wraps a <see cref="T:Microsoft.CodeAnalysis.TextDocumentState"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.#ctor(Microsoft.CodeAnalysis.TextDocumentState)">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a <see cref="T:Microsoft.CodeAnalysis.TextDocumentState"/>. <paramref name="documentState"/> should be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.Path">
            <summary>
            Resolved path of the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState.GetText(System.Threading.CancellationToken)">
            <summary>
            Retrieves a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> with the contents of this file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult">
            <summary>
            This holds onto diagnostics for a specific version of project snapshot
            in a way each kind of diagnostics can be queried fast.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultBuilder">
            <summary>
            We have this builder to avoid creating collections unnecessarily.
            Expectation is that, most of time, most of analyzers doesn't have any diagnostics. so no need to actually create any objects.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap">
            <summary>
            Basically typed tuple.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticDataSerializer">
            <summary>
            DiagnosticData serializer
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DiagnosticProvider">
            <summary>
            Provide a way for users to turn on and off analyzing workspace for compiler diagnostics
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticProvider.Options.Syntax">
            <summary>
            Include syntax errors
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticProvider.Options.Semantic">
            <summary>
            Include semantic errors
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.DiagnosticProvider.Options.ScriptSemantic">
            <summary>
            Include script semantic errors
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.Edit`1">
            <summary>
            Represents an edit operation on a tree or a sequence of nodes.
            </summary>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.OldNode">
            <summary>
            Insert: 
            default(TNode).
            
            Delete: 
            Deleted node.
            
            Move, Update: 
            Node in the old tree/sequence.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.Edit`1.NewNode">
            <summary>
            Insert: 
            Inserted node.
            
            Delete: 
            default(TNode)
            
            Move, Update:
            Node in the new tree/sequence.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.None">
            <summary>
            No change.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Update">
            <summary>
            Node value was updated.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Insert">
            <summary>
            Node was inserted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Delete">
            <summary>
            Node was deleted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Move">
            <summary>
            Node changed parent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.EditKind.Reorder">
            <summary>
            Node changed position within its parent. The parent nodes of the old node and the new node are matching.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.EditScript`1">
            <summary>
            Represents a sequence of tree edits.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonImmutableArraySubsequence`1">
            <summary>
            Calculates Longest Common Subsequence for immutable arrays.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1">
            <summary>
            Calculates Longest Common Subsequence.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VBuffer">
            <summary>
            Underlying storage for <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VArray"/>s allocated on <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VStack"/>.
            </summary>
            <remarks>
            The LCS algorithm allocates <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VArray"/>s of sizes (3, 2*1 + 1, ..., 2*D + 1), always in this order, 
            where D is at most the sum of lengths of the compared sequences.
            The arrays get pushed on a stack as they are built up, then all consumed in the reverse order (stack pop).
            
            Since the exact length of each array in the above sequence is known we avoid allocating each individual array.
            Instead we allocate a large buffer serving as a a backing storage of a contiguous sequence of arrays 
            corresponding to stack depths <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VBuffer.MinDepth"/> to <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VBuffer.MaxDepth"/>.
            If more storage is needed we chain next large buffer to the previous one in a linked list.
            
            We pool a few of these linked buffers on <see cref="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VStack"/> to conserve allocations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VBuffer.FirstBufferMaxDepth">
            <summary>
            The max stack depth backed by the fist buffer.
            Size of the buffer for 100 is ~10K. 
            For 150 it'd be 91KB, which would be allocated on LOH.
            The buffers grow by factor of <see cref="F:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.VBuffer.GrowFactor"/>, so the next buffer will be allocated on LOH.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeDistance(`0,System.Int32,`0,System.Int32)">
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more similar the sequences are.
            </summary>
            <summary>
            Returns a distance [0..1] of the specified sequences.
            The smaller distance the more similar the sequences are.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ComputeEditPaths(`0,System.Int32,`0,System.Int32)">
             <summary>
             Calculates a list of "V arrays" using Eugene W. Myers O(ND) Difference Algorithm
             </summary>
             <remarks>
             
             The algorithm was inspired by Myers' Diff Algorithm described in an article by Nicolas Butler:
             https://www.codeproject.com/articles/42279/investigating-myers-diff-algorithm-part-of
             The author has approved the use of his code from the article under the Apache 2.0 license.
             
             The algorithm works on an imaginary edit graph for A and B which has a vertex at each point in the grid(i, j), i in [0, lengthA] and j in [0, lengthB].
             The vertices of the edit graph are connected by horizontal, vertical, and diagonal directed edges to form a directed acyclic graph.
             Horizontal edges connect each vertex to its right neighbor. 
             Vertical edges connect each vertex to the neighbor below it.
             Diagonal edges connect vertex (i,j) to vertex (i-1,j-1) if <see cref="M:Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1.ItemsEqual(`0,System.Int32,`0,System.Int32)"/>(sequenceA[i-1],sequenceB[j-1]) is true.
             
             Move right along horizontal edge (i-1,j)-(i,j) represents a delete of sequenceA[i-1].
             Move down along vertical edge (i,j-1)-(i,j) represents an insert of sequenceB[j-1].
             Move along diagonal edge (i-1,j-1)-(i,j) represents an match of sequenceA[i-1] to sequenceB[j-1].
             The number of diagonal edges on the path from (0,0) to (lengthA, lengthB) is the length of the longest common sub.
            
             The function does not actually allocate this graph. Instead it uses Eugene W. Myers' O(ND) Difference Algoritm to calculate a list of "V arrays" and returns it in a Stack. 
             A "V array" is a list of end points of so called "snakes". 
             A "snake" is a path with a single horizontal (delete) or vertical (insert) move followed by 0 or more diagonals (matching pairs).
             
             Unlike the algorithm in the article this implementation stores 'y' indexes and prefers 'right' moves instead of 'down' moves in ambiguous situations
             to preserve the behavior of the original diff algorithm (deletes first, inserts after).
             
             The number of items in the list is the length of the shortest edit script = the number of inserts/edits between the two sequences = D. 
             The list can be used to determine the matching pairs in the sequences (GetMatchingPairs method) or the full editing script (GetEdits method).
             
             The algorithm uses O(ND) time and memory where D is the number of delete/inserts and N is the sum of lengths of the two sequences.
             
             VArrays store just the y index because x can be calculated: x = y + k.
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring">
            <summary>
            Calculates longest common substring using Wagner algorithm.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetTreeEdits">
            <summary>
            Returns an edit script (a sequence of edits) that transform <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.OldRoot"/> subtree 
            to <see cref="P:Microsoft.CodeAnalysis.Differencing.Match`1.NewRoot"/> subtree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.Match`1.GetSequenceEdits(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Returns an edit script (a sequence of edits) that transform a sequence of nodes <paramref name="oldNodes"/>
            to a sequence of nodes <paramref name="newNodes"/>. 
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="oldNodes"/> or <paramref name="newNodes"/> is a null reference.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.SequenceEdit">
            <summary>
            Represents an edit operation on a sequence of values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.Kind">
            <summary>
            The kind of edit: <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Delete"/>, <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Insert"/>, or <see cref="F:Microsoft.CodeAnalysis.Differencing.EditKind.Update"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.OldIndex">
            <summary>
            Index in the old sequence, or -1 if the edit is insert.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.SequenceEdit.NewIndex">
            <summary>
            Index in the new sequence, or -1 if the edit is delete.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Differencing.TreeComparer`1">
            <summary>
            Implements a tree differencing algorithm.
            </summary>
            <remarks>
            Subclasses define relationships among tree nodes, and parameters to the differencing algorithm.
            </remarks>
            <typeparam name="TNode">Tree node.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeEditScript(`0,`0)">
            <summary>
            Returns an edit script that transforms <paramref name="oldRoot"/> to <paramref name="newRoot"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ComputeMatch(`0,`0,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`0}})">
            <summary>
            Returns a match map of <paramref name="oldRoot"/> descendants to <paramref name="newRoot"/> descendants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDistance(`0,`0)">
            <summary>
            Calculates the distance [0..1] of two nodes.
            </summary>
            <remarks>
            The more similar the nodes the smaller the distance.
            
            Used to determine whether two nodes of the same label match.
            Even if 0 is returned the nodes might be slightly different.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.ValuesEqual(`0,`0)">
            <summary>
            Returns true if the specified nodes have equal values.
            </summary>
            <remarks>
            Called with matching nodes (<paramref name="oldNode"/>, <paramref name="newNode"/>).
            Return true if the values of the nodes are the same, or their difference is not important.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.LabelCount">
            <summary>
            The number of distinct labels used in the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetLabel(`0)">
            <summary>
            Returns an integer label corresponding to the given node.
            </summary>
            <remarks>Returned value must be within [0, LabelCount).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TiedToAncestor(System.Int32)">
            <summary>
            Returns N > 0 if the node with specified label can't change its N-th ancestor node, zero otherwise.
            </summary>
            <remarks>
            1st ancestor is the node's parent node.
            2nd ancestor is the node's grandparent node.
            etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetChildren(`0)">
            <summary>
            May return null if the <paramref name="node"/> is a leaf.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetDescendants(`0)">
            <summary>
            Enumerates all descendant nodes of the given node in depth-first prefix order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TryGetParent(`0,`0@)">
            <summary>
            Returns a parent for the specified node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.TreesEqual(`0,`0)">
            <summary>
            Return true if specified nodes belong to the same tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Differencing.TreeComparer`1.GetSpan(`0)">
            <summary>
            Returns the position of the node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.DocumentEditor">
            <summary>
            An editor for making changes to a document's syntax tree. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.DocumentEditor.CreateAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.DocumentEditor.OriginalDocument">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Document"/> specified when the editor was first created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.DocumentEditor.SemanticModel">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> of the original document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.DocumentEditor.GetChangedDocument">
            <summary>
            Returns the changed <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the span specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the spans specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the span specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSyntaxesAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the spans specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the span specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the sub-trees annotated with the <see cref="T:Microsoft.CodeAnalysis.SyntaxAnnotation"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdder.AddImportsFromSymbolAnnotationAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Boolean,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Adds namespace imports / using directives for namespace references found in the document within the spans specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdderService.MakeSafeToAddNamespaces(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.INamespaceOrTypeSymbol},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Fully qualifies parts of the document that may change meaning if namespaces are added, 
            and marks them with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation"/> so they can be reduced later.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdderService.GetImportDirectivesFromSyntaxesAsync(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.AddImports.IAddImportsService,Microsoft.CodeAnalysis.Editing.SyntaxGenerator,System.Threading.CancellationToken)">
            <summary>
            
            </summary>
            <param name="root">ref as we add simplifier annotations to nodes with explicit namespaces</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.ImportAdderService.IsInsideNamespace(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.INamespaceSymbol,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Checks if the namespace declaration <paramref name="node"/> is contained inside,
            or any of its ancestor namespaces are the same as <paramref name="symbol"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ImplicitConversion">
            <summary>
            The name assigned to an implicit (widening) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ExplicitConversion">
            <summary>
            The name assigned to an explicit (narrowing) conversion.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Addition">
            <summary>
            The name assigned to the Addition operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.BitwiseAnd">
            <summary>
            The name assigned to the BitwiseAnd operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.BitwiseOr">
            <summary>
            The name assigned to the BitwiseOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Decrement">
            <summary>
            The name assigned to the Decrement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Division">
            <summary>
            The name assigned to the Division operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Equality">
            <summary>
            The name assigned to the Equality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.ExclusiveOr">
            <summary>
            The name assigned to the ExclusiveOr operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.False">
            <summary>
            The name assigned to the False operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.GreaterThan">
            <summary>
            The name assigned to the GreaterThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.GreaterThanOrEqual">
            <summary>
            The name assigned to the GreaterThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Increment">
            <summary>
            The name assigned to the Increment operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Inequality">
            <summary>
            The name assigned to the Inequality operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LeftShift">
            <summary>
            The name assigned to the LeftShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LessThan">
            <summary>
            The name assigned to the LessThan operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LessThanOrEqual">
            <summary>
            The name assigned to the LessThanOrEqual operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.LogicalNot">
            <summary>
            The name assigned to the LogicalNot operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Modulus">
            <summary>
            The name assigned to the Modulus operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Multiply">
            <summary>
            The name assigned to the Multiply operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.OnesComplement">
            <summary>
            The name assigned to the OnesComplement operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.RightShift">
            <summary>
            The name assigned to the RightShift operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.Subtraction">
            <summary>
            The name assigned to the Subtraction operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.True">
            <summary>
            The name assigned to the True operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.UnaryNegation">
            <summary>
            The name assigned to the UnaryNegation operator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.OperatorKind.UnaryPlus">
            <summary>
            The name assigned to the UnaryPlus operator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SolutionEditor">
            <summary>
            An editor for making changes to multiple documents in a solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SolutionEditor.OriginalSolution">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Solution"/> that was specified when the <see cref="T:Microsoft.CodeAnalysis.Editing.SolutionEditor"/> was constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SolutionEditor.GetDocumentEditorAsync(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> for the corresponding <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SolutionEditor.GetChangedSolution">
            <summary>
            Returns the changed <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor">
            <summary>
            An editor for making changes to symbol source declarations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.Create(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> instance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.Create(Microsoft.CodeAnalysis.Document)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SymbolEditor.OriginalSolution">
            <summary>
            The original solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SymbolEditor.ChangedSolution">
            <summary>
            The solution with the edits applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetChangedDocuments">
            <summary>
            The documents changed since the <see cref="T:Microsoft.CodeAnalysis.Editing.SymbolEditor"/> was constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetCurrentSymbolAsync(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the current symbol for a source symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetCurrentDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the current declarations for the specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the declaration syntax nodes for a given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.TryGetBestDeclarationForSingleEdit(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the best declaration node for adding members.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction">
            <summary>
            An action that make changes to a declaration node within a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
            <param name="editor">The <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> to apply edits to.</param>
            <param name="declaration">The declaration to edit.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction">
            <summary>
            An action that make changes to a declaration node within a <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/>.
            </summary>
            <param name="editor">The <see cref="T:Microsoft.CodeAnalysis.Editing.DocumentEditor"/> to apply edits to.</param>
            <param name="declaration">The declaration to edit.</param>
            <param name="cancellationToken">A cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="location">A location within one of the symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the definition of one of the symbol's declarations.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="location">A location within one of the symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the symbol's declaration where the member is also declared.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="member">A symbol whose declaration is contained within one of the primary symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditOneDeclarationAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing the symbol's declaration where the member is also declared.
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to edit.</param>
            <param name="member">A symbol whose declaration is contained within one of the primary symbol's declarations.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditAllDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.AsyncDeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing all the symbol's declarations. 
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to be edited.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditor.EditAllDeclarationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Editing.SymbolEditor.DeclarationEditAction,System.Threading.CancellationToken)">
            <summary>
            Enables editing all the symbol's declarations. 
            Partial types and methods may have more than one declaration.
            </summary>
            <param name="symbol">The symbol to be edited.</param>
            <param name="editAction">The action that makes edits to the declaration.</param>
            <param name="cancellationToken">An optional <see cref="T:System.Threading.CancellationToken"/>.</param>
            <returns>The new symbol including the changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.GetBaseOrInterfaceDeclarationReferenceAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the reference to the declaration of the base or interface type as part of the symbol's declaration. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Func{Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Changes the base type of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions.SetBaseTypeAsync(Microsoft.CodeAnalysis.Editing.SymbolEditor,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Changes the base type of the symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor">
            <summary>
            An editor for making changes to a syntax tree. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.#ctor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SyntaxEditor.OriginalRoot">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> that was specified when the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxEditor"/> was constructed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Editing.SyntaxEditor.Generator">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> to use to create and change <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>'s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.GetChangedRoot">
            <summary>
            Returns the changed root node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.TrackNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Makes sure the node is tracked, even if it is not changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Remove the node from the tree.
            </summary>
            <param name="node">The node to remove that currently exists as part of the tree.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Remove the node from the tree.
            </summary>
            <param name="node">The node to remove that currently exists as part of the tree.</param>
            <param name="options">Options that affect how node removal works.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Replace the specified node with a node produced by the function.
            </summary>
            <param name="node">The node to replace that already exists in the tree.</param>
            <param name="computeReplacement">A function that computes a replacement node. 
            The node passed into the compute function includes changes from prior edits. It will not appear as a descendant of the original root.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Replace the specified node with a different node.
            </summary>
            <param name="node">The node to replace that already exists in the tree.</param>
            <param name="newNode">The new node that will be placed into the tree in the existing node's location.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertBefore(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Insert the new nodes before the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed before. This must be a node this is contained within a syntax list.</param>
            <param name="newNodes">The nodes to place before the existing node. These nodes must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertBefore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Insert the new node before the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed before. This must be a node this is contained within a syntax list.</param>
            <param name="newNode">The node to place before the existing node. This node must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertAfter(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Insert the new nodes after the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed after. This must be a node this is contained within a syntax list.</param>
            <param name="newNodes">The nodes to place after the existing node. These nodes must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxEditor.InsertAfter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Insert the new node after the specified node already existing in the tree.
            </summary>
            <param name="node">The node already existing in the tree that the new nodes will be placed after. This must be a node this is contained within a syntax list.</param>
            <param name="newNode">The node to place after the existing node. This node must be of a compatible type to be placed in the same list containing the existing node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator">
            <summary>
            A language agnostic factory for creating syntax nodes.
            
            This API can be used to create language specific syntax nodes that are semantically 
            similar between languages.
            
            The trees generated by this API will try to respect user preferences when
            possible.  For example, generating <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)"/> 
            will be done in a way such that "this." or "Me." will be simplified according to user
            preference if any <see cref="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)" /> 
            overload is called.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Workspace,System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the specified language.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the language corresponding to the document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGenerator(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.SyntaxGenerator"/> for the language corresponding to the project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the node if it is a declaration, the immediate enclosing declaration if one exists, or null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationKind)">
            <summary>
            Returns the enclosing declaration of the specified kind or null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol)">
            <summary>
            Creates a field declaration matching an existing field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FieldDeclaration(Microsoft.CodeAnalysis.IFieldSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a field declaration matching an existing field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MethodDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MethodDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration matching an existing method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.OperatorDeclaration(Microsoft.CodeAnalysis.Editing.OperatorKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.OperatorDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a method declaration matching an existing method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ParameterDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Creates a parameter declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ParameterDeclaration(Microsoft.CodeAnalysis.IParameterSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a parameter declaration matching an existing parameter symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.PropertyDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.PropertyDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a property declaration using an existing property symbol as a signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IndexerDeclaration(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an indexer declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IndexerDeclaration(Microsoft.CodeAnalysis.IPropertySymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an indexer declaration matching an existing indexer symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddEventHandler(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that adds the given handler to the given event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveEventHandler(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that removes the given handler from the given event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EventDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Creates an event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EventDeclaration(Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Creates an event declaration from an existing event symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CustomEventDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a custom event declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CustomEventDeclaration(Microsoft.CodeAnalysis.IEventSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a custom event declaration from an existing event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConstructorDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a constructor declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConstructorDeclaration(Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Create a constructor declaration using 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPublicInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts method, property and indexer declarations into public interface implementations.
            This is equivalent to an implicit C# interface implementation (you can access it via the interface or directly via the named member.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPublicInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Converts method, property and indexer declarations into public interface implementations.
            This is equivalent to an implicit C# interface implementation (you can access it via the interface or directly via the named member.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPrivateInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Converts method, property and indexer declarations into private interface implementations.
            This is equivalent to a C# explicit interface implementation (you can declare it for access via the interface, but cannot call it directly).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AsPrivateInterfaceImplementation(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Converts method, property and indexer declarations into private interface implementations.
            This is equivalent to a C# explicit interface implementation (you can declare it for access via the interface, but cannot call it directly).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ClassDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a class declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.StructDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a struct declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InterfaceDeclaration(System.String,System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.Accessibility,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a interface declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EnumDeclaration(System.String,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an enum declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.EnumMember(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an enum member
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DelegateDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{System.String},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Creates a delegate declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Declaration(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Creates a declaration matching an existing symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Converts a declaration (method, class, etc) into a declaration with type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeParameters(Microsoft.CodeAnalysis.SyntaxNode,System.String[])">
            <summary>
            Converts a declaration (method, class, etc) into a declaration with type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeConstraint(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Adds a type constraint to a type parameter of a declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a namespace declaration.
            </summary>
            <param name="name">The name of the namespace.</param>
            <param name="declarations">Zero or more namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CompilationUnit(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a compilation unit declaration
            </summary>
            <param name="declarations">Zero or more namespace import, namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CompilationUnit(Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a compilation unit declaration
            </summary>
            <param name="declarations">Zero or more namespace import, namespace or type declarations.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceImportDeclaration(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a namespace import declaration.
            </summary>
            <param name="name">The name of the namespace being imported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NamespaceImportDeclaration(System.String)">
            <summary>
            Creates a namespace import declaration.
            </summary>
            <param name="name">The name of the namespace being imported.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AliasImportDeclaration(System.String,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol)">
            <summary>
            Creates an alias import declaration.
            </summary>
            <param name="aliasIdentifierName">The name of the alias.</param>
            <param name="symbol">The namespace or type to be aliased.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AliasImportDeclaration(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an alias import declaration.
            </summary>
            <param name="aliasIdentifierName">The name of the alias.</param>
            <param name="name">The namespace or type to be aliased.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Attribute(Microsoft.CodeAnalysis.AttributeData)">
            <summary>
            Creates an attribute matching existing attribute data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AttributeArgument(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AttributeArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an attribute argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveAllAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes all attributes from the declaration, including return attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveAllComments(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes comments from leading and trailing trivia, as well
            as potentially removing comments from opening and closing tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the attributes of a declaration, not including the return attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a declaration with the specified attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributes(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a declaration with the specified attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the return attributes from the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a method declaration with return attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a method declaration with return attributes inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of a method declaration with return attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddReturnAttributes(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of a method declaration node with return attributes added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the attribute arguments for the attribute declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the attribute with the arguments inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAttributeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the attribute with the arguments added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the namespace imports that are part of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the namespace imports inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the namespace imports inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the namespace imports added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddNamespaceImports(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the namespace imports added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetMembers(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the current members of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the members inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the members inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddMembers(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the members added to the end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddMembers(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a new instance of the declaration with the members added to the end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessibility(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the accessibility of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithAccessibility(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Accessibility)">
            <summary>
            Changes the accessibility of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetModifiers(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationModifiers"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithModifiers(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationModifiers)">
            <summary>
            Changes the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationModifiers"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetDeclarationKind(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Editing.DeclarationKind"/> for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the name of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithName(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Changes the name of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetType(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the type of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Changes the type of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetParameters(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of parameters for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the parameters at the specified index into the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddParameters(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds the parameters to the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetSwitchSections(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of switch sections for the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertSwitchSections(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the switch sections at the specified index into the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddSwitchSections(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Adds the switch sections to the statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the expression associated with the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Changes the expression associated with the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessors(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the accessors for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetAccessor(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Editing.DeclarationKind)">
            <summary>
            Gets the accessor of the specified kind for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertAccessors(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the accessors inserted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddAccessors(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a new instance of the declaration with the accessors added.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetGetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the get-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithGetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the get-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetSetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the statements for the body of the set-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithSetAccessorStatements(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Changes the statements for the body of the set-accessor of the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GetBaseAndInterfaceTypes(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of the base and interface types for the declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddBaseType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Adds a base type to the declaration
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddInterfaceType(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Adds an interface type to the declaration
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReplaceNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Replaces the node in the root's tree with the new node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNodesBefore(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the new node before the specified declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InsertNodesAfter(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Inserts the new node before the specified declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Removes the node from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNode(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxRemoveOptions)">
            <summary>
            Removes the node from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RemoveNodes(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Removes all the declarations from the sub tree starting at the root.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ClearTrivia``1(``0)">
            <summary>
            Creates a new instance of the node with the leading and trailing trivia removed and replaced with elastic markers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ExpressionStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates statement that allows an expression to execute in a statement context.
            This is typically an invocation or assignment expression.
            </summary>
            <param name="expression">The expression that is to be executed. This is usually a method invocation expression.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to return a value from a method body.
            </summary>
            <param name="expression">An optional expression that can be returned.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.YieldReturnStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to yield a value from an iterator method.
            </summary>
            <param name="expression">An expression that can be yielded.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowStatement(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that can be used to throw an exception.
            </summary>
            <param name="expression">An optional expression that can be thrown.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that can be used to throw an exception.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SupportsThrowExpression">
            <summary>
            True if <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThrowExpression(Microsoft.CodeAnalysis.SyntaxNode)"/> can be used
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.RequiresLocalDeclarationType">
            <summary>
            <see langword="true"/> if the language requires a <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol)"/>
            (including <see langword="var"/>) to be stated when making a 
            <see cref="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.ITypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)"/>.
            <see langword="false"/> if the language allows the type node to be entirely elided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.ITypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a statement that declares a single local variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IfStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an if-statement
            </summary>
            <param name="condition">A condition expression.</param>
            <param name="trueStatements">The statements that are executed if the condition is true.</param>
            <param name="falseStatements">The statements that are executed if the condition is false.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IfStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an if statement
            </summary>
            <param name="condition">A condition expression.</param>
            <param name="trueStatements">The statements that are executed if the condition is true.</param>
            <param name="falseStatement">A single statement that is executed if the condition is false.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a switch statement that branches to individual sections based on the value of the specified expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a switch statement that branches to individual sections based on the value of the specified expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchSection(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a section for a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SwitchSection(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a single-case section a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DefaultSwitchSection(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a default section for a switch statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ExitSwitchStatement">
            <summary>
            Create a statement that exits a switch statement and continues after it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(Microsoft.CodeAnalysis.SyntaxNode,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.UsingStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a using-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LockStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a statement that represents a lock-block pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCatchStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a try-catch or try-catch-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCatchStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a try-catch or try-catch-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryFinallyStatement(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a try-finally statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CatchClause(Microsoft.CodeAnalysis.SyntaxNode,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a catch-clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CatchClause(Microsoft.CodeAnalysis.ITypeSymbol,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a catch-clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WhileStatement(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a while-loop statement
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ScopeBlock(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a block of statements. Not supported in VB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DefaultExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            An expression that represents the default value of a type.
            This is typically a null value for reference types or a zero-filled value for value types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ThisExpression">
            <summary>
            Creates an expression that denotes the containing method's this-parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BaseExpression">
            <summary>
            Creates an expression that denotes the containing method's base-parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LiteralExpression(System.Object)">
            <summary>
            Creates a literal expression. This is typically numeric primitives, strings or chars.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypedConstantExpression(Microsoft.CodeAnalysis.TypedConstant)">
            <summary>
            Creates an expression for a typed constant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.FalseLiteralExpression">
            <summary>
            Creates an expression that denotes the boolean false literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TrueLiteralExpression">
            <summary>
            Creates an expression that denotes the boolean true literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NullLiteralExpression">
            <summary>
            Creates an expression that denotes the null literal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IdentifierName(System.String)">
            <summary>
            Creates an expression that denotes a simple identifier name.
            </summary>
            <param name="identifier"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ITypeSymbol})">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GenericName(System.String,Microsoft.CodeAnalysis.ITypeSymbol[])">
            <summary>
            Creates an expression that denotes a generic identifier name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeArguments(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Converts an expression that ends in a name into an expression that ends in a generic name.
            If the expression already ends in a generic name, the new type arguments are used instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.WithTypeArguments(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Converts an expression that ends in a name into an expression that ends in a generic name.
            If the expression already ends in a generic name, the new type arguments are used instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.QualifiedName(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a name expression that denotes a qualified name. 
            The left operand can be any name expression.
            The right operand can be either and identifier or generic name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GlobalAliasedName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns a new name node qualified with the 'global' alias ('Global' in VB).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DottedName(System.String)">
            <summary>
            Creates a name expression from a dotted name string.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NameExpression(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol)">
            <summary>
            Creates a name that denotes a type or namespace.
            </summary>
            <param name="namespaceOrTypeSymbol">The symbol to create a name for.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Creates an expression that denotes a type. If addImport is false,
            adds a <see cref="T:Microsoft.CodeAnalysis.Simplification.DoNotAddImportsAnnotation"/> which will prevent any
            imports or usings from being added for the type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeExpression(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Creates an expression that denotes a special type name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayTypeExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an array type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NullableTypeExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a nullable type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleTypeExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ITypeSymbol},System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an expression that denotes a tuple type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleElementExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Creates an expression that denotes a tuple element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleElementExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.String)">
            <summary>
            Creates an expression that denotes a tuple element.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AssignmentStatement(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an assignment from the right argument to left argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a value-type equality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReferenceEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a reference-type equality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueNotEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a value-type inequality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ReferenceNotEqualsExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a reference-type inequality test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LessThanExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a less-than test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LessThanOrEqualExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a less-than-or-equal test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GreaterThanExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a greater-than test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.GreaterThanOrEqualExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a greater-than-or-equal test operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NegateExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a unary negation operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an addition operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.SubtractExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an subtraction operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MultiplyExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a multiplication operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.DivideExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a division operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ModuloExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a modulo operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseAndExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-and operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseOrExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-or operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.BitwiseNotExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a bitwise-not operation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalAndExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical-and operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalOrExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical-or operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LogicalNotExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a logical not operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConditionalExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a conditional evaluation operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CoalesceExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a coalesce operation. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a member access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.MemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.String)">
            <summary>
            Creates a member access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an array creation expression for a single dimensional array of specified size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an array creation expression for a single dimensional array with specified initial element values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.ITypeSymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ObjectCreationExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an object creation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates a invocation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.InvocationExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates a invocation expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(System.String,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.Argument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a node that is an argument to an invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that access an element of an array or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ElementAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode[])">
            <summary>
            Creates an expression that access an element of an array or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TypeOfExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that evaluates to the type at runtime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IsTypeExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an is-type-check operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.IsTypeExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes an is-type-check operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes an try-cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TryCastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates an expression that denotes an try-cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CastExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.CastExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type cast operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConvertExpression(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type conversion operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ConvertExpression(Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that denotes a type conversion operation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a void returning lambda expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a single parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a single parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a single parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a single parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a zero parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an expression that declares a zero parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.ValueReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a zero parameter value returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.VoidReturningLambdaExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an expression that declares a zero parameter void returning lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LambdaParameter(System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a lambda parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.LambdaParameter(System.String,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Creates a lambda parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AwaitExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an await expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.AddParentheses(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Wraps with parens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.NameOfExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates an nameof expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Editing.SyntaxGenerator.TupleExpression(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Creates an tuple expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.ReferenceType">
            <summary>
            Has the reference type constraint (i.e. 'class' constraint in C#)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.ValueType">
            <summary>
            Has the value type constraint (i.e. 'struct' constraint in C#)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind.Constructor">
            <summary>
            Has the constructor constraint (i.e. 'new' constraint in C#)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic">
            <summary>
            Represents an error in a embedded language snippet.  The error contains the message to show 
            a user as well as the span of the error.  This span is in actual user character coordinates.
            For example, if the user has the string "...\\p{0}..." then the span of the error would be 
            for the range of characters for '\\p{0}' (even though the regex engine would only see the \\ 
            translated as a virtual char to the single \ character.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2">
            <summary>
            Root of the embedded language syntax hierarchy.  EmbeddedSyntaxNodes are very similar to 
            Roslyn Red-Nodes in concept, though there are differences for ease of implementation.
            
            Similarities:
            1. Fully representative of the original source.  All source VirtualChars are contained
               in the Regex nodes.
            2. Specific types for Nodes, Tokens and Trivia.
            3. Uniform ways of deconstructing Nodes (i.e. ChildCount + ChildAt).
            
            Differences:
            Note: these differences are not required, and can be changed if felt to be valuable.
            1. No parent pointers.  These have not been needed yet.
            2. No Update methods.  These have not been needed yet.
            3. No direct ways to get Positions/Spans of node/token/trivia.  Instead, that information can
               be acquired from the VirtualChars contained within those constructs.  This does mean that
               an empty node (for example, an empty RegexSequenceNode) effect has no way to simply ascertain
               its location.  So far that hasn't been a problem.
            4. No null nodes.  Haven't been needed so far, and it keeps things extremely simple.  For 
               example where Roslyn might have chosen an optional null child, the Regex hierarchy just
               has multiple nodes.  For example there are distinct nodes to represent the very similar
               {a}   {a,}    {a,b}    constructs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1.Value">
            <summary>
            Returns the value of the token. For example, if the token represents an integer capture,
            then this property would return the actual integer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1">
            <summary>
            Trivia on an <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1.Diagnostics">
            <summary>
            A place for diagnostics to be stored during parsing.  Not intended to be accessed 
            directly.  These will be collected and aggregated into <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTree`3.Diagnostics"/>
            </summary> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.AbstractEmbeddedLanguagesProvider">
            <summary>
            Abstract implementation of the C# and VB embedded language providers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.FallbackEmbeddedLanguage">
            <summary>
            A 'fallback' embedded language that can classify normal escape sequences in 
            C# or VB strings if no other embedded languages produce results.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguage">
            <summary>
            Services related to a specific embedded language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguage.Classifier">
            <summary>
            A optional classifier that can produce <see cref="T:Microsoft.CodeAnalysis.Classification.ClassifiedSpan"/>s for an embedded language string.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguagesProvider">
            <summary>
            Service that returns all the embedded languages supported.  Each embedded language can expose
            individual language services through the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguage"/> interface.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexPatternDetector">
            <summary>
            Helper class to detect regex pattern tokens in a document efficiently.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexPatternDetector.s_languageCommentDetector">
            <summary>
            Helps match patterns of the form: language=regex,option1,option2,option3
            
            All matching is case insensitive, with spaces allowed between the punctuation.
            'regex' or 'regexp' are both allowed.  Option values will be or'ed together
            to produce final options value.  If an unknown option is encountered, processing
            will stop with whatever value has accumulated so far.
            
            Option names are the values from the <see cref="T:System.Text.RegularExpressions.RegexOptions"/> enum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexPatternDetector.GetMethodNamesOfInterest(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Finds public, static methods in <see cref="T:System.Text.RegularExpressions.Regex"/> that have a parameter called
            'pattern'.  These are helpers (like <see cref="M:System.Text.RegularExpressions.Regex.Replace(System.String,System.String,System.String)"/> 
            where at least one (but not necessarily more) of the parameters should be treated as a
            pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.LanguageServices.RegexSyntaxClassifier">
            <summary>
            Classifier impl for embedded regex strings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass">
            <summary>
            Minimal copy of https://github.com/dotnet/corefx/blob/master/src/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexCharClass.cs
            Used to accurately determine if something is a WordChar according to the .NET regex engine.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass.CharInClassInternal(System.Char,System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Determines a character's membership in a character class (via the
            string representation of the class).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharClass.CharInCategoryGroup(System.Char,System.Globalization.UnicodeCategory,System.String,System.Int32@)">
            <summary>
            This is used for categories which are composed of other categories - L, N, Z, W...
            These groups need special treatment when they are negated
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHelpers.MapEscapeChar(System.Char)">
            <summary>
            Maps an escaped character to the actual character it was escaping.  For something like
            'a' this will map to actual '\a' char (the bell character).  However, for something like
            '(' this will just map to '(' as that's all that \( does in a regex.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLexer">
             <summary>
             Produces tokens from the sequence of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> characters.  Unlike the
             native C# and VB lexer, this lexer is much more tightly controlled by the parser.  For
             example, while C# can have trivia on virtual every token, the same is not true for
             RegexTokens.  As such, instead of automatically lexing out tokens to make them available for
             the parser, the parser asks for each token as necessary passing the right information to
             indicate which types and shapes of tokens are allowed.
            
             The tight coupling means that the parser is allowed direct control of the position of the
             lexer.
            
             Note: most of the time, tokens returned are just a single character long, including for long
             sequences of text characters (like ```"goo"```).  This is just three <see
             cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode"/>s in a row (each containing a <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind.TextToken"/> a
             single character long).
            
             There are multi-character tokens though.  For example ```10``` in ```a{10,}``` or ```name```
             in ```\k'name'```
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSequenceNode">
            <summary>
            Represents a possibly-empty sequence of regex expressions.  For example, the regex ""
            will produce an empty RegexSequence nodes, and "a|" will produce an alternation with an
            empty sequence on the right side.  Having a node represent the empty sequence is actually
            appropriate as these are legal regexes and the empty sequence represents 'a pattern
            that will match any position'.  Not having a node for this would actually end up 
            complicating things in terms of dealing with nulls in the tree.
            
            This does not deviate from Roslyn principles.  While nodes for empty text are rare, they
            are allowed (for example, OmittedTypeArgument in C#).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTextNode">
            <summary>
            Represents a chunk of text (usually just a single char) from the original pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBaseCharacterClassNode">
            <summary>
            Base type for [...] and [^...] character classes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassNode">
            <summary>
            [...] node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegatedCharacterClassNode">
            <summary>
            [^...] node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassRangeNode">
            <summary>
            ```a-z``` node in a character class.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassSubtractionNode">
            <summary>
            ```-[f-m]``` in a pattern like ```[a-z-[f-m]]```.  A subtraction must come last in a 
            character class, and removes some range of chars from the character class built up
            so far.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPosixPropertyNode">
            <summary>
            Represents a ```[:...:]``` node in a character class.  Note: the .NET regex parser
            simply treats this as the character ```[``` and ignores the rest of the ```:...:]```.
            They latter part has no impact on the actual match engine that is produced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExpressionNode">
            <summary>
            Root of all expression nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPrimaryExpressionNode">
            <summary>
            Root of all the primary nodes (similar to unary nodes in C#).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexWildcardNode">
            <summary>
            A ```.``` expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuantifierNode">
            <summary>
            Root of all quantifier nodes: ```?```, ```*``` etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrMoreQuantifierNode">
            <summary>
            ```expr*```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOneOrMoreQuantifierNode">
            <summary>
            ```expr+```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexZeroOrOneQuantifierNode">
            <summary>
            ```expr?```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexLazyQuantifierNode">
            <summary>
            Quantifiers can be optionally followed by a ? to make them lazy.  i.e. ```a*?``` or ```a+?```.
            You can even have ```a??```  (zero or one 'a', lazy).  However, only one lazy modifier is allowed
            ```a*??``` or ```a???``` is not allowed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNumericQuantifierNode">
            <summary>
            Base type of all regex numeric quantifier nodes.  i.e.  
            ```a{5}```,  ```a{5,}``` and ```a{5,10}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexExactNumericQuantifierNode">
            <summary>
            ```a{5}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOpenNumericRangeQuantifierNode">
            <summary>
            ```a{5,}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexClosedNumericRangeQuantifierNode">
            <summary>
            ```a{5,10}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorNode">
            <summary>
            ```$``` or ```^```.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAlternationNode">
            <summary>
            ```expr1|expr2``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexGroupingNode">
            <summary>
            Base type of all non-trivia ```(...)``` nodes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleGroupingNode">
            <summary>
            The ```(...)``` node you get when the group does not start with ```(?```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexQuestionGroupingNode">
            <summary>
            Base type of all ```(?...)``` groupings.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOptionsGroupingNode">
            <summary>
            Base type of ```(?inmsx)``` or ```(?inmsx:...)``` nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleOptionsGroupingNode">
            <summary>
            ```(?inmsx)``` node.  Changes options in a sequence for all subsequence nodes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNestedOptionsGroupingNode">
            <summary>
            ```(?inmsx:expr)``` node.  Changes options for the parsing of 'expr'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNonCapturingGroupingNode">
            <summary>
            ```(?:expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookaheadGroupingNode">
            <summary>
            ```(?=expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookaheadGroupingNode">
            <summary>
            ```(?!expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexPositiveLookbehindGroupingNode">
            <summary>
            ```(?&lt;=expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNegativeLookbehindGroupingNode">
            <summary>
            ```(?&lt;!expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexNonBacktrackingGroupingNode">
            <summary>
            ```(?&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureGroupingNode">
            <summary>
            ```(?'name'expr)``` or ```(?&lt;name&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBalancingGroupingNode">
            <summary>
            ```(?'name1-name2'expr)``` or ```(?&lt;name1-name2&gt;expr)``` node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalCaptureGroupingNode">
            <summary>
            ```(?(capture_name)result)```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexConditionalExpressionGroupingNode">
            <summary>
            ```(?(group)result)```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexEscapeNode">
            <summary>
            Base type of all regex primitives that start with \
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTypeEscapeNode">
            <summary>
            Base type of all regex escapes that start with \ and some informative character (like \v \t \c etc.).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexSimpleEscapeNode">
            <summary>
            A basic escape that just has \ and one additional character and needs no further information.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexAnchorEscapeNode">
            <summary>
            One of \b \B \A \G \z \Z
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCharacterClassEscapeNode">
            <summary>
            One of \s \S \d \D \w \W
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexControlEscapeNode">
            <summary>
            ```\cX``` escape
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexHexEscapeNode">
            <summary>
            ```\xFF``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexUnicodeEscapeNode">
            <summary>
            ```\uFFFF``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCaptureEscapeNode">
            <summary>
            ```\'name'``` or ```\&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKCaptureEscapeNode">
            <summary>
            ```\k'name'``` or ```\k&lt;name&gt;``` escape.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexOctalEscapeNode">
            <summary>
            ```\1``` escape. In contexts where back-references are not allowed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexBackreferenceEscapeNode">
            <summary>
            ```\1```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexCategoryEscapeNode">
            <summary>
            ```\p{...}```
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser">
             <summary>
             Produces a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexTree"/> from a sequence of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/> characters.
            
             Importantly, this parser attempts to replicate diagnostics with almost the exact same text
             as the native .NET regex parser.  This is important so that users get an understandable
             experience where it appears to them that this is all one cohesive system and that the IDE
             will let them discover and fix the same issues they would encounter when previously trying
             to just compile and execute these regexes.
             </summary>
             <remarks>
             Invariants we try to maintain (and should consider a bug if we do not): l 1. If the .NET
             regex parser does not report an error for a given pattern, we should not either. it would be
             very bad if we told the user there was something wrong with there pattern when there really
             wasn't.
            
             2. If the .NET regex parser does report an error for a given pattern, we should either not
             report an error (not recommended) or report the same error at an appropriate location in the
             pattern.  Not reporting the error can be confusing as the user will think their pattern is
             ok, when it really is not.  However, it can be acceptable to do this as it's not telling
             them that something is actually wrong, and it may be too difficult to find and report the
             same error.  Note: there is only one time we do this in this parser (see the deviation
             documented in <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParsePossibleEcmascriptBackreferenceEscape(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},System.Boolean)"/>).
            
             Note1: "report the same error" means that we will attempt to report the error using the same
             text the .NET regex parser uses for its error messages.  This is so that the user is not
             confused when they use the IDE vs running the regex by getting different messages for the
             same issue.
            
             Note2: the above invariants make life difficult at times.  This happens due to the fact that
             the .NET parser is multi-pass.  Meaning it does a first scan (which may report errors), then
             does the full parse.  This means that it might report an error in a later location during
             the initial scan than it would during the parse.  We replicate that behavior to follow the
             second invariant.
            
             Note3: It would be nice if we could check these invariants at runtime, so we could control
             our behavior by the behavior of the real .NET regex engine.  For example, if the .NET regex
             engine did not report any issues, we could suppress any diagnostics we generated and we
             could log an NFW to record which pattern we deviated on so we could fix the issue for a
             future release.  However, we cannot do this as the .NET regex engine has no guarantees about
             its performance characteristics.  For example, certain regex patterns might end up causing
             that engine to consume unbounded amounts of CPU and memory.  This is because the .NET regex
             engine is not just a parser, but something that builds an actual recognizer using techniques
             that are not necessarily bounded.  As such, while we test ourselves around it during our
             tests, we cannot do the same at runtime as part of the IDE.
            
             This parser was based off the corefx RegexParser based at:
             https://github.com/dotnet/corefx/blob/f759243d724f462da0bcef54e86588f8a55352c6/src/System.Text.RegularExpressions/src/System/Text/RegularExpressions/RegexParser.cs#L1
            
             Note4: The .NET parser itself changes over time (for example to fix behavior that even it
             thinks is buggy).  When this happens, we have to make a choice as to which behavior to
             follow. In general, the overall principle is that we should follow the more lenient
             behavior.  If we end up taking the more strict interpretation we risk giving people an error
             during design time that they would not get at runtime.  It's far worse to have that than to
             not report an error, even though one might happen later.
             </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer">
            <summary>
            Analyzes the first parsed tree to determine the set of capture numbers and names.  These are
            then used to do the second parsing pass as they can change how the regex engine interprets
            some parts of the pattern (though not the groups themselves).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer.AssignNumbersToCaptureNames">
            <summary>
            Give numbers to all named captures.  They will get successive <see
            cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.CaptureInfoAnalyzer._autoNumber"/> values that have not already been handed out to existing
            numbered capture groups.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ConsumeCurrentToken(System.Boolean)">
            <summary>
            Returns the latest token the lexer has produced, and then asks the lexer to 
            produce the next token after that.
            </summary>
            <param name="allowTrivia">Whether or not trivia is allowed on the next token
            produced.  In the .NET parser trivia is only allowed on a few constructs,
            and our parser mimics that behavior.  Note that even if trivia is allowed,
            the type of trivia that can be scanned depends on the current RegexOptions.
            For example, if <see cref="F:System.Text.RegularExpressions.RegexOptions.IgnorePatternWhitespace"/> is currently
            enabled, then '#...' comments are allowed.  Otherwise, only '(?#...)' comments
            are allowed.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.TryParse(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,System.Text.RegularExpressions.RegexOptions)">
            <summary>
            Given an input text, and set of options, parses out a fully representative syntax tree 
            and list of diagnostics.  Parsing should always succeed, except in the case of the stack 
            overflowing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.AddUniqueDiagnostics(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic})">
            <summary>
            It's very common to have duplicated diagnostics.  For example, consider "((". This will
            have two 'missing )' diagnostics, both at the end.  Reporting both isn't helpful, so we
            filter duplicates out here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParseAlternatingSequencesWorker(System.Boolean)">
            <summary>
            Parses out code of the form: ...|...|...
            This is the type of code you have at the top level of a regex, or inside any grouping
            contruct.  Note that sequences can be empty in .NET regex.  i.e. the following is legal:
            
                ...||...
            
            An empty sequence just means "match at every position in the test string".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexParser.ParseEscape(Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken{Microsoft.CodeAnalysis.EmbeddedLanguages.RegularExpressions.RegexKind},System.Boolean)">
            <summary>
            Parses out an escape sequence.  Escape sequences are allowed in top level sequences
            and in character classes.  In a top level sequence trivia will be allowed afterwards,
            but in a character class trivia is not allowed afterwards.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService.TryConvertSimpleDoubleQuoteString(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.String,System.Boolean)">
            <summary>
            Helper to convert simple string literals that escape quotes by doubling them.  This is 
            how normal VB literals and c# verbatim string literals work.
            </summary>
            <param name="startDelimiter">The start characters string.  " in VB and @" in C#</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService">
             <summary>
             Helper service that takes the raw text of a string token and produces the individual
             characters that raw string token represents (i.e. with escapes collapsed).  The difference
             between this and the result from token.ValueText is that for each collapsed character
             returned the original span of text in the original token can be found.  i.e. if you had the
             following in C#:
            
             "G\u006fo"
            
             Then you'd get back:
            
             'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)
            
             This allows for embedded language processing that can refer back to the users' original code
             instead of the escaped value we're processing.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService.TryConvertToVirtualChars(Microsoft.CodeAnalysis.SyntaxToken)">
             <summary>
             Takes in a string token and return the <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s corresponding to each
             char of the tokens <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.  In other words, for each char
             in ValueText there will be a VirtualChar in the resultant array.  Each VirtualChar will
             specify what char the language considers them to represent, as well as the span of text
             in the original <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> that the language created that char from. 
            
             For most chars this will be a single character span.  i.e. 'c' -> 'c'.  However, for
             escapes this may be a multi character span.  i.e. 'c' -> '\u0063'
            
             If the token is not a string literal token, or the string literal has any diagnostics on
             it, then <see langword="default"/> will be returned.   Additionally, because a
             VirtualChar can only represent a single char, while some escape sequences represent
             multiple chars, <see langword="default"/> will also be returned in those cases. All
             these cases could be relaxed in the future.  But they greatly simplify the
             implementation.
            
             If this function succeeds, certain invariants will hold.  First, each character in the
             sequence of characters in <paramref name="token"/>.ValueText will become a single
             VirtualChar in the result array with a matching <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Char"/> property.
             Similarly, each VirtualChar's <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar.Span"/> will abut each other, and
             the union of all of them will cover the span of the token's <see
             cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/>
             *not* including the start and quotes.
            
             In essence the VirtualChar array acts as the information explaining how the <see
             cref="P:Microsoft.CodeAnalysis.SyntaxToken.Text"/> of the token between the quotes maps to each character in the
             token's <see cref="P:Microsoft.CodeAnalysis.SyntaxToken.ValueText"/>.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar">
             <summary>
             The Regex and Json parsers wants to work over an array of characters, however this array of
             characters is not the same as the array of characters a user types into a string in C# or
             VB. For example In C# someone may write: @"\z".  This should appear to the user the same as
             if they wrote "\\z" and the same as "\\\u007a".  However, as these all have wildly different
             presentations for the user, there needs to be a way to map back the characters it sees ( '\'
             and 'z' ) back to the  ranges of characters the user wrote.  
            
             VirtualChar serves this purpose.  It contains the interpreted value of any language
             character/character-escape-sequence, as well as the original SourceText span where that
             interpreted character was created from.  This allows the regex and json parsers to both
             process input from any language uniformly, but then also produce trees and diagnostics that
             map back properly to the original source text locations that make sense to the user.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence">
             <summary>
             Represents the individual characters that raw string token represents (i.e. with escapes collapsed).  
             The difference between this and the result from token.ValueText is that for each collapsed character
             returned the original span of text in the original token can be found.  i.e. if you had the
             following in C#:
            
             "G\u006fo"
            
             Then you'd get back:
            
             'G' -> [0, 1) 'o' -> [1, 7) 'o' -> [7, 1)
            
             This allows for embedded language processing that can refer back to the user's original code
             instead of the escaped value we're processing.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk">
            <summary>
            Abstraction over a contiguous chunk of <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s.  This
            is used so we can expose <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar"/>s over an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            or over a <see cref="T:System.String"/>.  The latter is especially useful for reducing
            memory usage in common cases of string tokens without escapes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.ImmutableArrayChunk">
            <summary>
            Thin wrapper over an actual <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.
            This will be the common construct we generate when getting the
            <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> for a string token that has escapes in it.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.Chunk"/> on top of a normal
            string.  This is the common case of the type of the sequence we would
            create for a normal string token without any escapes in it.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.StringChunk._underlyingData">
            <summary>
            The underlying string that we're returning virtual chars from.  Note:
            this will commonly include things like quote characters.  Clients who
            do not want that should then ask for an appropriate <see cref="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.GetSubSequence(Microsoft.CodeAnalysis.Text.TextSpan)"/>
            back that does not include those characters.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters">
            <summary>
            The actual characters that this <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/> is a portion of.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._span">
            <summary>
            The portion of <see cref="F:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence._leafCharacters"/> that is being exposed.  This span 
            is `[inclusive, exclusive)`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence.FromBounds(Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence,Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence)">
            <summary>
            Combines two <see cref="T:Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence"/>s, producing a final
            sequence that points at the same underlying data, but spans from the 
            start of <paramref name="chars1"/> to the end of <paramref name="chars2"/>.
            </summary>  
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.AssetStorages">
            <summary>
            This is collection of asset storage
            </summary>
            <summary>
            This is collection of root checksum tree node
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.AssetStorages._globalAssets">
            <summary>
            global asset is an asset which life time is same as host
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.AssetStorages._storages">
            <summary>
            map from solution checksum scope to its associated asset storage
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.AssetStorages.Storage">
            <summary>
            root tree node of checksum tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.CustomAsset">
            <summary>
            Asset that is not part of solution, but want to participate in <see cref="T:Microsoft.CodeAnalysis.Execution.IRemotableDataService"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SimpleCustomAsset">
            <summary>
            helper type for custom asset
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.WorkspaceAnalyzerReferenceAsset">
            <summary>
            workspace analyzer specific asset.
            
            we need this to prevent dlls from other languages such as typescript, f#, xaml and etc
            from loading at OOP start up.
            
            unlike project analyzer, analyzer that got installed from vsix doesn't do shadow copying
            so we don't need to load assembly to find out actual filepath.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.CustomAssetBuilder">
            <summary>
            builder to create custom asset which is not part of solution but want to participate in <see cref="T:Microsoft.CodeAnalysis.Execution.IRemotableDataService"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.DesktopReferenceSerializationServiceFactory">
            <summary>
            this is desktop implementation of IReferenceSerializationService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SerializationAnalyzerAssemblyLoader">
            <summary>
            This is assembly loader for serialized analyzer reference. 
            
            this will record display path (<see cref="P:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.FullPath"/>  returns) and 
            actual path (<see cref="M:Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference.GetAssembly"/> ) assembly needed to be loaded 
            
            when requested, it will load from actual path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.IOptionsSerializationService">
            <summary>
            This deal with serializing/deserializing language specific data
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.IReferenceSerializationService">
            <summary>
            This deals with how to serialize/deserialize references that we have multiple implementations 
            between different layers such as workspace, host - ex, VS.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.IRemotableDataService">
            <summary>
            a service that lets one to create <see cref="T:Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope"/> that can be used to pin solution
            while working on remote host
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.AddGlobalAsset(System.Object,Microsoft.CodeAnalysis.Execution.CustomAsset,System.Threading.CancellationToken)">
            <summary>
            Add global <see cref="T:Microsoft.CodeAnalysis.Execution.CustomAsset"/> which stays alive while host is alive.
            
            this asset can be something that is not part of <see cref="T:Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope"/> 
            
            TODO: currently, this asset must be something <see cref="T:Microsoft.CodeAnalysis.Serialization.ISerializerService"/> can understand
                  this should be changed so that custom serializer can be discoverable by <see cref="F:Microsoft.CodeAnalysis.Execution.RemotableData.Kind"/> 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.GetGlobalAsset(System.Object,System.Threading.CancellationToken)">
            <summary>
            Get saved global <see cref="T:Microsoft.CodeAnalysis.Execution.CustomAsset"/> associated with given <paramref name="value"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.RemoveGlobalAsset(System.Object,System.Threading.CancellationToken)">
            <summary>
            Remove saved global <see cref="T:Microsoft.CodeAnalysis.Execution.CustomAsset"/> associated with given <paramref name="value"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.CreatePinnedRemotableDataScopeAsync(Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope"/> from <see cref="T:Microsoft.CodeAnalysis.Solution"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.GetRemotableDataAsync(System.Int32,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Execution.RemotableData"/> corresponding to given <see cref="T:Microsoft.CodeAnalysis.Checksum"/>. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IRemotableDataService.GetRemotableDataAsync(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Checksum},System.Threading.CancellationToken)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Execution.RemotableData"/>s corresponding to given <see cref="T:Microsoft.CodeAnalysis.Checksum"/>s. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.ISupportTemporaryStorage">
            <summary>
            This lets consumer to get to inner temporary storage that references use
            as its shadow copy storage
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.PinnedSolutionInfo">
            <summary>
            Information related to pinned solution
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.PinnedSolutionInfo.ScopeId">
            <summary>
            Unique ID for this pinned solution
            
            This later used to find matching solution between VS and remote host
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.PinnedSolutionInfo.FromPrimaryBranch">
            <summary>
            This indicates whether this scope is for primary branch or not (not forked solution)
            
            Features like OOP will use this flag to see whether caching information related to this solution
            can benefit other requests or not
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.PinnedSolutionInfo.WorkspaceVersion">
            <summary>
            This indicates a Solution.WorkspaceVersion of this solution. remote host engine uses this version
            to decide whether caching this solution will benefit other requests or not
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope">
            <summary>
            checksum scope that one can use to pin assets in memory while working on remote host
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope.AddAdditionalAsset(Microsoft.CodeAnalysis.Execution.CustomAsset)">
            <summary>
            Add asset that is not part of solution to be part of this snapshot.
            
            TODO: currently, this asset must be something <see cref="T:Microsoft.CodeAnalysis.Serialization.ISerializerService"/> can understand
                  this should be changed so that custom serializer can be discoverable by <see cref="F:Microsoft.CodeAnalysis.Execution.RemotableData.Kind"/> 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.Creator">
            <summary>
            This is just internal utility type to reduce allocations and reduntant code
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.ReferenceSerializationServiceFactory">
            <summary>
            this is default implementation of IReferenceSerializationService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.RemotableData">
            <summary>
            Base for object that will use <see cref="T:Microsoft.CodeAnalysis.Execution.IRemotableDataService"/> framework to synchronize data to remote host
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.RemotableData.Kind">
            <summary>
            Indicates what kind of object it is
            <see cref="T:Microsoft.CodeAnalysis.Serialization.WellKnownSynchronizationKind"/> for examples.
            
            this will be used in tranportation framework and deserialization service
            to hand shake how to send over data and deserialize serialized data
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Execution.RemotableData.Checksum">
            <summary>
            Checksum of this object
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.RemotableData.WriteObjectToAsync(Roslyn.Utilities.ObjectWriter,System.Threading.CancellationToken)">
            <summary>
            This will write out this object's data (the data the checksum is associated with) to bits
            
            this hide how each data is serialized to bits
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.RemotableData.NullRemotableData">
            <summary>
            null asset indicating things that doesn't actually exist
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.SolutionAsset">
            <summary>
            Asset that is part of solution
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Execution.IAssetProvider">
            <summary>
            Provides corresponding data of the given checksum
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Execution.IAssetProvider.GetAssetAsync``1(Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            return data of type T whose checksum is the given checksum
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService">
            <summary>
            Temporarily stores text and streams in memory mapped files.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.SingleFileThreshold">
            <summary>
            The maximum size in bytes of a single storage unit in a memory mapped file which is shared with other
            storage units.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.MultiFileBlockSize">
            <summary>
            The size in bytes of a memory mapped file created to store multiple temporary objects.
            </summary>
            <remarks>
            <para>This value was arbitrarily chosen and appears to work well. Can be changed if data suggests
            something better.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate">
            <summary>
            The synchronization object for accessing the memory mapped file related fields (indicated in the remarks
            of each field).
            </summary>
            <remarks>
            <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
            available in source control history. The use of exclusive locks was not causing any measurable
            performance overhead even on 28-thread machines at the time this was written.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference">
            <summary>
            The most recent memory mapped file for creating multiple storage units. It will be used via bump-pointer
            allocation until space is no longer available in it.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._name">
            <summary>The name of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._fileSize">
            <summary>The total size of the current memory mapped file for multiple storage units.</summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._offset">
            <summary>
            The offset into the current memory mapped file where the next storage unit can be held.
            </summary>
            <remarks>
            <para>Access should be synchronized on <see cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._gate"/>.</para>
            </remarks>
            <seealso cref="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService._weakFileReference"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.TemporaryStorageService.CreateTemporaryStorage(System.Int64)">
            <summary>
            Allocate shared storage of a specified size.
            </summary>
            <remarks>
            <para>"Small" requests are fulfilled from oversized memory mapped files which support several individual
            storage units. Larger requests are allocated in their own memory mapped files.</para>
            </remarks>
            <param name="size">The size of the shared storage block to allocate.</param>
            <returns>A <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> describing the allocated block.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo">
             <summary>
             Our own abstraction on top of memory map file so that we can have shared views over mmf files. 
             Otherwise, each view has minimum size of 64K due to requirement forced by windows.
             
             most of our view will have short lifetime, but there are cases where view might live a bit longer such as
             metadata dll shadow copy. shared view will help those cases.
             </summary>
             <remarks>
             <para>Instances of this class should be disposed when they are no longer needed. After disposing this
             instance, it should no longer be used. However, streams obtained through <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>
             or <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream"/> will not be invalidated until they are disposed independently (which
             may occur before or after the <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/> is disposed.</para>
            
             <para>This class and its nested types have familiar APIs and predictable behavior when used in other code,
             but are non-trivial to work on. The implementations of <see cref="T:System.IDisposable"/> adhere to the best
             practices described in
             <see href="http://joeduffyblog.com/2005/04/08/dg-update-dispose-finalization-and-resource-management/">DG
             Update: Dispose, Finalization, and Resource Management</see>. Additional notes regarding operating system
             behavior leveraged for efficiency are given in comments.</para>
             </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._memoryMappedFile">
            <summary>
            The memory mapped file.
            </summary>
            <remarks>
            <para>It is possible for the file to be disposed prior to the view and/or the streams which use it.
            However, the operating system does not actually close the views which are in use until the file handles
            are closed as well, even if the file is disposed first.</para>
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo._weakReadAccessor">
             <summary>
             A weak reference to a read-only view for the memory mapped file.
             </summary>
             <remarks>
             <para>This holds a weak counted reference to current <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedViewAccessor"/>, which
             allows additional accessors for the same address space to be obtained up until the point when no
             external code is using it. When the memory is no longer being used by any
             <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream"/> objects, the view of the memory mapped file is unmapped, making the
             process address space it previously claimed available for other purposes. If/when it is needed again, a
             new view is created.</para>
            
             <para>This view is read-only, so it is only used by <see cref="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream"/>.</para>
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Name">
            <summary>
            The name of the memory mapped file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Offset">
            <summary>
            The offset into the memory mapped file of the region described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.Size">
            <summary>
            The size of the region of the memory mapped file described by the current
            <see cref="T:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateReadableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will not increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.CreateWritableStream">
            <summary>
            Caller is responsible for disposing the returned stream.
            multiple call of this will increase VM.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.RunWithCompactingGCFallback``2(System.Func{``0,``1},``0)">
            <summary>
            Run a function which may fail with an <see cref="T:System.IO.IOException"/> if not enough memory is available to
            satisfy the request. In this case, a full compacting GC pass is forced and the function is attempted
            again.
            </summary>
            <remarks>
            <para><see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewAccessor(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> and
            <see cref="M:System.IO.MemoryMappedFiles.MemoryMappedFile.CreateViewStream(System.Int64,System.Int64,System.IO.MemoryMappedFiles.MemoryMappedFileAccess)"/> will use a native
            memory map, which can't trigger a GC. In this case, we'd otherwise crash with OOM, so we don't care
            about creating a UI delay with a full forced compacting GC. If it crashes the second try, it means we're
            legitimately out of resources.</para>
            </remarks>
            <typeparam name="TArg">The type of argument to pass to the callback.</typeparam>
            <typeparam name="T">The type returned by the function.</typeparam>
            <param name="function">The function to execute.</param>
            <param name="argument">The argument to pass to the function.</param>
            <returns>The value returned by <paramref name="function"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.TemporaryStorageServiceFactory.MemoryMappedInfo.SharedReadableStream.GetPointer">
            <summary>
            Get underlying native memory directly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1">
            <summary>
            This class is a <see cref="T:Roslyn.Utilities.ValueSource`1"/> that holds onto a value weakly, 
            but can save its value and recover it on demand if needed.
            
            The initial value comes from the <see cref="T:Roslyn.Utilities.ValueSource`1"/> specified in the constructor.
            Derived types implement SaveAsync and RecoverAsync.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.SaveAsync(`0,System.Threading.CancellationToken)">
            <summary>
            Override this to save the state of the instance so it can be recovered.
            This method will only ever be called once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.RecoverAsync(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement asynchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1.Recover(System.Threading.CancellationToken)">
            <summary>
            Override this method to implement synchronous recovery semantics.
            This method may be called multiple times.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WeaklyCachedValueSource`1">
            <summary>
            A value source that caches its value weakly once obtained from its source.
            The source must allow repeatable accesses.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IProjectCacheService">
            <summary>
            Service used to enable recoverable object caches for a given <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IProjectCacheHostService">
            <summary>
            Caches recoverable objects
            
            Compilations are put into a conditional weak table.
            
            Recoverable SyntaxTrees implement <see cref="T:Microsoft.CodeAnalysis.Host.ICachedObjectOwner"/> since they are numerous
            and putting them into a conditional weak table greatly increases GC costs in
            clr.dll!PromoteDependentHandle.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IProjectCacheHostService.CacheObjectIfCachingEnabledForKey``1(Microsoft.CodeAnalysis.ProjectId,System.Object,``0)">
            <summary>
            If caching is enabled for <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> key, the instance is added to 
            a conditional weak table.  
            
            It will not be collected until either caching is disabled for the project
            or the owner object is collected.
            
            If caching is not enabled for the project, the instance is added to a fixed-size
            cache.
            </summary>
            <returns>The instance passed in is always returned</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IProjectCacheHostService.CacheObjectIfCachingEnabledForKey``1(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Host.ICachedObjectOwner,``0)">
            <summary>
            If caching is enabled for <see cref="T:Microsoft.CodeAnalysis.ProjectId"/> key, <see cref="P:Microsoft.CodeAnalysis.Host.ICachedObjectOwner.CachedObject"/>
            will be set to instance.
            </summary>
            <returns>The instance passed in is always returned</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceCacheService">
            <summary>
            Workspace service for cache implementations.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IWorkspaceCacheService.CacheFlushRequested">
            <summary>
            May be raised by a Workspace host when available memory is getting low in order to request
            that caches be flushed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.DocumentPropertiesService">
            <summary>
            Extensible document properties specified via a document service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DocumentPropertiesService.DesignTimeOnly">
            <summary>
            True if the source code contained in the document is only used in design-time (e.g. for completion),
            but is not passed to the compiler when the containing project is built.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentExcerptService">
            <summary>
            excerpt some part of <see cref="T:Microsoft.CodeAnalysis.Document"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,System.Threading.CancellationToken)">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.ExcerptResult"/> of given <see cref="T:Microsoft.CodeAnalysis.Document"/> and <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>
            
            the result might not be an exact copy of the given source or contains more then given span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ExcerptMode">
            <summary>
            this mode shows intention not actual behavior. it is up to implementation how to interpret the intention.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ExcerptResult">
            <summary>
            Result of excerpt
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content">
            <summary>
            excerpt content
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.MappedSpan">
            <summary>
            span on <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content"/> that given <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Span"/> got mapped to
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.ClassifiedSpans">
            <summary>
            classification information on the <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Content"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document"/> this excerpt is from
            
            should be same document in <see cref="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,System.Threading.CancellationToken)" />
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Span">
            <summary>
            span on <see cref="F:Microsoft.CodeAnalysis.Host.ExcerptResult.Document"/> this excerpt is from
            
            should be same text span in <see cref="M:Microsoft.CodeAnalysis.Host.IDocumentExcerptService.TryExcerptAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Host.ExcerptMode,System.Threading.CancellationToken)" />
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentOperationService">
            <summary>
            TODO: Merge into <see cref="T:Microsoft.CodeAnalysis.Host.DocumentPropertiesService"/>.
            Used by Razor via IVT.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.CanApplyChange">
            <summary>
            document version of <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.SupportDiagnostics">
            <summary>
            indicates whether this document supports diagnostics or not
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDocumentService">
            <summary>
            Empty interface just to mark document services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider.GetService``1">
            <summary>
            Gets a document specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISpanMappingService">
             <summary>
             Map spans in a document to other spans even in other document
            
             this will be used by various features if provided to convert span in one document to other spans.
             
             for example, it is used to show spans users expect in a razor file rather than spans in 
             auto generated file that is implementation detail or navigate to the right place rather 
             than the generated file and etc.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ISpanMappingService.MapSpansAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},System.Threading.CancellationToken)">
            <summary>
            Map spans in the document to more appropriate locations
            
            in current design, this can NOT map a span to a span that is not backed by a file.
            for example, roslyn supports someone to have a document that is not backed by a file. and current design doesn't allow
            such document to be returned from this API
            for example, span on razor secondary buffer document in roslyn solution mapped to a span on razor cshtml file is possible but
            a span on razor cshtml file to a span on secondary buffer document is not possible since secondary buffer document is not backed by a file
            </summary>
            <param name="document">Document given spans belong to</param>
            <param name="spans">Spans in the document</param>
            <param name="cancellationToken">Cancellation token</param>
            <returns>Return mapped span. order of result should be same as the given span</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MappedSpanResult">
            <summary>
            Result of span mapping
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.FilePath">
            <summary>
            Path to mapped file
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.LinePositionSpan">
            <summary>
            LinePosition representation of the Span
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.MappedSpanResult.Span">
            <summary>
            Mapped span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.EventListenerMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.EventListenerTracker`1">
            <summary>
            helper type to track whether <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> has been initialized.
            
            currently, this helper only supports services whose lifetime is same as Host (ex, VS)
            </summary>
            <typeparam name="TService">TService for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener`1"/></typeparam>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.EventListenerTracker`1._eventListenerInitialized">
            <summary>
            Workspace kind this event listener is initialized for
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ExportEventListenerAttribute.#ctor(System.String,System.String[])">
            <summary>
            MEF export attribute for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/>
            </summary>
            <param name="service">
            one of values from <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> indicating which service this event listener is for
            </param>
            <param name="workspaceKinds">indicate which workspace kind this event listener is for</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListener">
            <summary>
            provide a way for features to lazily subscribe to a service event for particular workspace
            
            see <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> for supported services
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListenerStoppable">
            <summary>
            provide a way for <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> to mark it as stoppable
            
            for example, if the service <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> is used for is a disposable
            service, the service can call Stop when the service go away
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IEventListener`1">
            <summary>
            provide a way for features to lazily subscribe to a service event for particular workspace
            
            see <see cref="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners"/> for supported services
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceEventListenerService">
            <summary>
            Ensure <see cref="M:Microsoft.CodeAnalysis.Host.IEventListener`1.StartListening(Microsoft.CodeAnalysis.Workspace,`0)"/> is called for the workspace
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.WellKnownEventListeners">
            <summary>
            list of well known <see cref="T:Microsoft.CodeAnalysis.Host.IEventListener"/> types
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostLanguageServices">
            <summary>
            Per language services provided by the host environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.WorkspaceServices">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that originated this language service.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.Language">
            <summary>
            The name of the language
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetService``1">
            <summary>
            Gets a language specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostLanguageServices.GetRequiredService``1">
            <summary>
            Gets a language specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns throws <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostLanguageServices.CompilationFactory">
            <summary>
            A factory for creating compilations instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostServices">
            <summary>
            Services provided by the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostServices.CreateWorkspaceServices(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Creates a new workspace service. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices">
            <summary>
            Per workspace services provided by the host environment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.HostServices">
            <summary>
            The host services this workspace services originated from.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.Workspace">
            <summary>
            The workspace corresponding to this workspace services instantiation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetService``1">
            <summary>
            Gets a workspace specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetRequiredService``1">
            <summary>
            Gets a workspace specific service provided by the host identified by the service type. 
            If the host does not provide the service, this method throws <see cref="T:System.InvalidOperationException"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException">The host does not provide the service.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.PersistentStorage">
            <summary>
            A service for storing information across that can be retrieved in a separate process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TemporaryStorage">
            <summary>
            A service for storing information in a temporary location that only lasts for the duration of the process.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.TextFactory">
            <summary>
            A factory that constructs <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.SupportedLanguages">
            <summary>
            A list of language names for supported language services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.IsSupported(System.String)">
            <summary>
            Returns true if the language is supported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.GetLanguageServices(System.String)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> for the language name.
            </summary>
            <exception cref="T:System.NotSupportedException">Thrown if the language isn't supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.HostWorkspaceServices.FindLanguageServices``1(Microsoft.CodeAnalysis.Host.HostWorkspaceServices.MetadataFilter)">
            <summary>
            Finds all language services of the corresponding type across all supported languages that match the filter criteria.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ILanguageService">
            <summary>
            Empty interface just to mark language services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceService">
            <summary>
            Empty interface just to mark workspace services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportDynamicFileInfoProviderAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> implementation for MEF
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportDynamicFileInfoProviderAttribute.Extensions">
            <summary>
            file extensions this <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> can handle such as cshtml
            
            match will be done by <see cref="P:System.StringComparer.OrdinalIgnoreCase"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Language">
            <summary>
            The language that the service is target for; LanguageNames.CSharp, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; LanguageNames.CSharp, etc.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Language">
            <summary>
            The language that the service is target for; LanguageNames.CSharp, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute.#ctor(System.Type,System.String,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <param name="type">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/>.</param>
            <param name="language">The language that the service is target for; LanguageNames.CSharp, etc.</param>
            <param name="layer">The layer that the service is specified for; ServiceLayer.Default, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute.#ctor(System.Type,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute">
            <summary>
            Use this attribute to declare a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.ServiceType">
            <summary>
            The assembly qualified name of the service's type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.Layer">
            <summary>
            The layer that the service is specified for; ServiceLayer.Default, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute.#ctor(System.Type,System.String)">
            <summary>
            Declares a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> implementation for inclusion in a MEF-based workspace.
            </summary>
            <param name="serviceType">The type that will be used to retrieve the service from a <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/>.</param>
            <param name="layer">The layer or workspace kind that the service is specified for; <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default" />, <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.MiscellaneousFiles" />etc.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.FileExtensionsMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific file extensions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Language property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory.CreateLanguageService(Microsoft.CodeAnalysis.Host.HostLanguageServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> instance.
            </summary>
            <param name="languageServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostLanguageServices"/> that can be used to access other services.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata">
            <summary>
            This interface is provided purely to enable some shared logic that handles multiple kinds of 
            metadata that share the Languages property. It should not be used to find exports via MEF,
            use LanguageMetadata instead.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory">
            <summary>
            A factory that creates instances of a specific <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/>.
            
            Implement a <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> when you want to provide <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instances that use other services.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory.CreateService(Microsoft.CodeAnalysis.Host.HostWorkspaceServices)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> instance.
            Returns <c>null</c> if the service is not applicable to the given workspace.
            </summary>
            <param name="workspaceServices">The <see cref="T:Microsoft.CodeAnalysis.Host.HostWorkspaceServices"/> that can be used to access other services.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific language.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.ILanguageService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory"/> exports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.s_CreationHook">
            <summary>
            This delegate allows test code to override the behavior of <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/>.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.TestAccessor.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefHostServices.CreationHook)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.TestAccessor.HookServiceCreation(Microsoft.CodeAnalysis.Host.Mef.MefHostServices.CreationHook)">
            <summary>
            Injects replacement behavior for the <see cref="M:Microsoft.CodeAnalysis.Host.Mef.MefHostServices.Create(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})"/> method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer">
            <summary>
            The layer of an exported service.  
            
            If there are multiple definitions of a service, the <see cref="T:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer"/> is used to determine which is used.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Host">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor"/>, <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop"/> and <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Editor">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop" /> and <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Desktop">
            <summary>
            Service layer that overrides <see cref="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Host.Mef.ServiceLayer.Default">
            <summary>
            The base service layer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceKindMetadata">
            <summary>
            MEF metadata class used to find exports declared for a specific <see cref="T:Microsoft.CodeAnalysis.WorkspaceKind"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata">
            <summary>
            MEF metadata class used for finding <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceService"/> and <see cref="T:Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory"/> exports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver">
            <summary>
            Provides a way to map from an assembly name to the actual path of the .NET Framework 
            assembly with that name in the context of a specified project.  For example, if the 
            assembly name is "System.Data" then a project targeting .NET 2.0 would resolve this
            to a different path than a project targeting .NET 4.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver.ResolveAssemblyPath(Microsoft.CodeAnalysis.ProjectId,System.String,System.String)">
            <summary>
            Returns null if the assembly name could not be resolved.
            </summary>
            <param name="fullyQualifiedName">An optional type name for a type that must
            exist in the assembly.</param>
            <param name="projectId">The project context to search within.</param>
            <param name="assemblyName">The name of the assembly to try to resolve.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MetadataReferenceCache">
            <summary>
            A cache for metadata references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.MetadataReferenceCache.ReferenceSet">
            <summary>
            A collection of references to the same underlying metadata, each with different properties.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadChecksumAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            Reads the existing checksum we have for the solution with the given <paramref name="name"/>,
            or <see langword="null"/> if we do not have a checksum persisted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadChecksumAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)">
            <summary>
            Reads the existing checksum we have for the given <paramref name="project"/> with the given <paramref name="name"/>,
            or <see langword="null"/> if we do not have a checksum persisted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadChecksumAsync(Microsoft.CodeAnalysis.Document,System.String,System.Threading.CancellationToken)">
            <summary>
            Reads the existing checksum we have for the given <paramref name="document"/> with the given <paramref name="name"/>,
            or <see langword="null"/> if we do not have a checksum persisted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the solution with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="project"/> with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="document"/> with the given <paramref name="name"/>.  If <paramref name="checksum"/>
            is provided, the persisted checksum must match it.  If there is no such stream with that name, or the
            checksums do not match, then <see langword="null"/> will be returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(System.String,System.IO.Stream,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the solution with the given <paramref name="name"/>.  An optional <paramref name="checksum"/>
            can be provided to store along with the data.  This can be used along with ReadStreamAsync with future 
            reads to ensure the data is only read back if it matches that checksum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Project,System.String,System.IO.Stream,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="project"/> with the given <paramref name="name"/>.  An optional <paramref name="checksum"/>
            can be provided to store along with the data.  This can be used along with ReadStreamAsync with future 
            reads to ensure the data is only read back if it matches that checksum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage.WriteStreamAsync(Microsoft.CodeAnalysis.Document,System.String,System.IO.Stream,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)">
            <summary>
            Reads the stream for the <paramref name="document"/> with the given <paramref name="name"/>.  An optional <paramref name="checksum"/>
            can be provided to store along with the data.  This can be used along with ReadStreamAsync with future 
            reads to ensure the data is only read back if it matches that checksum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IPersistentStorageService">
            <summary>
            This service allows you to persist information relative to solution, projects and documents.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.PersistentStorageServiceFactory">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo">
            <summary>
            provides info on the given file
            
            this will be used to provide dynamic content such as generated content from cshtml to workspace
            we acquire this from <see cref="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider"/> exposed from external components such as razor for cshtml
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.FilePath">
            <summary>
            for now, return null. in future, we will use this to get right options from editorconfig
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.SourceCodeKind">
            <summary>
            return <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.SourceCodeKind"/> for this file
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.TextLoader">
            <summary>
            return <see cref="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.TextLoader"/> to load content for the dynamic file
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.DynamicFileInfo.DocumentServiceProvider">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> for the content it provided
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider">
            <summary>
            Provider for the <see cref="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo"/>
            
            implementer of this service should be pure free-thread meaning it can't switch to UI thread underneath.
            otherwise, we can get into dead lock if we wait for the dynamic file info from UI thread
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.GetDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            return <see cref="T:Microsoft.CodeAnalysis.Host.DynamicFileInfo"/> for the context given
            </summary>
            <param name="projectId"><see cref="T:Microsoft.CodeAnalysis.ProjectId"/> this file belongs to</param>
            <param name="projectFilePath">full path to project file (ex, csproj)</param>
            <param name="filePath">full path to non source file (ex, cshtml)</param>
            <returns>null if this provider can't handle the given file</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.RemoveDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            let provider know certain file has been removed
            </summary>
            <param name="projectId"><see cref="T:Microsoft.CodeAnalysis.ProjectId"/> this file belongs to</param>
            <param name="projectFilePath">full path to project file (ex, csproj)</param>
            <param name="filePath">full path to non source file (ex, cshtml)</param>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.Updated">
            <summary>
            indicate content of a file has updated. the event argument "string" should be same as "filepath" given to <see cref="M:Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider.GetDynamicFileInfoAsync(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.Threading.CancellationToken)"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService">
            <summary>
            Provides workspace status
            
            this is an work in-progress interface, subject to be changed as we work on prototype.
            
            it can completely removed at the end or new APIs can added and removed as prototype going on
            no one except one in the prototype group should use this interface.
            
            tracking issue - https://github.com/dotnet/roslyn/issues/34415
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.StatusChanged">
            <summary>
            Indicate that status has changed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.WaitUntilFullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Wait until workspace is fully loaded
            
            unfortunately, some hosts, such as VS, use services (ex, IVsOperationProgressStatusService) that require UI thread to let project system to proceed to next stages.
            what that means is that this method should only be used with either await or JTF.Run, it should be never used with Task.Wait otherwise, it can
            deadlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.IsFullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Indicates whether workspace is fully loaded
            
            unfortunately, some hosts, such as VS, use services (ex, IVsOperationProgressStatusService) that require UI thread to let project system to proceed to next stages.
            what that means is that this method should only be used with either await or JTF.Run, it should be never used with Task.Wait otherwise, it can
            deadlock
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService">
            <summary>
            Factory service for creating syntax trees.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler">
            <summary>
            An abstraction for running tasks either in sequence or in parallel.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask(System.Action,System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task action on a thread owned by a task scheduler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask``1(System.Func{``0},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask(System.Func{System.Threading.Tasks.Task},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler.ScheduleTask``1(System.Func{System.Threading.Tasks.Task{``0}},System.String,System.Threading.CancellationToken)">
            <summary>
            Execute the task function on a thread owned by a task scheduler and return the schedule
            task that can be used to wait for the result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory">
            <summary>
            A factory that creates either sequential or parallel task schedulers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory.CreateBackgroundTaskScheduler">
            <summary>
            Creates a workspace task scheduler that schedules tasks to run in parallel on the background.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory.CreateEventingTaskQueue">
            <summary>
            Creates a workspace task scheduler that schedules task to run in sequence to be used for raising
            workspace events.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ISupportDirectMemoryAccess">
            <summary>
            support direct memory access pointer
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryTextStorage">
            <summary>
            TemporaryStorage can be used to read and write text to a temporary storage location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageService">
            <summary>
            This service allows you to access temporary storage.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageService2">
            <summary>
            This service allows you to access temporary storage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageService2.AttachTemporaryStreamStorage(System.String,System.Int64,System.Int64,System.Threading.CancellationToken)">
            <summary>
            Attach to existing <see cref="T:Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage"/> with given name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITemporaryStorageService2.AttachTemporaryTextStorage(System.String,System.Int64,System.Int64,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Attach to existing <see cref="T:Microsoft.CodeAnalysis.Host.ITemporaryTextStorage"/> with given name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName">
            <summary>
            TemporaryStorage can be used to read and write text to a temporary storage location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName.Name">
            <summary>
            Get name of the temporary storage
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName.Offset">
            <summary>
            Get offset of the temporary storage
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName.Size">
            <summary>
            Get size of the temporary storage
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Host.ITextFactoryService">
            <summary>
            A factory for creating <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITextFactoryService.CreateText(System.IO.Stream,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a stream.
            </summary>
            <param name="stream">The stream to read the text from. Must be readable and seekable. The text is read from the start of the stream.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be the system encoding.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="cancellationToken">Cancellation token.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Host.ITextFactoryService.CreateText(System.IO.TextReader,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from a reader with given <paramref name="encoding"/>.
            </summary>
            <param name="reader">The <see cref="T:System.IO.TextReader"/> to read the text from.</param>
            <param name="encoding">Specifies an encoding for the <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/>SourceText. 
            it could be null. but if null is given, it won't be able to calculate checksum</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.SerializerService">
            <summary>
            serialize and deserialize objects to straem.
            some of these could be moved into actual object, but putting everything here is a bit easier to find I believe.
            
            also, consider moving this serializer to use C# BOND serializer 
            https://github.com/Microsoft/bond
            </summary>
            <summary>
            serialize and deserialize objects to stream.
            some of these could be moved into actual object, but putting everything here is a bit easier to find I believe.
            </summary>
            <summary>
            serialize and deserialize objects to straem.
            some of these could be moved into actual object, but putting everything here is a bit easier to find I believe.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ChecksumCollection">
            <summary>
            collection which children is checksum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ChecksumWithChildren">
            <summary>
            this is a collection that has its own checksum and contains only checksum or checksum collection as its children.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Serialization.ChecksumCache">
            <summary>
            hold onto object checksum that currently doesn't have a place to hold onto checksum
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IErrorReportingService.ShowErrorInfoInActiveView(System.String,Microsoft.CodeAnalysis.Extensions.InfoBarUI[])">
             <summary>
             Show error info in an active view.
            
             Different host can have different definition on what active view means.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IErrorReportingService.ShowGlobalErrorInfo(System.String,Microsoft.CodeAnalysis.Extensions.InfoBarUI[])">
             <summary>
             Show global error info.
            
             this kind error info should be something that affects whole roslyn such as
             background compilation is disabled due to memory issue and etc
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IInfoBarService.ShowInfoBarInActiveView(System.String,Microsoft.CodeAnalysis.Extensions.InfoBarUI[])">
             <summary>
             Show an info bar in the current active view.
            
             Different hosts can have different definitions on what active view means.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Extensions.IInfoBarService.ShowInfoBarInGlobalView(System.String,Microsoft.CodeAnalysis.Extensions.InfoBarUI[])">
            <summary>
            Show global info bar
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.CustomDataFlowAnalysis`1.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer{`0},System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis for the given <paramref name="analyzer"/> on the given <paramref name="controlFlowGraph"/>.
            </summary>
            <param name="controlFlowGraph">Control flow graph on which to execute analysis.</param>
            <param name="analyzer">Dataflow analyzer.</param>
            <returns>Block analysis data at the end of the exit block.</returns>
            <remarks>
            Algorithm for this CFG walker has been forked from <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder"/>'s internal
            implementation for basic block reachability computation: "MarkReachableBlocks",
            we should keep them in sync as much as possible.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1">
            <summary>
            Analyzer to execute custom dataflow analysis on a control flow graph.
            </summary>
            <typeparam name="TBlockAnalysisData">Custom data tracked for each basic block with values at start of the block.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock)">
            <summary>
            Gets current analysis data for the given basic block, or an empty analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.GetEmptyAnalysisData">
            <summary>
            Gets empty analysis data for first analysis pass on a basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.SetCurrentAnalysisData(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Updates the current analysis data for the given basic block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeBlock(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Analyze the given basic block and return the block analysis data at the end of the block for its successors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeNonConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the non-conditional fallthrough successor branch for the given basic block
            and return the block analysis data for the branch destination.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeConditionalBranch(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,`0,System.Threading.CancellationToken)">
            <summary>
            Analyze the given conditional branch for the given basic block and return the
            block analysis data for the branch destinations for the fallthrough and
            conditional successor branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.Merge(`0,`0,System.Threading.CancellationToken)">
            <summary>
            Merge the given block analysis data instances to produce the resultant merge data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.IsEqual(`0,`0)">
            <summary>
            Returns true if both the given block analysis data instances should be considered equivalent by analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1.AnalyzeUnreachableBlocks">
            <summary>
            Flag indicating if the dataflow analysis should run on unreachable blocks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind">
            <summary>
            Indicates the kind of flow capture in an <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.RValueCapture">
            <summary>
            Indicates an R-Value flow capture, i.e. capture of a symbol's value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueCapture">
            <summary>
            Indicates an L-Value flow capture, i.e. captures of a symbol's location/address.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind.LValueAndRValueCapture">
            <summary>
            Indicates both an R-Value and an L-Value flow capture, i.e. captures of a symbol's value and location/address.
            These are generated for left of a compound assignment operation, such that there is conditional code on the right side of the compound assignment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.LValueFlowCapturesProvider">
            <summary>
            Helper class to detect <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation"/>s that are l-value captures.
            L-value captures are essentially captures of a symbol's location/address.
            Corresponding <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation"/>s which share the same
            <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.CaptureId"/> as this flow capture, dereferences and writes to this location
            subsequently in the flow graph.
            For example, consider the below code:
                a[i] = x ?? a[j];
            The control flow graph contains an initial flow capture of "a[i]" to capture the l-value
            of this array element:
                FC0 (a[i])
            Then it evaluates the right hand side, which can have different
            values on different control flow paths, and the resultant value is then written
            to the captured location:
                FCR0 = result
            </summary>
            <remarks>
            NOTE: This type is a workaround for https://github.com/dotnet/roslyn/issues/31007
            and it can be deleted once that feature is implemented.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis">
            <summary>
            Analysis to compute all the symbol writes for local and parameter
            symbols in an executable code block, along with the information of whether or not the definition
            may be read on some control flow path.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData">
            <summary>
            Core analysis data to drive the operation <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker"/>
            for operation tree based analysis OR control flow graph based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._allocatedBasicBlockAnalysisDatas">
            <summary>
            Pooled <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> allocated during analysis with the
            current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData"/> instance, which will be freed during <see cref="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.Dispose"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData._referenceTakenSymbolsBuilder">
            <summary>
            Set of locals/parameters which are passed by reference to other method calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsWriteBuilder">
            <summary>
            Map from each (symbol, write) to a boolean indicating if the value assigned
            at the write is read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.SymbolsReadBuilder">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.LambdaOrLocalFunctionsBeingAnalyzed">
            <summary>
            Set of lambda/local functions whose invocations are currently being analyzed to prevent
            infinite recursion for analyzing code with recursive lambda/local function calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.CurrentBlockAnalysisData">
            <summary>
            Current block analysis data used for analysis.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.AdditionalConditionalBranchAnalysisData">
            <summary>
            Block analysis data used for an additional conditional branch.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ToResult">
            <summary>
            Creates an immutable <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult"/> for the current analysis data.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.AnalysisData.ResetState">
            <summary>
            Resets all the currently tracked symbol writes to be conservatively marked as read.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData">
            <summary>
            Analysis data for a particular <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock"/> for <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph"/>
            based dataflow analysis OR for the entire executable code block for high level operation
            tree based analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData._reachingWrites">
            <summary>
            Map from each symbol to possible set of reachable write operations that are live at current program point.
            A write is live if there is no intermediate write operation that overwrites it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.GetCurrentWrites(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the currently reachable writes for the given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData.OnWriteReferenceFound(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IOperation,System.Boolean)">
            <summary>
            Marks the given symbol write as a new unread write operation,
            potentially clearing out the prior write operations if <paramref name="maybeWritten"/> is <code>false</code>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs dataflow analysis on the given control flow graph to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Run(Microsoft.CodeAnalysis.IOperation,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Runs a fast, non-precise operation tree based analysis to compute symbol usage results
            for symbol read/writes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer">
            <summary>
            Dataflow analysis to compute symbol usage information (i.e. reads/writes) for locals/parameters
            in a given control flow graph, along with the information of whether or not the writes
            may be read on some control flow path.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analysisDataByBasicBlockMap">
            <summary>
            Map from basic block to current <see cref="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.BasicBlockAnalysisData"/> for dataflow analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._analyzeLocalFunctionOrLambdaInvocation">
            <summary>
            Callback to analyze lambda/local function invocations and return new block analysis data.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lValueFlowCapturesMap">
            <summary>
            Map from flow capture ID to set of captured symbol addresses along all possible control flow paths.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._reachingDelegateCreationTargets">
            <summary>
            Map from operations to potential delegate creation targets that could be invoked via delegate invocation
            on the operation.
            Used to analyze delegate creations/invocations of lambdas and local/functions defined in a method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._localFunctionTargetsToAccessingCfgMap">
            <summary>
            Map from local functions to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the local function was accessed
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this local function at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._lambdaTargetsToAccessingCfgMap">
            <summary>
            Map from lambdas to the <see cref="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.ControlFlowGraph"/> where the lambda was defined
            to create an invocable delegate. This control flow graph is required to lazily get or create the
            control flow graph for this lambda at delegate invocation callsite.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData._symbolWritesInsideBlockRangeMap">
            <summary>
            Map from basic block range to set of writes within this block range.
            Used for try-catch-finally analysis, where start of catch/finally blocks should
            consider all writes in the corresponding try block as reachable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.LValueFlowCapturesInGraph">
            <summary>
            Flow captures for l-value or address captures.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.DataFlowAnalyzer.FlowGraphAnalysisData.HandleCatchOrFilterOrFinallyInitialization(Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock,System.Threading.CancellationToken)">
            <summary>
            Special handling to ensure that at start of catch/filter/finally region analysis,
            we mark all symbol writes from the corresponding try region as reachable in the
            catch/filter/finally region.
            </summary>
            <param name="basicBlock"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis.Walker">
            <summary>
            Operations walker used for walking high-level operation tree
            as well as control flow graph based operations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolWritesMap">
            <summary>
            Map from each symbol write to a boolean indicating if the value assinged
            at write is used/read on some control flow path.
            For example, consider the following code:
            <code>
                int x = 0;
                x = 1;
                Console.WriteLine(x);
            </code>
            This map will have two entries for 'x':
                1. Key = (symbol: x, write: 'int x = 0')
                   Value = 'false', because value assigned to 'x' here **is never** read. 
                2. Key = (symbol: x, write: 'x = 1')
                   Value = 'true', because value assigned to 'x' here **may be** read on
                   some control flow path.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.SymbolsRead">
            <summary>
            Set of locals/parameters that are read at least once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetUnreadSymbolWrites">
            <summary>
            Gets symbol writes that have are never read.
            WriteOperation will be null for the initial value write to parameter symbols from the callsite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.IsInitialParameterValueUsed(Microsoft.CodeAnalysis.IParameterSymbol)">
            <summary>
            Returns true if the initial value of the parameter from the caller is used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult.GetSymbolWriteCount(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Gets the write count for a given local/parameter symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.GetValueUsageInfo(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/> for the given operation.
            This extension can be removed once https://github.com/dotnet/roslyn/issues/25057 is implemented.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.OperationExtensions.IsAnyCompoundAssignment(Microsoft.CodeAnalysis.IOperation)">
            <summary>
            Retursn true if the given operation is a regular compound assignment,
            i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation"/> such as <code>a += b</code>,
            or a special null coalescing compoud assignment, i.e. <see cref="T:Microsoft.CodeAnalysis.Operations.ICoalesceAssignmentOperation"/>
            such as <code>a ??= b</code>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolUsageInfo">
            <summary>
            Provides information about the way a particular symbol is being used at a symbol reference node.
            For namespaces and types, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo"/>.
            For methods, fields, properties, events, locals and parameters, this corresponds to values from <see cref="T:Microsoft.CodeAnalysis.ValueUsageInfo"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Qualified">
            <summary>
            Represents a reference to a namespace or type on the left side of a dotted name (qualified name or member access).
            For example, 'NS' in <code>NS.Type x = new NS.Type();</code> or <code>NS.Type.StaticMethod();</code> or 
            'Type' in <code>Type.NestedType x = new Type.NestedType();</code> or <code>Type.StaticMethod();</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeArgument">
            <summary>
            Represents a generic type argument reference.
            For example, 'Type' in <code>Generic{Type} x = ...;</code> or <code>class Derived : Base{Type} { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.TypeConstraint">
            <summary>
            Represents a type parameter constraint that is a type.
            For example, 'Type' in <code>class Derived{T} where T : Type { }</code>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Base">
            <summary>
            Represents a base type or interface reference in the base list of a named type.
            For example, 'Base' in <code>class Derived : Base { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.ObjectCreation">
            <summary>
            Represents a reference to a type whose instance is being created.
            For example, 'C' in <code>var x = new C();</code>, where 'C' is a named type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.Import">
            <summary>
            Represents a reference to a namespace or type within a using or imports directive.
            For example, <code>using NS;</code> or <code>using static NS.Extensions</code> or <code>using Alias = MyType</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo.NamespaceDeclaration">
            <summary>
            Represents a reference to a namespace name in a namespace declaration context.
            For example, 'N1' or <code>namespaces N1.N2 { }</code>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.None">
            <summary>
            Represents default value indicating no usage.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Read">
            <summary>
            Represents a value read.
            For example, reading the value of a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Write">
            <summary>
            Represents a value write.
            For example, assigning a value to a local/field/parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Reference">
            <summary>
            Represents a reference being taken for the symbol.
            For example, passing an argument to an "in", "ref" or "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.Name">
            <summary>
            Represents a name-only reference that neither reads nor writes the underlying value.
            For example, 'nameof(x)' or reference to a symbol 'x' in a documentation comment
            does not read or write the underlying value stored in 'x'.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadWrite">
            <summary>
            Represents a value read and/or write.
            For example, an increment or compound assignment operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "in" or "ref readonly" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.WritableReference">
            <summary>
            Represents a readable reference being taken to the value.
            For example, passing an argument to an "out" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ValueUsageInfo.ReadableWritableReference">
            <summary>
            Represents a value read or write.
            For example, passing an argument to a "ref" parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.Name">
            <summary>
            The name to pattern match against, and to show in a final presentation layer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.NameSuffix">
            <summary>
            An optional suffix to be shown in a presentation layer appended to <see cref="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.Name"/>.
            Can be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.ContainerDisplayName">
            <summary>
            Container of the symbol that can be shown in a final presentation layer. 
            For example, the container of a type "KeyValuePair" might be 
            "System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;".  This can 
            then be shown with something like "type System.Collections.Generic.Dictionary&lt;TKey, TValue&gt;"
            to indicate where the symbol is located.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.FullyQualifiedContainerName">
            <summary>
            Dotted container name of the symbol, used for pattern matching.  For example
            The fully qualified container of a type "KeyValuePair" would be 
            "System.Collections.Generic.Dictionary" (note the lack of type parameters).
            This way someone can search for "D.KVP" and have the "D" part of the pattern
            match against this.  This should not be shown in a presentation layer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo.InheritanceNames">
            <summary>
            The names directly referenced in source that this type inherits from.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder">
            <summary>
            Provides helper methods for finding dependent projects across a solution that a given symbol can be referenced within.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.DefinitionProject">
            <summary>
            A helper struct used for keying in <see cref="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.s_dependentProjectsCache"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.s_dependentProjectsCache">
            <summary>
            Dependent projects cache.
            For a given solution, maps from an assembly (source/metadata) to the set of projects referencing it.
                Key: DefinitionProject, which contains the assembly name and a flag indicating whether assembly is source or metadata assembly.
                Value: List of DependentProjects, where each DependentProject contains a dependent project ID and a flag indicating whether the dependent project has internals access to definition project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.s_createDependentProjectsMapCallback">
            <summary>
            Used to create a new concurrent dependent projects map for a given assembly when needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.GetDependentProjectsWorkerAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            This method computes the dependent projects that need to be searched for references of the given <paramref name="symbol"/>.
            This computation depends on the given symbol's visibility:
                1) Public: Dependent projects include the symbol definition project and all the referencing projects.
                2) Internal: Dependent projects include the symbol definition project and all the referencing projects that have internals access to the definition project.
                3) Private: Dependent projects include the symbol definition project and all the referencing submission projects (which are special and can reference private fields of the previous submission).
            
            We perform this computation in two stages:
                1) Compute all the dependent projects (submission + non-submission) and their InternalsVisibleTo semantics to the definition project.
                2) Filter the above computed dependent projects based on symbol visibility.
            Dependent projects computed in stage (1) are cached to avoid recomputation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.CreateInternalsVisibleToMap(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            This method creates an initial cheap InternalsVisibleTo map from the given <paramref name="assembly"/> to the assembly names that have friend access to this assembly.
            This map is a superset of the actual InternalsVisibleTo map and is used for performance reasons only.
            While identifying depend projects that can reference a given symbol (see method <see cref="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.AddNonSubmissionDependentProjectsAsync(Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Project,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.DependentProject},System.Threading.CancellationToken)"/>), we need to know a symbol's
            accessibility from referencing projects. This requires us to create a compilation for the referencing project just to check accessibility and can be performance intensive.
            Instead, we crack the assembly attributes just for the symbol's containing assembly here to enable cheap checks for friend assemblies in <see cref="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.AddNonSubmissionDependentProjectsAsync(Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Project,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.DependentProject},System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder.GetAssemblyReferenceType``1(Microsoft.CodeAnalysis.Project,System.Func{Microsoft.CodeAnalysis.IAssemblySymbol,System.Nullable{``0}},System.Threading.CancellationToken)">
            <summary>
            Determines if this project has a reference to an assembly matching a passed
            in predicate.  The predicate returns 'null' to indicate no match, and non-null
            to indicate a match of some kind.  If any match is found, that value is returned
            as the value of this function.  Otherwise 'null' is returned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder">
            <summary>
            Provides helper methods for finding dependent types (derivations, implementations, 
            etc.) across a solution.  The results found are returned in pairs of <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s
            and <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>s.  The Ids specify what project we were searching in when
            we found the symbol.  That project has the compilation that we found the specific
            source or metadata symbol within.  Note that for metadata symbols there could be
            many projects where the same symbol could be found.  However, we only return the
            first instance we found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.FindImmediatelyDerivedClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Used for implementing the Inherited-By relation for progression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.FindTransitivelyDerivedClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            This is an internal implementation of <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId{Microsoft.CodeAnalysis.INamedTypeSymbol},Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>, which is a publically callable method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.FindTransitivelyImplementingStructuresAndClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Implementation of <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/> for 
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.FindTransitivelyImplementingStructuresClassesAndInterfacesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Implementation of <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/> for 
            <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder.FindImmediatelyDerivedAndImplementingTypesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Used for implementing the Inherited-By relation for progression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.FindDocumentsAsync(Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken,System.String[])">
            <summary>
            Finds all the documents in the provided project that contain the requested string
            values
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder.CollectMatchingReferences">
            <summary>
            If the `node` implicitly matches the `symbol`, then it will be added to `locations`.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node">
            <summary>
            The actual node that we found the reference on.  Normally the 'Name' portion
            of any piece of syntax.  Might also be something like a 'foreach' statement node
            when finding results for something like GetEnumerator.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Location">
            <summary>
            The location we want want to return through the FindRefs API.  The location contains
            additional information (like if this was a Write, or if it was Implicit).  This value
            also has a <see cref="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Location"/> property.  Importantly, this value
            is not necessarily the same location you would get by calling <see cref="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node"/>.<see
            cref="M:Microsoft.CodeAnalysis.SyntaxNode.GetLocation"/>.  Instead, this location is where we want to navigate
            the user to.  A case where this can be different is with an indexer reference.  The <see
            cref="F:Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation.Node"/> will be the node for the full 'ElementAccessExpression', whereas the 
            location we will take the user to will be the zero-length position immediately preceding
            the `[` character.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.ILanguageServiceReferenceFinder">
            <summary>
            Extensibility interface to allow individual languages to extend the 'Find References' service. 
            Languages can use this to provide specialized cascading logic between symbols that 'Find 
            References' is searching for.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder">
            <summary>
            Extensibility interface to allow extending the IFindReferencesService service.  Implementations
            must be thread-safe as the methods on this interface may be called on multiple threads
            simultaneously.  Implementations should also respect the provided cancellation token and
            should try to cancel themselves quickly when requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineCascadedSymbolsAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine when a new symbol definition is found.
            Implementations can then choose to request more symbols be searched for.  For example, an
            implementation could choose for the find references search engine to cascade to
            constructors when searching for standard types.
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineProjectsToSearchAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine which projects should be
            searched for a given symbol.  The returned projects will then be searched in parallel. If
            the implementation does not care about the provided symbol then null can be returned
            from this method.
            
            Implementations should endeavor to keep the list of returned projects as small as
            possible to keep search time down to a minimum.  Returning the entire list of projects in
            a solution is not recommended (unless, of course, there is reasonable reason to believe
            there are references in every project).
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.DetermineDocumentsToSearchAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Project,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine which documents in the supplied
            project need to be searched for references.  Only projects returned by
            DetermineProjectsToSearch will be passed to this method.
            
            Implementations should endeavor to keep the list of returned documents as small as
            possible to keep search time down to a minimum.  Returning the entire list of documents
            in a project is not recommended (unless, of course, there is reasonable reason to
            believe there are references in every document).
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder.FindReferencesInDocumentAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions,System.Threading.CancellationToken)">
            <summary>
            Called by the find references search engine to determine the set of reference locations
            in the provided document.  Only documents returned by DetermineDocumentsToSearch will be
            passed to this method. 
            
            Implementations of this method must be thread-safe.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders.DefaultReferenceFinders">
            <summary>
            The list of common reference finders.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.FindReferencesProgress">
            <summary>
            A class that reports the current progress made when finding references to symbols.  
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine._documentToLocationMap">
            <summary>
            Mapping from a document to the list of reference locations found in it.  Kept around so
            we only notify the callback once when a location is found for a reference (in case
            multiple finders find the same reference location for a symbol).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.AssociatePropertyReferencesWithSpecificAccessor">
            <summary>
            When searching for property, associate specific references we find to the relevant
            accessor symbol (if there is one).  For example, in C#, this would result in:
            
                P = 0;     // A reference to the P.set accessor
                var v = P; // A reference to the P.get accessor
                P++;       // A reference to P.get and P.set accessors
                nameof(P); // A reference only to P.  Not associated with a particular accessor.
                
            The default for this is false.  With that default, all of the above references
            are associated with the property P and not the accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions.GetFeatureOptionsForStartingSymbol(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            For IDE features, if the user starts searching on an accessor, then we want to give
            results associated with the specific accessor.  Otherwise, if they search on a property,
            then associate everything with the property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgress">
            <summary>
            A class that reports the current progress made when finding references to symbols.  
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgressAdapter">
            <summary>
            Wraps an <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress"/> into an <see cref="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress"/>
            so it can be used from the new streaming find references APIs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress">
            <summary>
            Reports the progress of the FindReferences operation.  Note: these methods may be called on
            any thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress">
            <summary>
            Reports the progress of the FindReferences operation.  Note: these methods may be called on
            any thread.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol">
            <summary>
            Represents a single result of the call to the synchronous
            IFindReferencesService.FindReferences method. Finding the references to a symbol will result
            in a set of definitions being returned (containing at least the symbol requested) as well as
            any references to those definitions in the source. Multiple definitions may be found due to
            how C# and VB allow a symbol to be both a definition and a reference at the same time (for
            example, a method which implements an interface method).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Definition">
            <summary>
            The symbol definition that these are references to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol.Locations">
            <summary>
            The set of reference locations in the solution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation">
            <summary>
            Information about a reference to a symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Document">
            <summary>
            The document that the reference was found in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Alias">
            <summary>
            If the symbol was bound through an alias, then this is the alias that was used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.Location">
            <summary>
            The actual source location for a given symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsImplicit">
            <summary>
            Indicates if this is an implicit reference to the definition.  i.e. the definition wasn't
            explicitly stated in the source code at this position, but it was still referenced. For
            example, this can happen with special methods like GetEnumerator that are used
            implicitly by a 'for each' statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsWrittenTo">
            <summary>
            Indicates if this is a location where the reference is written to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.SymbolUsageInfo">
            <summary>
            Symbol usage info for this reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.AdditionalProperties">
            <summary>
            Additional properties for this reference
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation.IsCandidateLocation">
            <summary>
            Indicates if this was not an exact reference to a location, but was instead a possible
            location that was found through error tolerance.  For example, a call to a method like
            "Goo()" could show up as an error tolerance location to a method "Goo(int i)" if no
            actual "Goo()" method existed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Exact">
            <summary>
            Use an case-sensitive comparison when searching for matching items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.ExactIgnoreCase">
            <summary>
            Use a case-insensitive comparison when searching for matching items.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Fuzzy">
            <summary>
            Use a fuzzy comparison when searching for matching items. Fuzzy matching allows for 
            a certain amount of misspellings, missing words, etc. See <see cref="T:Roslyn.Utilities.SpellChecker"/> for 
            more details.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Custom">
            <summary>
            Search term is matched in a custom manner (i.e. with a user provided predicate).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery.Name">
            <summary>The name being searched for.  Is null in the case of custom predicate searching..  But 
            can be used for faster index based searching when it is available.</summary> 
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery.Kind">
            <summary>The kind of search this is.  Faster index-based searching can be used if the 
             SearchKind is not <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SearchKind.Custom"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SearchQuery._predicate">
            <summary>The predicate to fall back on if faster index searching is not possible.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.StreamingProgressCollector">
            <summary>
            Collects all the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> definitions and <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation"/> 
            references that are reported independently and packages them up into the final list
            of <see cref="T:Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol" />.  This is used by the old non-streaming Find-References
            APIs to return all the results at the end of the operation, as opposed to broadcasting
            the results as they are found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId">
            <summary>
            Represents a symbol and the project it was acquired from.
            It should always be the case that if you have the original solution
            that this symbol came from, that you'll be able to find this symbol
            in the compilation for the specified project.
            
            Note that the 'Same' symbol could be acquired from many different projects
            (after all, each project sees, at least, all the public symbols for all the 
            projects it references).  As such, a single ISymbol could be found in many
            places.  The ProjectId at least gives us a single place to look for it again.
            
            The purpose of this type is to support serializing/deserializing symbols
            and allowing features to work out-of-process (OOP).  In OOP scenarios, 
            we will need to marshal <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>s to and from the host and 
            the external process.  That means being able to recover the <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> 
            on either side.  With the <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId.ProjectId"/> this becomes possible.
            
            Accordingly, it is ok to have a <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId"/> that does
            not have a <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId.ProjectId"/>.  It just means that that data cannot
            be marshalled in an OOP scenario.  Existing features, and third party clients
            will then have code that still works (albeit just in-process).  However,
            code that updates to use this can then opt-into working OOP.
            
            Note: for purposes of Equality/Hashing, all that we use is the underlying
            Symbol.  That's because nearly all IDE features only care if they're looking
            at the same symbol, they don't care if hte symbol came from a different 
            project or not.  i.e. a feature like FAR doesn't want to cascade into the 
            "same" symbol even if it hits it in another project.  As such, we do not
            include the ProjectId when computing the result.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdComparer`1">
            <summary>
            Provides a way for us to store and compare SymbolAndProjectId in the
            sets that we're using.  For the purposes of the operations in 
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder"/> these entities are the same if they
            point to Symbols that are considered the same.  For example, if
            we find a derived type of 'X' called 'Y' in a metadata assembly 'M'
            in project A and we also find a derived type of 'X' called 'Y' in a 
            metadata assembly 'M' in project B, then we consider these the same.
            What project we were searching in does not matter to us in terms of
            deciding if these symbols are the same or not.  We're only keeping
            the projects to return to the caller information about what project
            we were searching when we found the symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdComparer`1._underlyingComparer">
            <summary>
            Note(cyrusn): We're using SymbolEquivalenceComparer.Instance as the underlying 
            way of comparing symbols.  That's probably not correct as it won't appropriately
            deal with forwarded types.  However, that's the behavior that we've already had
            in this type for a while, so this is just preserving that logic.  If this is an 
            issue in the future, this underlying comparer can absolutely be changed to something
            more appropriate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdComparer.SymbolEquivalenceInstance">
            <summary>
            Note(cyrusn): We're using SymbolEquivalenceComparer.Instance as the underlying 
            way of comparing symbols.  That's probably not correct as it won't appropriately
            deal with forwarded types.  However, that's the behavior that we've already had
            in this type for a while, so this is just preserving that logic.  If this is an 
            issue in the future, this underlying comparer can absolutely be changed to something
            more appropriate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo">
            <summary>
            Contains information about a call from one symbol to another.  The symbol making the call is
            stored in CallingSymbol and the symbol that the call was made to is stored in CalledSymbol.
            Whether or not the call is direct or indirect is also stored.  A direct call is a call that
            does not go through any other symbols in the inheritance hierarchy of CalledSymbol, while an
            indirect call does go through the inheritance hierarchy.  For example, calls through a base
            member that this symbol overrides, or through an interface member that this symbol
            implements will be considered 'indirect'. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CallingSymbol">
            <summary>
            The symbol that is calling the symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.Locations">
            <summary>
            The locations inside the calling symbol where the called symbol is referenced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.CalledSymbol">
            <summary>
            The symbol being called.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo.IsDirect">
            <summary>
            True if the CallingSymbol is directly calling CalledSymbol.  False if it is calling a
            symbol in the inheritance hierarchy of the CalledSymbol.  For example, if the called
            symbol is a class method, then an indirect call might be through an interface method that
            the class method implements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPosition(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Obsolete.  Use <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSymbolAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,System.Threading.CancellationToken)">
            <summary>
            Finds the symbol that is associated with a position in the text of a document.
            </summary>
            <param name="semanticModel">The semantic model associated with the document.</param>
            <param name="position">The character position within the document.</param>
            <param name="workspace">A workspace to provide context.</param>
            <param name="cancellationToken">A CancellationToken.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDefinitionAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds the definition symbol declared in source code for a corresponding reference symbol. 
            Returns null if no such symbol can be found in the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSimilarSymbols``1(``0,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Finds symbols in the given compilation that are similar to the specified symbol.
            
            A found symbol may be the exact same symbol instance if the compilation is the origin of the specified symbol, 
            or it may be a different symbol instance if the compilation is not the originating compilation.
            
            Multiple symbols may be returned if there are ambiguous matches.
            No symbols may be returned if the compilation does not define or have access to a similar symbol.
            </summary>
            <param name="symbol">The symbol to find corresponding matches for.</param>
            <param name="compilation">A compilation to find the corresponding symbol within. The compilation may or may not be the origin of the symbol.</param>
            <param name="cancellationToken">A CancellationToken.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesServerCallback">
            <summary>
            Callback object we pass to the OOP server to hear about the result 
            of the FindReferencesEngine as it executes there.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the declared symbols from either source, referenced projects or metadata assemblies with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the declared symbols from either source, referenced projects or metadata assemblies with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.Func{System.String,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with a matching name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsAsync(Microsoft.CodeAnalysis.Project,System.String,System.Boolean,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Solution,System.String,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Solution,System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Project,System.String,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindSourceDeclarationsWithPatternAsync(Microsoft.CodeAnalysis.Project,System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Find the symbols for declarations made in source with the specified pattern. This pattern is matched
            using heuristics that may change from release to release. So, the set of symbols matched by a given
            pattern may change between releases. For example, new symbols may be matched by a pattern and/or
            symbols previously matched by a pattern no longer are. However, the set of symbols matched by a
            specific release will be consistent for a specific pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="documents">A set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindReferencesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all references to a symbol throughout a solution
            </summary>
            <param name="symbol">The symbol to find references to.</param>
            <param name="solution">The solution to find references within.</param>
            <param name="progress">An optional progress object that will receive progress
            information as the search is undertaken.</param>
            <param name="documents">An optional set of documents to be searched. If documents is null, then that means "all documents".</param>
            <param name="cancellationToken">An optional cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindOverridesAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for members that override the specified member symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementedInterfaceMembersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Find symbols for declarations that implement members of the specified interface symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindDerivedClassesAsync(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the derived classes of the given type. Implementations of an interface are not considered "derived", but can be found
            with <see cref="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)"/>.
            </summary>
            <param name="type">The symbol to find derived types of.</param>
            <param name="solution">The solution to search in.</param>
            <param name="projects">The projects to search. Can be null to search the entire solution.</param>
            <param name="cancellationToken"></param>
            <returns>The derived types of the symbol. The symbol passed in is not included in this list.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindImplementationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Project},System.Threading.CancellationToken)">
            <summary>
            Finds the symbols that implement an interface or interface member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolFinder.FindCallersAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Collections.Immutable.IImmutableSet{Microsoft.CodeAnalysis.Document},System.Threading.CancellationToken)">
            <summary>
            Finds all the callers of a specified symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.ISymbolTreeInfoCacheService.TryGetSourceSymbolTreeInfoAsync(Microsoft.CodeAnalysis.Project,System.Threading.CancellationToken)">
            <summary>
            Returns null if the info cannot be retrieved from the cache.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTree.ISymbolTreeInfoCacheService.TryGetMetadataSymbolTreeInfoAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.PortableExecutableReference,System.Threading.CancellationToken)">
            <summary>
            Returns null if the info cannot be retrieved from the cache.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._concatenatedNames">
            <summary>
            To prevent lots of allocations, we concatenate all the names in all our
            Nodes into one long string.  Each Node then just points at the span in
            this string with the portion they care about.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._nodes">
            <summary>
            The list of nodes that represent symbols. The primary key into the sorting of this 
            list is the name. They are sorted case-insensitively with the <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_totalComparer" />.
            Finding case-sensitive matches can be found by binary searching for something that 
            matches insensitively, and then searching around that equivalence class for one that 
            matches.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._inheritanceMap">
            <summary>
            Inheritance information for the types in this assembly.  The mapping is between
            a type's simple name (like 'IDictionary') and the simple metadata names of types 
            that implement it or derive from it (like 'Dictionary').
            
            Note: to save space, all names in this map are stored with simple ints.  These
            ints are the indices into _nodes that contain the nodes with the appropriate name.
            
            This mapping is only produced for metadata assemblies.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._simpleTypeNameToExtensionMethodMap">
            <summary>
            Maps the name of target type name of simple extension methods to its <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo" />.
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo"/> for the definition of simple/complex methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._extensionMethodOfComplexType">
            <summary>
            A list of <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo" /> for complex extension methods.
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo"/> for the definition of simple/complex methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._spellCheckerTask">
            <summary>
            The task that produces the spell checker we use for fuzzy match queries.
            We use a task so that we can generate the <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> 
            without having to wait for the spell checker construction to finish.
            
            Features that don't need fuzzy matching don't want to incur the cost of 
            the creation of this value.  And the only feature which does want fuzzy
            matching (add-using) doesn't want to block waiting for the value to be
            created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FuzzyFindAsync(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.IAssemblySymbol},System.String,System.Threading.CancellationToken)">
            <summary>
            Finds symbols in this assembly that match the provided name in a fuzzy manner.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FindAsync(Roslyn.Utilities.AsyncLazy{Microsoft.CodeAnalysis.IAssemblySymbol},System.String,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Get all symbols that have a name matching the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FindNodeIndices(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node},System.String,Microsoft.CodeAnalysis.Utilities.StringSliceComparer)">
            <summary>
            Gets all the node indices with matching names per the <paramref name="comparer" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BinarySearch(System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node},System.String)">
            <summary>
            Searches for a name in the ordered list that matches per the <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_caseInsensitiveComparer" />.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.FirstEntityHandleProvider">
            <summary>
            Used to produce the simple-full-name components of a type from metadata.
            The name is 'simple' in that it does not contain things like backticks,
            generic arguments, or nested type + separators.  Instead just hte name
            of the type, any containing types, and the component parts of its namespace
            are added.  For example, for the type "X.Y.O`1.I`2, we will produce [X, Y, O, I]
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.BuilderNode"/>s are produced when initially creating our indices.
            They store Names of symbols and the index of their parent symbol.  When we
            produce the final <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> though we will then convert
            these to <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node"/>s.  Those nodes will not point to individual 
            strings, but will instead point at <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._concatenatedNames"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node.NameSpan">
            <summary>
            Span in <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._concatenatedNames"/> of the Name of this Node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node.ParentIndex">
            <summary>
            Index in <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo._nodes"/> of the parent Node of this Node.
            Value will be <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.RootNodeParentIndex"/> if this is the 
            Node corresponding to the root symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.Name">
            <summary>
            This is the type name of the parameter when <see cref="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.IsComplexType"/> is false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ParameterTypeInfo.IsComplexType">
            <summary>
            Similar to <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.ExtensionMethodInfo"/>, we divide extension methods into simple 
            and complex categories for filtering purpose. Whether a method is simple is determined based on if we 
            can determine it's target type easily with a pure text matching. For complex methods, we will need to
            rely on symbol to decide if it's feasible.
            
            Simple types include:
            - Primitive types
            - Types which is not a generic method parameter
            - By reference type of any types above
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo.Name">
            <summary>
            Name of the extension method. 
            This can be used to retrive corresponding symbols via <see cref="M:Microsoft.CodeAnalysis.INamespaceOrTypeSymbol.GetMembers(System.String)"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.ExtensionMethodInfo.FullyQualifiedContainerName">
            <summary>
            Fully qualified name for the type that contains this extension method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.GetInfoForMetadataReferenceAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.PortableExecutableReference,Microsoft.CodeAnalysis.Checksum,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Produces a <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo"/> for a given <see cref="T:Microsoft.CodeAnalysis.PortableExecutableReference"/>.
            Note:  will never return null;
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.MetadataDefinition.TargetTypeInfo">
            <summary>
            Only applies to member kind. Represents the type info of the first parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.LoadOrCreateSpellCheckerAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Checksum,System.String,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.Node})">
            <summary>
            Loads the SpellChecker for a given assembly symbol (metadata or project).  If the
            info can't be loaded, it will be created (and persisted if possible).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.TryLoadOrCreateAsync``1(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Checksum,System.Boolean,System.Func{System.Threading.Tasks.Task{``0}},System.String,System.Func{Roslyn.Utilities.ObjectReader,``0},System.Threading.CancellationToken)">
            <summary>
            Generalized function for loading/creating/persisting data.  Used as the common core
            code for serialization of SymbolTreeInfos and SpellCheckers.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo.s_projectToSourceChecksum">
            <summary>
            Cache of project to the checksum for it so that we don't have to expensively recompute
            this each time we get a project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.ExtensionMethodInfo.SimpleExtensionMethodInfo">
            <summary>
            Name of the simple method's target type name to the index of its DeclaredSymbolInfo in `_declarationInfo`.
            All predefined types are converted to its metadata form. e.g. int => Int32. For generic types, type parameters are ignored.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.ExtensionMethodInfo.ComplexExtensionMethodInfo">
            <summary>
            Indices of to all complex methods' DeclaredSymbolInfo in `_declarationInfo`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.IdentifierInfo.ProbablyContainsIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) to be within the
            syntax tree.  Returns false when the identifier is guaranteed to not be within the
            syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.IdentifierInfo.ProbablyContainsEscapedIdentifier(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) escaped within the
            text of the syntax tree.  Returns false when the identifier is guaranteed to not be
            escaped within the text of the syntax tree.  An identifier that is not escaped within
            the text can be found by searching the text directly.  An identifier that is escaped can
            only be found by parsing the text and syntactically interpreting any escaping
            mechanisms found in the language ("\uXXXX" or "@XXXX" in C# or "[XXXX]" in Visual
            Basic).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.LiteralInfo.ProbablyContainsStringValue(System.String)">
            <summary>
            Returns true when the identifier is probably (but not guaranteed) to be within the
            syntax tree.  Returns false when the identifier is guaranteed to not be within the
            syntax tree.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.s_projectStringTable">
            <summary>
            String interning table so that we can share many more strings in our DeclaredSymbolInfo
            buckets.  Keyed off a Project instance so that we share all these strings as we create
            the or load the index items for this a specific Project.  This helps as we will generally 
            be creating or loading all the index items for the documents in a Project at the same time.
            Once this project is let go of (which happens with any solution change) then we'll dump
            this string table.  The table will have already served its purpose at that point and 
            doesn't need to be kept around further.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormattingService">
            <summary>
            Base implementation of C# and VB formatting services.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`2">
            <summary>
            a tweaked version of our interval tree to meet the formatting engine's need
            
            it now has an ability to return a smallest span that contains a position rather than
            all Intersecting or overlapping spans
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext">
            <summary>
            this class maintain contextual information such as 
            indentation of current position, based token to follow in current position and etc.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData">
            <summary>
            data that will be used in an interval tree related to Anchor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData">
            <summary>
            data that will be used in an interval tree related to indentation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressSpacingData">
            <summary>
            data that will be used in an interval tree related to suppressing spacing operations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.SuppressWrappingData">
            <summary>
            data that will be used in an interval tree related to suppressing wrapping operations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the node with the given trivia information in the map
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.FormatSummary">
            <summary>
            return summary for current formatting work
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine.OperationApplier">
            <summary>
            this actually applies formatting operations to trivia between two tokens
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.FormattedSpan">
            <summary>
            span in the tree to format
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult.Rewriter(System.Collections.Generic.Dictionary{System.ValueTuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.TriviaData},System.Threading.CancellationToken)">
            <summary>
            rewrite the tree info root node with the trivia information in the map
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory.Whitespace">
            <summary>
            represents a general trivia between two tokens. slightly more expensive than others since it
            needs to calculate stuff unlike other cases
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.NodeOperations">
            <summary>
            this collector gathers formatting operations that are based on a node
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenData">
            <summary>
            it represents a token that is inside of token stream not also outside of token stream
            
            it uses an index to navigate previous and after tokens in the stream to make navigation faster. and regular
            Previous/NextToken for tokens outside of the stream.
            
            this object is supposed to be live very short but created a lot of time. that is why it is struct. 
            (same reason why SyntaxToken is struct - to reduce heap allocation)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations">
            <summary>
            it holds onto space and wrapping operation need to run between two tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream">
            <summary>
            This class takes care of tokens consumed in the formatting engine.
            
            It will maintain information changed compared to original token information. and answers
            information about tokens.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TokenStream.Changes">
            <summary>
            Thread-safe collection that holds onto changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.TokenStream.GetColumn(Microsoft.CodeAnalysis.Formatting.TokenData,System.Func{Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TokenData,Microsoft.CodeAnalysis.Formatting.TriviaData})">
            <summary>
            Get column of the token 
            * column means text position on a line where all tabs are converted to spaces that first position on a line becomes 0
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TreeData">
            <summary>
            this provides information about the syntax tree formatting service is formatting.
            this provides necessary abstraction between different kinds of syntax trees so that ones that contain
            actual text or cache can answer queries more efficiently.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.TriviaData">
            <summary>
            it holds onto trivia information between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Formatter">
            <summary>
            Formats whitespace in documents or syntax trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.Formatter.Annotation">
            <summary>
            The annotation used to mark portions of a syntax tree to be formatted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Document)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetDefaultFormattingRules(Microsoft.CodeAnalysis.Workspace,System.String)">
            <summary>
            Gets the formatting rules that would be applied if left unspecified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in a document.
            </summary>
            <param name="document">The document to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in an area of a document corresponding to a text span.
            </summary>
            <param name="document">The document to format.</param>
            <param name="span">The span of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="document">The document to format.</param>
            <param name="spans">The spans of the document's text to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.FormatAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to annotated nodes.
            </summary>
            <param name="document">The document to format.</param>
            <param name="annotation">The annotation used to find on nodes to identify spans to format.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree corresponding to annotated nodes.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="annotation">The annotation used to find nodes to identify spans to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by a span.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="span">The span within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.Format(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a syntax tree identified by multiple non-overlapping spans.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="spans">The spans within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted tree's root node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="span">The span within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.GetFormattedTextChanges(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Determines the changes necessary to format the whitespace of a syntax tree.
            </summary>
            <param name="node">The root node of a syntax tree to format.</param>
            <param name="spans">The spans within the node's full span to format.</param>
            <param name="workspace">A workspace used to give the formatting context.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The changes necessary to format the tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Formatter.OrganizeImportsAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Organizes the imports in the document.
            </summary>
            <param name="document">The document to organize.</param>
            <param name="cancellationToken">The cancellation token that the operation will observe.</param>
            <returns>The document with organized imports. If the language does not support organizing imports, or if no changes were made, this method returns <paramref name="document"/>.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormattingDiagnosticId">
            <summary>
            This is the ID reported for formatting diagnostics.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds.FormatDocumentControlDiagnosticId">
            <summary>
            This special diagnostic can be suppressed via <c>#pragma</c> to prevent the formatter from making changes to
            code formatting within the span where the diagnostic is suppressed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Formatting.FormattingOptions.PreferredWrappingColumn">
            <summary>
            Default value of 120 was picked based on the amount of code in a github.com diff at 1080p.
            That resolution is the most common value as per the last DevDiv survey as well as the latest
            Steam hardware survey.  This also seems to a reasonable length default in that shorter
            lengths can often feel too cramped for .NET languages, which are often starting with a
            default indentation of at least 16 (for namespace, class, member, plus the final construct
            indentation).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.IFormattingResult">
            <summary>
            Contains changes that can be either applied to different targets such as a buffer or a tree
            or examined to be used in other places such as quick fix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.IFormattingService.FormatAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Formats the whitespace in areas of a document corresponding to multiple non-overlapping spans.
            </summary>
            <param name="document">The document to format.</param>
            <param name="spans">The spans of the document's text to format. If null, the entire document should be formatted.</param>
            <param name="options">An optional set of formatting options. If these options are not supplied the current set of options from the document's workspace will be used.</param>
            <param name="cancellationToken">An optional cancellation token.</param>
            <returns>The formatted document.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule">
            <summary>
            Provide a custom formatting operation provider that can intercept/filter/replace default formatting operations.
            </summary>
            <remarks>All methods defined in this class can be called concurrently. Must be thread-safe.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddSuppressOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAnchorIndentationOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddIndentBlockOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.AddAlignTokensOperations(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustNewLinesOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule.GetAdjustSpacesOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddSuppressOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction@)">
            <summary>
            Returns SuppressWrappingIfOnSingleLineOperations under a node either by itself or by
            filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAnchorIndentationOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction@)">
            <summary>
            returns AnchorIndentationOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddIndentBlockOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction@)">
            <summary>
            returns IndentBlockOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.AddAlignTokensOperationsSlow(System.Collections.Generic.List{Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction@)">
            <summary>
            returns AlignTokensOperations under a node either by itself or by filtering/replacing operations returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustNewLinesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation@)">
            <summary>
            returns AdjustNewLinesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule.GetAdjustSpacesOperationSlow(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet,Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation@)">
            <summary>
            returns AdjustSpacesOperation between two tokens either by itself or by filtering/replacing a operation returned by NextOperation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation">
            <summary>
            indicate how many lines are needed between two tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption">
            <summary>
            Options for AdjustNewLinesOperation.
            
            PreserveLines means the operation will leave lineBreaks as it is if original lineBreaks are
            equal or greater than given lineBreaks
            
            ForceLines means the operation will force existing lineBreaks to the given lineBreaks.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation">
            <summary>
            indicate how many spaces are needed between two spaces
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption">
            <summary>
            Options for AdjustSpacesOperation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.PreserveSpaces">
            <summary>
            Preserve spaces as it is
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DefaultSpacesIfOnSingleLine">
            <summary>
            DefaultSpacesIfOnSingleLine means a default space operation created by the formatting
            engine by itself. It has its own option kind to indicates that this is an operation
            generated by the engine itself. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpacesIfOnSingleLine">
            <summary>
            ForceSpaceIfOnSingleLine means forcing the specified spaces between two tokens if two
            tokens are on a single line. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.ForceSpaces">
            <summary>
            ForceSpaces means forcing the specified spaces regardless of positions of two tokens.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption.DynamicSpaceToIndentationIfOnSingleLine">
            <summary>
            If two tokens are on a single line, second token will be placed at current indentation if possible
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation">
            <summary>
            align first tokens on lines among the given tokens to the base token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption">
            <summary>
            option to control AlignTokensOperation behavior
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation">
            <summary>
            preserve relative spaces between anchor token and first tokens on lines within the given text span 
            as long as it doesn't have explicit line operations associated with them
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            create anchor indentation region around start and end token
            start token will act as anchor token and right after anchor token to end of end token will become anchor region
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAnchorIndentationOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            create anchor indentation region more explicitly by providing all necessary information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around start and end token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateSuppressOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption)">
            <summary>
            create suppress region around the given text span
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the existing indentation at the position of the start token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the start and end token with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateRelativeIndentBlockOperation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Text.TextSpan,System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption)">
            <summary>
            create indent block region around the given text span with the given indentation delta added to the column of the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAlignTokensOperation(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption)">
            <summary>
            instruct the engine to try to align first tokens on the lines among the given tokens to be aligned to the base token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustNewLinesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption)">
            <summary>
            instruct the engine to try to put the give lines between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.CreateAdjustSpacesOperation(System.Int32,Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption)">
            <summary>
            instruct the engine to try to put the given spaces between two tokens
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetSuppressOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return SuppressOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAnchorIndentationOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AnchorIndentationOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetIndentBlockOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return IndentBlockOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAlignTokensOperations(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AlignTokensOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustNewLinesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AdjustNewLinesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations.GetAdjustSpacesOperation(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            return AdjustSpacesOperation for the node provided by the given formatting rules
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation">
            <summary>
            set indentation level for the given text span. it can be relative, absolute or dependent to other tokens
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption">
            <summary>
            Options for IndentBlockOperation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativeToFirstTokenOnBaseTokenLine">
            <summary>
            This indentation will be a delta to the first token in the line in which the base token is present
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePosition">
            <summary>
            IndentationDeltaOrPosition will be interpreted as delta of its enclosing indentation
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.AbsolutePosition">
            <summary>
            IndentationDeltaOrPosition will be interpreted as absolute position
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.RelativePositionMask">
            <summary>
            Mask for relative position options
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption.PositionMask">
            <summary>
            Mask for position options
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation">
            <summary>
            suppress formatting operations within the given text span
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption">
            <summary>
            Options for SuppressOperation
            
            NoWrappingIfOnSingleLine means no wrapping if given tokens are on same line
            NoWrapping means no wrapping regardless of relative positions of two tokens
            NoSpacing means no spacing regardless of relative positions of two tokens
            
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption.DisableFormatting">
            <summary>
            Completely disable formatting within a span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.#cctor">
            <summary>
            set up space string caches
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Formatter`1">
            <summary>
            format the trivia at the line column and put changes to the changes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.WhitespaceAppender`1">
            <summary>
            create whitespace for the delta at the line column and put changes to the changes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Succeeded">
            <summary>
            return whether this formatting succeeded or not
            for example, if there is skipped tokens in one of trivia between tokens
            we consider formatting this region is failed
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is whitespace trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsEndOfLine(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            check whether given trivia is end of line trivia or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNullOrWhitespace(System.String)">
            <summary>
            check whether given string is either null or whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsWhitespace(System.Char)">
            <summary>
            check whether given char is whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.IsNewLine(System.Char)">
            <summary>
            check whether given char is new line char
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateWhitespace(System.String)">
            <summary>
            create whitespace trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.CreateEndOfLine">
            <summary>
            create end of line trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            return line column rule for the given two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.List{Microsoft.CodeAnalysis.SyntaxTrivia},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.Format(Microsoft.CodeAnalysis.Formatting.LineColumn,Microsoft.CodeAnalysis.SyntaxTrivia,System.Collections.Generic.List{Microsoft.CodeAnalysis.Text.TextChange},System.Threading.CancellationToken)">
            <summary>
            format the given trivia at the line column position and put text change result to the changes list
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsImplicitLineBreak(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            returns true if the trivia contains a Line break
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetOverallLineColumnRuleBetween(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.Formatting.LineColumnDelta,System.Boolean,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            get line column rule between two trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTokensAtEdgeOfStructureTrivia(Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxToken@,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            if the given trivia is the very first or the last trivia between two normal tokens and 
            if the trivia is structured trivia, get one token that belongs to the structured trivia and one belongs to the normal token stream
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.ContainsOnlyWhitespace(System.Int32,System.Int32)">
            <summary>
            check whether string between start and end position only contains whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.FirstLineBlank">
            <summary>
            check whether first line between two tokens contains only whitespace
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter.GetTrailingLinesAtEndOfTrivia1(Microsoft.CodeAnalysis.Formatting.LineColumn)">
            <summary>
            return 0 or 1 based on line column of the trivia1's end point
            this is based on our structured trivia's implementation detail that some structured trivia can have
            one new line at the end of the trivia
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.AbstractIndentationService`1.ShouldUseTokenIndenter(Microsoft.CodeAnalysis.Indentation.AbstractIndentationService{`0}.Indenter,Microsoft.CodeAnalysis.SyntaxToken@)">
            <summary>
            Returns <see langword="true"/> if the language specific <see
            cref="T:Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter"/> should be deferred to figure out indentation.  If so, it
            will be asked to <see cref="M:Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter.FormatTokenAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)"/> the resultant
            <paramref name="token"/> provided by this method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Indentation.IndentationResult">
            <summary>
            An indentation result represents where the indent should be placed.  It conveys this through
            a pair of values.  A position in the existing document where the indent should be relative,
            and the number of columns after that the indent should be placed at.  
            
            This pairing provides flexibility to the implementor to compute the indentation results in
            a variety of ways.  For example, one implementation may wish to express indentation of a 
            newline as being four columns past the start of the first token on a previous line.  Another
            may wish to simply express the indentation as an absolute amount from the start of the 
            current line.  With this tuple, both forms can be expressed, and the implementor does not
            have to convert from one to the other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Indentation.IndentationResult.BasePosition">
            <summary>
            The base position in the document that the indent should be relative to.  This position
            can occur on any line (including the current line, or a previous line).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Indentation.IndentationResult.Offset">
            <summary>
            The number of columns the indent should be at relative to the BasePosition's column.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Indentation.IIndentationService.GetIndentation(Microsoft.CodeAnalysis.Document,System.Int32,Microsoft.CodeAnalysis.Formatting.FormattingOptions.IndentStyle,System.Threading.CancellationToken)">
            <summary>
            Determines the desired indentation of a given line.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.IPrecedenceService.GetPrecedenceKind(System.Int32)">
            <summary>
            Returns the precedence of the given expression, mapped down to one of the 
            <see cref="T:Microsoft.CodeAnalysis.LanguageServices.PrecedenceKind"/> values.  The mapping is language specific.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.IPrecedenceService.GetOperatorPrecedence(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns the precedence of this expression in a scale specific to a particular
            language.  These values cannot be compared across languages, but relates the 
            precedence of expressions in the same language.  A smaller value means lower
            precedence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSemanticFactsService.GetCollidableSymbols(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Retrieves all symbols that could collide with a symbol at the specified location.
            A symbol can possibly collide with the location if it is available to that location and/or
            could cause a compiler error if its name is re-used at that location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.SupportsImplicitInterfaceImplementation">
            <summary>
            True if this language supports implementing an interface by signature only. If false,
            implementations must specific explicitly which symbol they're implementing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.ExposesAnonymousFunctionParameterNames">
            <summary>
            True if anonymous functions in this language have signatures that include named
            parameters that can be referenced later on when the function is invoked.  Or, if the
            anonymous function is simply a signature that will be assigned to a delegate, and the
            delegate's parameter names are used when invoking.  
            
            For example, in VB one can do this: 
            
            dim v = Sub(x as Integer) Blah()
            v(x:=4)
            
            However, in C# that would need to be:
            
            Action&lt;int&gt; v = (int x) => Blah();
            v(obj:=4)
            
            Note that in VB one can access 'x' outside of the declaration of the anonymous type.
            While in C# 'x' can only be accessed within the anonymous type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.IsWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: reads may also be performed
            to the expression as well.  For example, "++a".  In this expression 'a' is both read from
            and written to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.IsOnlyWrittenTo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            True if a write is performed to the given expression.  Note: unlike IsWrittenTo, this
            will not return true if reads are performed on the expression as well.  For example,
            "++a" will return 'false'.  However, 'a' in "out a" or "a = 1" will return true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            return speculative semantic model for supported node. otherwise, it will return null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService.GetAliasNameSet(Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            get all alias names defined in the semantic model
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService.GetDeclarations(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Given a symbol in source, returns the syntax nodes that compromise its declarations.
            This differs from symbol.Locations in that Locations returns a list of ILocations that
            normally correspond to the name node of the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractDeclaredSymbolInfoFactoryService.GetTargetTypeName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Get the name of the target type of specified extension method declaration. 
            The node provided must be an extension method declaration,  i.e. calling `TryGetDeclaredSymbolInfo()` 
            on `node` should return a `DeclaredSymbolInfo` of kind `ExtensionMethod`. 
            If the return value is null, then it means this is a "complex" method (as described at <see cref="T:Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex.ExtensionMethodInfo"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSyntaxFactsService.SpansPreprocessorDirective(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Determines if there is preprocessor trivia *between* any of the <paramref name="tokens"/>
            provided.  The <paramref name="tokens"/> will be deduped and then ordered by position.
            Specifically, the first token will not have it's leading trivia checked, and the last
            token will not have it's trailing trivia checked.  All other trivia will be checked to
            see if it contains a preprocessor directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.AbstractSyntaxFactsService.TryGetAncestorForLocation``1(Microsoft.CodeAnalysis.SyntaxNode,System.Int32)">
            <summary>
            Tries to get an ancestor of a Token on current position or of Token directly to left:
            e.g.: tokenWithWantedAncestor[||]tokenWithoutWantedAncestor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsReservedKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns 'true' if this a 'reserved' keyword for the language.  A 'reserved' keyword is a
            identifier that is always treated as being a special keyword, regardless of where it is
            found in the token stream.  Examples of this are tokens like <see langword="class"/> and
            <see langword="Class"/> in C# and VB respectively.
            
            Importantly, this does *not* include contextual keywords.  If contextual keywords are
            important for your scenario, use <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)"/> or <see
            cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsServiceExtensions.IsReservedOrContextualKeyword(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxToken)"/>.  Also, consider using
            <see cref="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsServiceExtensions.IsWord(Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxToken)"/> if all you need is the ability to know 
            if this is effectively any identifier in the language, regardless of whether the language
            is treating it as a keyword or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsContextualKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns <see langword="true"/> if this a 'contextual' keyword for the language.  A
            'contextual' keyword is a identifier that is only treated as being a special keyword in
            certain *syntactic* contexts.  Examples of this is 'yield' in C#.  This is only a
            keyword if used as 'yield return' or 'yield break'.  Importantly, identifiers like <see
            langword="var"/>, <see langword="dynamic"/> and <see langword="nameof"/> are *not*
            'contextual' keywords.  This is because they are not treated as keywords depending on
            the syntactic context around them.  Instead, the language always treats them identifiers
            that have special *semantic* meaning if they end up not binding to an existing symbol.
            
            Importantly, if <paramref name="token"/> is not in the syntactic construct where the
            language thinks an identifier should be contextually treated as a keyword, then this
            will return <see langword="false"/>.
            
            Or, in other words, the parser must be able to identify these cases in order to be a
            contextual keyword.  If identification happens afterwards, it's not contextual.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsPreprocessorKeyword(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            The set of identifiers that have special meaning directly after the `#` token in a
            preprocessor directive.  For example `if` or `pragma`.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetLeftSideOfDot(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Get the node on the left side of the dot if given a dotted expression. 
            </summary>
            <param name="allowImplicitTarget">
            In VB, we have a member access expression with a null expression, this may be one of the
            following forms:
                1) new With { .a = 1, .b = .a      .a refers to the anonymous type
                2) With obj : .m                   .m refers to the obj type
                3) new T() With { .a = 1, .b = .a  'a refers to the T type
            If `allowImplicitTarget` is set to true, the returned node will be set to approperiate node, otherwise, it will return null.
            This parameter has no affect on C# node.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetExpressionOfMemberAccessExpression(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns the expression node the member is being accessed off of.  If <paramref name="allowImplicitTarget"/>
            is <see langword="false"/>, this will be the node directly to the left of the dot-token.  If <paramref name="allowImplicitTarget"/>
            is <see langword="true"/>, then this can return another node in the tree that the member will be accessed
            off of.  For example, in VB, if you have a member-access-expression of the form ".Length" then this
            may return the expression in the surrounding With-statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsSimpleArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            True if this is an argument with just an expression and nothing else (i.e. no ref/out,
            no named params, no omitted args).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsMethodBody(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true for nodes that represent the body of a method.
            
            For VB this will be 
            MethodBlockBaseSyntax.  This will be true for things like constructor, method, operator
            bodies as well as accessor bodies.  It will not be true for things like sub() function()
            lambdas.  
            
            For C# this will be the BlockSyntax or ArrowExpressionSyntax for a 
            method/constructor/deconstructor/operator/accessor.  It will not be included for local
            functions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsTypeCharacter(System.Char)">
            <summary>
            Returns true if the given character is a character which may be included in an
            identifier to specify the type of a variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsScopeBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A block that has no semantics other than introducing a new scope. That is only C# BlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsExecutableBlock(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that contains a list of statements. In C#, this is BlockSyntax and SwitchSectionSyntax.
            In VB, this includes all block statements such as a MultiLineIfBlockSyntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.IsStatementContainer(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            A node that can host a list of statements or a single statement. In addition to
            every "executable block", this also includes C# embedded statement owners.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetMemberBodySpanForSpeculativeBinding(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, return the <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> representing the span of the member body
            it is contained within. This <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> is used to determine whether speculative binding should be
            used in performance-critical typing scenarios. Note: if this method fails to find a relevant span, it returns
            an empty <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/> at position 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetBindableParent(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns the parent node that binds to the symbols that the IDE prefers for features like
            Quick Info and Find All References. For example, if the token is part of the type of
            an object creation, the parenting object creation expression is returned so that binding
            will return constructor symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService.GetNameForArgument(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>, that represents and argument return the string representation of
            that arguments name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService">
            <summary>
            Provides a uniform view of SyntaxKinds over C# and VB for constructs they have
            in common.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService.LogicalAndExpression">
            <summary>
            A short-circuiting logical 'and'. In C#, 'LogicalAndExpression'. In VB, 'AndAlsoExpression'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService.LogicalOrExpression">
            <summary>
            A short-circuiting logical 'or'. In C#, 'LogicalOrExpression'. In VB, 'OrElseExpression'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService">
            <summary>
            Helper service for telling you what type can be inferred to be viable in a particular
            location in code.  This is useful for features that are starting from code that doesn't bind,
            but would like to know type that code should be in the location that it can be found in.  For
            example:
            
              int i = Here(); 
            
            If 'Here()' doesn't bind, then this class can be used to say that it is currently in a
            location whose type has been inferred to be 'int' from the surrounding context.  Note: this
            is simply a best effort guess.  'byte/short/etc.' as well as any user convertible types to
            int would also be valid here, however 'int' seems the most reasonable when considering user
            intuition.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.AbstractLogAggregator`1">
            <summary>
            helper class to aggregate some numeric value log in client side
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Maximum">
            <summary>
            maximum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Minimum">
            <summary>
            minimum value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Median">
            <summary>
            middle value of the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mean">
            <summary>
            average value of the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Mode">
            <summary>
            most frequent value in the total data set
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Range">
            <summary>
            difference between max and min value
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.StatisticResult.Count">
            <summary>
            number of data points in the total data set
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.AggregateLogger">
            <summary>
            a logger that aggregate multiple loggers
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock">
            <summary>
            no op log block
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EmptyLogger">
            <summary>
            a logger that doesn't do anything
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.EtwLogger">
            <summary>
            A logger that publishes events to ETW using an EventSource.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.FunctionId">
            <summary>
            Enum to uniquely identify each function location.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.HistogramLogAggregator">
            <summary>
            Defines a log aggregator to create a histogram
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.ILogger">
            <summary>
            logger interface actual logger should implements
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.IsEnabled(Microsoft.CodeAnalysis.Internal.Log.FunctionId)">
            <summary>
            answer whether it is enabled or not for the specific function id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockStart(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log a start event with context message
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.ILogger.LogBlockEnd(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            log an end event
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.InteractionClass">
            <summary>
            An interaction class defines how much time is expected to reach a time point, the response 
            time point being the most commonly used. The interaction classes correspond to human perception,
            so, for example, all interactions in the Fast class are perceived as fast and roughly feel like 
            they have the same performance. By defining these interaction classes, we can describe 
            performance using adjectives that have a precise, consistent meaning.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage">
            <summary>
            LogMessage that creates key value map lazily
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogType">
            <summary>
            Type of log it is making.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogType.Trace">
            <summary>
            Log some traces of an activity (default)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.LogType.UserAction">
            <summary>
            Log an user explicit action
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger">
            <summary>
            provide a way to log activities to various back end such as etl, code marker and etc
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.Logger.s_lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.SetLogger(Microsoft.CodeAnalysis.Internal.Log.ILogger)">
            <summary>
            give a way to explicitly set/replace the logger
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetLogger">
            <summary>
            ensure we have a logger by putting one from workspace service if one is not there already.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String)">
            <summary>
            log a specific event with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String})">
            <summary>
            log a specific event with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3)">
            <summary>
            log a specific event with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.Log(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage)">
            <summary>
            log a specific event with a context message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken)">
            <summary>
            simplest way to log a start and end pair with a simple context message which should be very cheap to create
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{System.String},System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that will only be created when it is needed.
            the messageGetter should be cheap to create. in another word, it shouldn't capture any locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``1(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,System.String},``0,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``2(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,System.String},``0,``1,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``3(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,System.String},``0,``1,``2,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock``4(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Func{``0,``1,``2,``3,System.String},``0,``1,``2,``3,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message that requires some arguments to be created when requested.
            given arguments will be passed to the messageGetter so that it can create the context message without requiring lifted locals
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.Logger.LogBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,Microsoft.CodeAnalysis.Internal.Log.LogMessage,System.Threading.CancellationToken)">
            <summary>
            log a start and end pair with a context message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.Logger.RoslynLogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.LogMessage">
            <summary>
            log message that can generate string lazily
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.LogMessage.FreeCore">
            <summary>
            Logger will call this to return LogMessage to its pool
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource">
            <summary>
            This EventSource exposes our events to ETW.
            RoslynEventSource GUID is {bf965e67-c7fb-5c5b-d98f-cdf68f8154c2}.
            
            When updating this class, use the following to also update Main\Source\Test\Performance\Log\RoslynEventSourceParser.cs:
            Main\Tools\Source\TraceParserGen\bin\Debug\TraceParserGen.exe Microsoft.CodeAnalysis.Workspaces.dll -eventsource:RoslynEventSource
            
            Use this command to register the ETW manifest on any machine where you need to decode events in xperf/etlstackbrowse:
            "\\clrmain\tools\managed\etw\eventRegister\bin\Debug\eventRegister.exe" Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogInformationalBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.Object,System.Threading.CancellationToken)">
            <summary>
            Logs an informational block with given <paramref name="entity"/>'s <see cref="M:System.Object.ToString"/> representation as the message
            and specified <paramref name="functionId"/>.
            On dispose of the returned disposable object, it logs the 'tick' count between the start and end of the block.
            Unlike other logging methods on <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/>, this method does not check
            if the specified <paramref name="functionId"/> was explicitly enabled.
            Instead it checks if the <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/> was enabled at <see cref="F:System.Diagnostics.Tracing.EventLevel.Informational"/> level.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogInformationalBlock(Microsoft.CodeAnalysis.Internal.Log.FunctionId,System.String,System.Threading.CancellationToken)">
            <summary>
            Logs an informational message block with the given <paramref name="message"/>> and specified <paramref name="functionId"/>.
            On dispose of the returned disposable object, it logs the 'tick' count between the start and end of the block.
            Unlike other logging methods on <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/>, this method does not check
            if the specified <paramref name="functionId"/> was explicitly enabled.
            Instead it checks if the <see cref="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource"/> was enabled at <see cref="F:System.Diagnostics.Tracing.EventLevel.Informational"/> level.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock">
            <summary>
            This tracks the logged message. On instantiation, it logs 'Started block' with other event data.
            On dispose, it logs 'Ended block' with the same event data so we can track which block started and ended when looking at logs.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock.s_lastUniqueBlockId">
            <summary>
            next unique block id that will be given to each LogBlock
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource.LogBlock.GetNextUniqueBlockId">
            <summary>
            return next unique pair id
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Internal.Log.TraceLogger">
            <summary>
            Implementation of <see cref="T:Microsoft.CodeAnalysis.Internal.Log.ILogger"/> that produce timing debug output. 
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Started">
            <summary>
            raised when global operation is started
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Stopped">
            <summary>
            raised when global operation is stopped
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService.Start(System.String)">
            <summary>
            start new global operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.DocumentOptionSet">
            <summary>
            An <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> that comes from <see cref="M:Microsoft.CodeAnalysis.Document.GetOptionsAsync(System.Threading.CancellationToken)"/>. It behaves just like a normal
            <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> but remembers which language the <see cref="T:Microsoft.CodeAnalysis.Document"/> is, so you don't have to
            pass that information redundantly when calling <see cref="M:Microsoft.CodeAnalysis.Options.DocumentOptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0})"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.DocumentOptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.DocumentOptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1">
            <summary>
            Specifies that an option should be read from an .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1.GetEditorConfigString(`0,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Gets the editorconfig string representation for this storage location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigString(System.Object,Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Gets the editorconfig string representation for this storage location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.GlobalOptionService.GetSerializableOptionsSnapshot(System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.IOptionService)">
            <summary>
            Gets force computed serializable options with prefetched values for all the registered options applicable to the given <paramref name="languages"/> by quering the option persisters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IDocumentOptions">
            <summary>
            Returned from a <see cref="T:Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IDocumentOptions.TryGetDocumentOption(Microsoft.CodeAnalysis.Options.OptionKey,System.Object@)">
            <summary>
            Attempts to fetch the value for the given option.
            </summary>
            <param name="option"></param>
            <param name="value">The value returned. May be null even if the function returns true as "null" may be valid value for some options.</param>
            <returns>True if this provider had a specific value for this option. False to indicate other providers should be queried.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider">
            <summary>
            Implemented to provide options that apply to specific documents, like from .editorconfig files.
            </summary>
            <remarks>
            This is passed to <see cref="M:Microsoft.CodeAnalysis.Options.IOptionService.RegisterDocumentOptionsProvider(Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider)"/> to activate it
            for a workspace. This instance then lives around for the lifetime of the workspace.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider.GetOptionsForDocumentAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Fetches a <see cref="T:Microsoft.CodeAnalysis.Options.IDocumentOptions"/> for the given document. Any asynchronous work (looking for config files, etc.)
            should be done here. Can return a null-valued task to mean there is no options being provided for this document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IDocumentOptionsProviderFactory">
            <summary>
            A MEF-exported factory which produces <see cref="T:Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider"/>s for <see cref="T:Microsoft.CodeAnalysis.Workspace"/>s.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IGlobalOptionService">
            <summary>
            Provides services for reading and writing options.
            This will provide support for options at the global level (i.e. shared among
            all workspaces/services).
            
            In general you should not import this type directly, and should instead get an
            <see cref="T:Microsoft.CodeAnalysis.Options.IOptionService"/> from <see cref="P:Microsoft.CodeAnalysis.Workspace.Services"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.SetOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Applies a set of options, invoking serializers if needed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetSerializableOptionsSnapshot(System.Collections.Immutable.ImmutableHashSet{System.String},Microsoft.CodeAnalysis.Options.IOptionService)">
            <summary>
            Gets force computed serializable options snapshot with prefetched values for the registered options applicable to the given <paramref name="languages"/> by quering the option persisters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetRegisteredOptions">
            <summary>
            Returns the set of all registered options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.GetRegisteredSerializableOptions(System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Returns the set of all registered serializable options applicable for the given <paramref name="languages"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.RefreshOption(Microsoft.CodeAnalysis.Options.OptionKey,System.Object)">
            <summary>
            Refreshes the stored value of a serialized option. This should only be called from serializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.RegisterWorkspace(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Registers a workspace with the option service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IGlobalOptionService.UnregisterWorkspace(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Unregisters a workspace from the option service.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionPersister">
            <summary>
            Exportable by a host to specify the save and restore behavior for a particular set of
            values.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionService">
            <summary>
            Provides services for reading and writing options.  This will provide support for
            customizations workspaces need to perform around options.  Note that 
            <see cref="T:Microsoft.CodeAnalysis.Options.IGlobalOptionService"/> options will normally still be offered through 
            implementations of this.  However, implementations may customize things differently 
            depending on their needs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the current value of the specific option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetOptions">
            <summary>
            Fetches an immutable set of all current options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetSerializableOptionsSnapshot(System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Gets a serializable option set snapshot with force computed values for all registered serializable options applicable for the given <paramref name="languages"/> by quering the option persisters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.SetOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Applies a set of options.
            </summary>
            <param name="optionSet">New options to set.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetRegisteredOptions">
            <summary>
            Returns the set of all registered options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetRegisteredSerializableOptions(System.Collections.Immutable.ImmutableHashSet{System.String})">
            <summary>
            Returns the set of all registered serializable options applicable for the given <paramref name="languages"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.RegisterDocumentOptionsProvider(Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider)">
            <summary>
            Registers a provider that can modify the result of <see cref="M:Microsoft.CodeAnalysis.Document.GetOptionsAsync(System.Threading.CancellationToken)"/>. Providers registered earlier are queried first
            for options, and the first provider to give a value wins.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.GetUpdatedOptionSetForDocumentAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> that applies to a specific document, given that document and the global options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.RegisterWorkspace(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Registers a workspace with the option service.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.IOptionService.UnregisterWorkspace(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Unregisters a workspace from the option service.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IOptionWithGroup">
            <summary>
            Group/sub-feature associated with an <see cref="T:Microsoft.CodeAnalysis.Options.IOption"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group">
            <summary>
            Group/sub-feature for this option.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IWorkspaceOptionService">
            <summary>
            Interface used for exposing functionality from the option service that we don't want to 
            ever be public.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.LocalUserProfileStorageLocation">
            <summary>
            Specifies that the option should be stored into the user's local registry hive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionGroup">
            <summary>
            Group/sub-feature associated with an <see cref="T:Microsoft.CodeAnalysis.Options.IOption"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Description">
            <summary>
            A localizable resource description string for the option group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.OptionGroup.Priority">
            <summary>
            Relative priority of the option group with respect to other option groups within the same feature.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionServiceFactory.OptionService">
            <summary>
            Wraps an underlying <see cref="T:Microsoft.CodeAnalysis.Options.IGlobalOptionService"/> and exposes its data to workspace
            clients.  Also takes the <see cref="E:Microsoft.CodeAnalysis.Options.IGlobalOptionService.OptionChanged"/> notifications
            and forwards them along using the same <see cref="T:Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler"/> used by the
            <see cref="T:Microsoft.CodeAnalysis.Workspace"/> this is connected to.  i.e. instead of synchronously just passing
            along the underlying events, these will be enqueued onto the workspace's eventing queue.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.OptionServiceFactory.OptionService._gate">
            <summary>
            Gate guarding <see cref="F:Microsoft.CodeAnalysis.Options.OptionServiceFactory.OptionService._eventHandlers"/> and <see cref="F:Microsoft.CodeAnalysis.Options.OptionServiceFactory.OptionService._documentOptionsProviders"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption(Microsoft.CodeAnalysis.Options.OptionKey)">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.Option{``0})">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.GetOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String)">
            <summary>
            Gets the value of the option.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption(Microsoft.CodeAnalysis.Options.OptionKey,System.Object)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.Option{``0},``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.OptionSet.WithChangedOption``1(Microsoft.CodeAnalysis.Options.PerLanguageOption{``0},System.String,``0)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet" /> that contains the changed value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.OptionStorageLocation">
            <summary>
            The base type of all types that specify where options are stored.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.ILanguageSpecificOption">
            <summary>
            Marker interface for <see cref="T:Microsoft.CodeAnalysis.Options.Option`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.Option`1">
            <summary>
            An global option. An instance of this class can be used to access an option value from an OptionSet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Feature">
            <summary>
            Feature this option is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Group">
            <summary>
            Optional group/sub-feature for this option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Name">
            <summary>
            The name of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.DefaultValue">
            <summary>
            The default value of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Option`1.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.IPerLanguageOption">
            <summary>
            Marker interface for <see cref="T:Microsoft.CodeAnalysis.Options.PerLanguageOption`1"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.PerLanguageOption`1">
            <summary>
            An option that can be specified once per language.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Feature">
            <summary>
            Feature this option is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Group">
            <summary>
            Optional group/sub-feature for this option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Name">
            <summary>
            The name of the option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.Type">
            <summary>
            The type of the option value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.PerLanguageOption`1.DefaultValue">
            <summary>
            The default option value.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.PredefinedDocumentOptionsProviderNames.EditorConfig">
            <summary>
            The name of the providers for .editorconfig. Both the current and legacy providers will use this name, so that way any other clients can
            order relative to the pair. The two factories are unordered themselves because only one ever actually gives a real provider.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute.Language">
            <summary>
            Optional source language for language specific option providers.  See <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/>.
            This will be empty string for language agnostic option providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute.#ctor">
            <summary>
            Constructor for language agnostic option providers.
            Use <see cref="M:Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute.#ctor(System.String)"/> overload for language specific option providers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute.#ctor(System.String)">
            <summary>
            Constructor for language specific option providers.
            Use <see cref="M:Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute.#ctor"/> overload for language agnostic option providers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation">
            <summary>
            Specifies that the option should be stored into a roamed profile across machines.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation.#ctor(System.Func{System.String,System.String})">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation"/> that has different key names for different languages.
            </summary>
            <param name="keyNameFromLanguageName">A function that maps from a <see cref="T:Microsoft.CodeAnalysis.LanguageNames"/> value to the key name.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.SerializableOptionSet">
            <summary>
            Serializable implementation of <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> for <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            It contains prepopulated fetched option values for all serializable options and values, and delegates to <see cref="T:Microsoft.CodeAnalysis.Options.SerializableOptionSet.WorkspaceOptionSet"/> for non-serializable values.
            It ensures a contract that values are immutable from this instance once observed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._languages">
            <summary>
            Languages for which all the applicable serializable options have been prefetched and saved in <see cref="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._serializableOptionValues"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._workspaceOptionSet">
            <summary>
            Fallback option set for non-serializable options. See comments on <see cref="T:Microsoft.CodeAnalysis.Options.SerializableOptionSet.WorkspaceOptionSet"/> for more details.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._serializableOptions">
            <summary>
            All serializable options for <see cref="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._languages"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._serializableOptionValues">
            <summary>
            Prefetched option values for all <see cref="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._serializableOptions"/> applicable for <see cref="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._languages"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Options.SerializableOptionSet._changedOptionKeys">
            <summary>
            Set of changed options in this option set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.SerializableOptionSet.GetChangedOptions">
            <summary>
            Gets a list of all the options that were changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Options.SerializableOptionSet.WorkspaceOptionSet">
            <summary>
            An implementation of <see cref="T:Microsoft.CodeAnalysis.Options.OptionSet"/> for non-serializable options that are defined in VS layers.
            It fetches values it doesn't know about to the workspace's option service. It ensures a contract
            that values are immutable from this instance once observed.
            TODO: Remove this type once we move all the options from the VS layers into Workspaces/Features, so the entire
                  option set is serializable and becomes pure data snapshot for options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Options.SerializableOptionSet.WorkspaceOptionSet.GetChangedOptions">
            <summary>
            Gets a list of all the options that were changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher">
            <summary>
            The pattern matcher is thread-safe.  However, it maintains an internal cache of
            information as it is used.  Therefore, you should not keep it around forever and should get
            and release the matcher appropriately once you no longer need it.
            Also, while the pattern matcher is culture aware, it uses the culture specified in the
            constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher">
            <summary>
            Encapsulated matches responsible for matching an all lowercase pattern against
            a candidate using CamelCase matching. i.e. this code is responsible for finding the
            match between "cofipro" and "CodeFixProvider". 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher.TryMatch(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Text.TextSpan}@)">
            <summary>
            Returns null if no match was found, 1 if a contiguous match was found, 2 if a 
            match as found that starts at the beginning of the candidate, and 3 if a contiguous
            match was found that starts at the beginning of the candidate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.AllLowerCamelCaseMatcher.UpdateBestResultIfBetter(Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.CamelCaseResult,System.Nullable{Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.CamelCaseResult}@,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Updates the currently stored 'best result' if the current result is better.
            Returns 'true' if no further work is required and we can break early, or 
            'false' if we need to keep on going.
            
            If 'weight' is better than 'bestWeight' and matchSpanToAdd is not null, then
            matchSpanToAdd will be added to matchedSpansInReverse.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.#ctor(System.Boolean,System.Globalization.CultureInfo,System.Boolean)">
            <summary>
            Construct a new PatternMatcher using the specified culture.
            </summary>
            <param name="culture">The culture to use for string searching and comparison.</param>
            <param name="includeMatchedSpans">Whether or not the matching parts of the candidate should be supplied in results.</param>
            <param name="allowFuzzyMatching">Whether or not close matches should count as matches.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.MatchPatternSegment(System.String,Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PatternSegment,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.PatternMatching.PatternMatch},System.Boolean)">
            <summary>
            Internal helper for MatchPatternInternal
            </summary>
            <remarks>
            PERF: Designed to minimize allocations in common cases.
            If there's no match, then null is returned.
            If there's a single match, or the caller only wants the first match, then it is returned (as a Nullable)
            If there are multiple matches, and the caller wants them all, then a List is allocated.
            </remarks>
            <param name="candidate">The word being tested.</param>
            <param name="segment">The segment of the pattern to check against the candidate.</param>
            <param name="matches">The result array to place the matches in.</param>
            <param name="fuzzyMatch">If a fuzzy match should be performed</param>
            <returns>If there's only one match, then the return value is that match. Otherwise it is null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PartStartsWith(System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.Globalization.CompareOptions)">
            <summary>
            Do the two 'parts' match? i.e. Does the candidate part start with the pattern part?
            </summary>
            <param name="candidate">The candidate text</param>
            <param name="candidatePart">The span within the <paramref name="candidate"/> text</param>
            <param name="pattern">The pattern text</param>
            <param name="patternPart">The span within the <paramref name="pattern"/> text</param>
            <param name="compareOptions">Options for doing the comparison (case sensitive or not)</param>
            <returns>True if the span identified by <paramref name="candidatePart"/> within <paramref name="candidate"/> starts with
            the span identified by <paramref name="patternPart"/> within <paramref name="pattern"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PartStartsWith(System.String,Microsoft.CodeAnalysis.Text.TextSpan,System.String,System.Globalization.CompareOptions)">
            <summary>
            Does the given part start with the given pattern?
            </summary>
            <param name="candidate">The candidate text</param>
            <param name="candidatePart">The span within the <paramref name="candidate"/> text</param>
            <param name="pattern">The pattern text</param>
            <param name="compareOptions">Options for doing the comparison (case sensitive or not)</param>
            <returns>True if the span identified by <paramref name="candidatePart"/> within <paramref name="candidate"/> starts with <paramref name="pattern"/></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.PatternSegment">
            <summary>
            First we break up the pattern given by dots.  Each portion of the pattern between the
            dots is a 'Segment'.  The 'Segment' contains information about the entire section of 
            text between the dots, as well as information about any individual 'Words' that we 
            can break the segment into.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.TextChunk">
            <summary>
            Information about a chunk of text from the pattern.  The chunk is a piece of text, with 
            cached information about the character spans within in.  Character spans separate out
            capitalized runs and lowercase runs.  i.e. if you have AAbb, then there will be two 
            character spans, one for AA and one for BB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.TextChunk.PatternHumps">
            <summary>
            Character spans separate out
            capitalized runs and lowercase runs.  i.e. if you have AAbb, then there will be two 
            character spans, one for AA and one for BB.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PatternMatching.PatternMatcher.SimplePatternMatcher.AddMatches(System.String,Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{Microsoft.CodeAnalysis.PatternMatching.PatternMatch})">
            <summary>
            Determines if a given candidate string matches under a multiple word query text, as you
            would find in features like Navigate To.
            </summary>
            <returns>If this was a match, a set of match types that occurred while matching the
            patterns. If it was not a match, it returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.IsCaseSensitive">
            <summary>
            True if this was a case sensitive match.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.Kind">
            <summary>
            The type of match that occurred.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PatternMatching.PatternMatch.MatchedSpans">
            <summary>
            The spans in the original text that were matched.  Only returned if the 
            pattern matcher is asked to collect these spans.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind">
            <summary>
            Note(cyrusn): this enum is ordered from strongest match type to weakest match type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Exact">
            <summary>
            The candidate string matched the pattern exactly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Prefix">
            <summary>
            The pattern was a prefix of the candidate string.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Substring">
            <summary>
            The pattern was a substring of the candidate string, but in a way that wasn't a CamelCase match.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseExact">
            <summary>
            All camel-humps in the pattern matched a camel-hump in the candidate.  All camel-humps
            in the candidate were matched by a camel-hump in the pattern.
            
            Example: "CFPS" matching "CodeFixProviderService"
            Example: "cfps" matching "CodeFixProviderService"
            Example: "CoFiPrSe" matching "CodeFixProviderService"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCasePrefix">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern matched the first camel-hump in the candidate.  There was no gap in the camel-
             humps in the candidate that were matched.
            
             Example: "CFP" matching "CodeFixProviderService"
             Example: "cfp" matching "CodeFixProviderService"
             Example: "CoFiPRo" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseNonContiguousPrefix">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern matched the first camel-hump in the candidate.  There was at least one gap in 
             the camel-humps in the candidate that were matched.
            
             Example: "CP" matching "CodeFixProviderService"
             Example: "cp" matching "CodeFixProviderService"
             Example: "CoProv" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseSubstring">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern did not match the first camel-hump in the pattern.  There was no gap in the camel-
             humps in the candidate that were matched.
            
             Example: "FP" matching "CodeFixProviderService"
             Example: "fp" matching "CodeFixProviderService"
             Example: "FixPro" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.CamelCaseNonContiguousSubstring">
             <summary>
             All camel-humps in the pattern matched a camel-hump in the candidate.  The first camel-hump
             in the pattern did not match the first camel-hump in the pattern.  There was at least one gap in 
             the camel-humps in the candidate that were matched.
            
             Example: "FS" matching "CodeFixProviderService"
             Example: "fs" matching "CodeFixProviderService"
             Example: "FixSer" matching "CodeFixProviderService"
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind.Fuzzy">
            <summary>
            The pattern matches the candidate in a fuzzy manner.  Fuzzy matching allows for 
            a certain amount of misspellings, missing words, etc. See <see cref="T:Roslyn.Utilities.SpellChecker"/> for 
            more details.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationServiceRunner`1.GetTypeSymbols(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.String,System.Int32,System.Int32)">
            <summary>
            Tries to get a type of its' <paramref name="ordinalInLambda"/> lambda parameter of <paramref name="ordinalInInvocation"/> argument for each candidate symbol.
            </summary>
            <param name="candidateSymbols">symbols corresponding to <see cref="T:System.Linq.Expressions.Expression`1"/> or <see cref="T:System.Func`2"/>
            Here, some_args can be multi-variables lambdas as well, e.g. f((a,b) => a+b, (a,b,c)=>a*b*c.Length)
            </param>
            <param name="ordinalInInvocation">ordinal of the arguments of function: (a,b) or (a,b,c) in the example above</param>
            <param name="ordinalInLambda">ordinal of the lambda parameters, e.g. a, b or c.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationServiceRunner`1.SuppressDefaultTupleElements(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            If container is a tuple type, any of its tuple element which has a friendly name will cause
            the suppression of the corresponding default name (ItemN).
            In that case, Rest is also removed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Recommendations.Recommender.GetRecommendedSymbolsAtPosition(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Obsolete.  Use <see cref="M:Microsoft.CodeAnalysis.Recommendations.Recommender.GetRecommendedSymbolsAtPositionAsync(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.DefaultRemoteHostClientServiceFactory">
            <summary>
            Default implementation of IRemoteHostClientService
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.IRemoteHostClientFactory">
            <summary>
            Create new <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/>.
            
            <see cref="T:Microsoft.CodeAnalysis.Remote.IRemoteHostClientFactory"/> will use this to create new <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/> 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.IRemoteHostClientService">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/> that a user can use to communicate with a remote host (i.e. ServiceHub) 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostClientService.RequestNewRemoteHostAsync(System.Threading.CancellationToken)">
            <summary>
            Request new remote host. 
            
            this is designed to be not disruptive to existing callers and to support scenarios where
            features required to reload user extension dlls without re-launching VS.
            
            if someone requests new remote host, all new callers for <see cref="M:Microsoft.CodeAnalysis.Remote.IRemoteHostClientService.TryGetRemoteHostClientAsync(System.Threading.CancellationToken)"/> will
            receive a new remote host client that connects to a new remote host.
            
            existing remoteHostClient will still remain connected to old host and that old host will eventually go away once all existing clients
            are done with their requests.
            
            callers can subscribe to <see cref="E:Microsoft.CodeAnalysis.Remote.RemoteHostClient.StatusChanged"/> event to see whether client is going away if
            caller is designed to hold onto a service for a while to react to remote host change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostClientService.TryGetRemoteHostClientAsync(System.Threading.CancellationToken)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient"/> to current RemoteHost
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostService.SetLoggingFunctionIds(System.Collections.Generic.List{System.String},System.Collections.Generic.List{System.String},System.Threading.CancellationToken)">
            <summary>
            This is only for debugging
            
            this lets remote side to set same logging options as VS side
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostService.OnGlobalOperationStarted(System.String)">
            <remarks>
            JsonRPC seems to have a problem with empty parameter lists.  So passing a dummy parameter
            just to make it work properly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.IRemoteHostService.SynchronizePrimaryWorkspaceAsync(Microsoft.CodeAnalysis.Checksum,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Synchronize data to OOP proactively without anyone asking for it to make most of operation
            faster
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient">
            <summary>
            This represents client in client/servier model.
            
            user can create a connection to communicate with the server (remote host) through this client
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Remote.RemoteHostClient.ClientId">
            <summary>
            Return an unique string per client.
            
            one can use this to distinguish different clients that are connected to different RemoteHosts including
            cases where 2 external process finding each others
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryCreateConnectionAsync(System.String,System.Object,System.Threading.CancellationToken)">
            <summary>
            Create <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient.Connection"/> for the <paramref name="serviceName"/> if possible.
            otherwise, return null.
            
            Creating session could fail if remote host is not available. one of example will be user killing
            remote host.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryCreateSessionAsync(System.String,Microsoft.CodeAnalysis.Solution,System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Remote.SessionWithSolution"/> for the <paramref name="serviceName"/> if possible, otherwise returns <see langword="null"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClient.TryCreateKeepAliveSessionAsync(System.String,System.Object,System.Threading.CancellationToken)">
            <summary>
            Creates <see cref="T:Microsoft.CodeAnalysis.Remote.KeepAliveSession"/> for the <paramref name="serviceName"/>, otherwise returns <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient.NoOpClient">
            <summary>
            NoOpClient is used if a user killed our remote host process. Basically this client never
            create a session
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient.Connection">
            <summary>
            This is a connection between client and server. user can use this to communicate with remote host.
            
            This doesn't know anything specific to Roslyn. this is general pure connection between client and server.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions.SynchronizePrimaryWorkspaceAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Synchronize given solution as primary workspace solution in remote host
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.SessionWithSolution">
            <summary>
            This will tie <see cref="T:Microsoft.CodeAnalysis.Solution"/> and <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient.Connection"/>'s lifetime together
            so that one can handle those more easily
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Remote.KeepAliveSession">
            <summary>
            This will let one to hold onto <see cref="T:Microsoft.CodeAnalysis.Remote.RemoteHostClient.Connection"/> for a while.
            this helper will let you not care about remote host being gone while you hold onto the connection if that ever happen
            
            when this is used, solution must be explicitly passed around between client (VS) and remote host (OOP)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation">
            <summary>
            This annotation will be used by rename to mark all places where it needs to rename an identifier (token replacement) and where to 
            check if the semantics have been changes (conflict detection).
            </summary>
            <remarks>This annotation should be put on tokens only.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.OriginalSpan">
            <summary>
            The span this token occupied in the original syntax tree. Can be used to show e.g. conflicts in the UI.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsRenameLocation">
            <summary>
            A flag indicating whether this is a location that needs to be renamed or just tracked for conflicts.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsOriginalTextLocation">
            <summary>
            A flag indicating whether the token at this location has the same ValueText then the original name 
            of the symbol that gets renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Prefix">
            <summary>
            When replacing the annotated token this string will be prepended to the token's value. This is used when renaming compiler 
            generated fields and methods backing properties (e.g. "get_X" or "_X" for property "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.Suffix">
            <summary>
            When replacing the annotated token this string will be appended to the token's value. This is used when renaming compiler 
            generated types whose names are derived from user given names (e.g. "XEventHandler" for event "X").
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.RenameDeclarationLocationReferences">
            <summary>
            A single dimensional array of annotations to verify after rename.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsNamespaceDeclarationReference">
            <summary>
            States if this token is a Namespace Declaration Reference
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsMemberGroupReference">
            <summary>
            States if this token is a member group reference, typically found in NameOf expressions
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation.IsInvocationExpression">
            <summary>
            States if this token is annotated as a part of the Invocation Expression that needs to be checked for the Conflicts
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference">
            <summary>
            This class is used to refer to a Symbol definition which could be in source or metadata
            it has a metadata name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.Name">
            <summary>
            The metadata name for this symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.SymbolLocationsCount">
            <summary>
            Count of symbol location (Partial Types, Constructors, etc).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference.IsOverriddenFromMetadata">
            <summary>
            A flag indicating that the associated symbol is an override of a symbol from metadata
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker._currentIdentifiersInScope">
            <summary>
            The core data structure of the tracker. This is a dictionary of variable name to the
            current identifier tokens that are declaring variables. This should only ever be updated
            via the AddIdentifier and RemoveIdentifier helpers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution">
            <summary>
            The result of the conflict engine. Once this object is returned from the engine, it is
            immutable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.RelatedLocations">
            <summary>
            The list of all symbol locations that are referenced either by the original symbol or
            the renamed symbol. This includes both resolved and unresolved conflicts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.DocumentIds">
            <summary>
            The list of all document ids of documents that have been touched for this rename operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.NewSolution">
            <summary>
            The new workspace snapshot
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.OldSolution">
            <summary>
            The base workspace snapshot
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.ReplacementTextValid">
            <summary>
            Whether the text that was resolved with was even valid. This may be false if the
            identifier was not valid in some language that was involved in the rename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution.ReplacementText">
            <summary>
            The original text that is the rename replacement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.ResolveConflictsAsync(Microsoft.CodeAnalysis.Rename.RenameLocations,System.String,System.String,Microsoft.CodeAnalysis.Options.OptionSet,System.Func{System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol},System.Nullable{System.Boolean}},System.Threading.CancellationToken)">
            <summary>
            Performs the renaming of the symbol in the solution, identifies renaming conflicts and automatically resolves them where possible.
            </summary>
            <param name="renameLocationSet">The locations to perform the renaming at.</param>
            <param name="originalText">The original name of the identifier.</param>
            <param name="replacementText">The new name of the identifier</param>
            <param name="optionSet">The option for rename</param>
            <param name="hasConflict">Called after renaming references.  Can be used by callers to
            indicate if the new symbols that the reference binds to should be considered to be ok or
            are in conflict.  'true' means they are conflicts.  'false' means they are not conflicts.
            'null' means that the default conflict check should be used.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A conflict resolution containing the new solution.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.SymbolsForEnclosingInvocationExpressionWorker(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken)">
            <summary>
            Used to find the symbols associated with the Invocation Expression surrounding the Token
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.AddDeclarationConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId},Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Computes an adds conflicts relating to declarations, which are independent of
            location-based checks. Examples of these types of conflicts include renaming a member to
            the same name as another member of a type: binding doesn't change (at least from the
            perspective of find all references), but we still need to track it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.GetSymbolLocationAsync(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Gives the First Location for a given Symbol by ordering the locations using DocumentId first and Location starting position second
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session">
            <summary>
            Helper class to track the state necessary for finding/resolving conflicts in a 
            rename session.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.IdentifyConflictsAsync(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DocumentId},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution)">
            <summary>
            Find conflicts in the new solution 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.GetNodesOrTokensToCheckForConflicts(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets the list of the nodes that were annotated for a conflict check 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.FindDocumentsAndPossibleNameConflicts">
            <summary>
            The method determines the set of documents that need to be processed for Rename and also determines
             the possible set of names that need to be checked for conflicts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver.Session.ShouldIncludeLocation(System.Collections.Generic.ISet{Microsoft.CodeAnalysis.Rename.RenameLocation},Microsoft.CodeAnalysis.Rename.RenameLocation)">
            We try to rewrite all locations that are invalid candidate locations. If there is only
            one location it must be the correct one (the symbol is ambiguous to something else)
            and we always try to rewrite it.  If there are multiple locations, we only allow it
            if the candidate reason allows for it).
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation">
            <summary>
            Gives information about an identifier span that was affected by Rename (Reference or Non reference)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.NoConflict">
            <summary>
            There was no conflict. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedReferenceConflict">
            <summary>
            A conflict was resolved at a location that references the symbol being renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.ResolvedNonReferenceConflict">
            <summary>
            A conflict was resolved in a piece of code that does not reference the symbol being
            renamed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.PossiblyResolvableConflict">
            <summary>
            There was a conflict that could not be resolved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType.UnresolvableConflict">
            <summary>
            These are the conflicts that cannot be resolved. E.g.: Declaration Conflict
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker">
            <summary>
            Tracks the text spans that were modified as part of a rename operation
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker.ComplexifiedSpan">
            <summary>
            Information to track deltas of complexified spans
            
            Consider the following example where renaming a->b causes a conflict 
            and Goo is an extension method:
                "a.Goo(a)" is rewritten to "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The OriginalSpan is the span of "a.Goo(a)"
            
            The NewSpan is the span of "NS1.NS2.Goo(NS3.a, NS3.a)"
            
            The ModifiedSubSpans are the pairs of complexified symbols sorted 
            according to their order in the original source code span:
                "a", "NS3.a"
                "Goo", "NS1.NS2.Goo"
                "a", "NS3.a"
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.AnnotateAndRename(Microsoft.CodeAnalysis.Rename.RenameRewriterParameters)">
            <summary>
            This method annotates the given syntax tree with all the locations that need to be checked for conflict
            after the rename operation.  It also renames all the reference locations and expands any conflict locations.
            </summary>
            <param name="parameters">The options describing this rename operation</param>
            <returns>The root of the annotated tree.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.TryAddPossibleNameConflicts(Microsoft.CodeAnalysis.ISymbol,System.String,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Based on the kind of the symbol and the new name, this function determines possible conflicting names that
            should be tracked for semantic changes during rename.
            </summary>
            <param name="symbol">The symbol that gets renamed.</param>
            <param name="newName">The new name for the symbol.</param>
            <param name="possibleNameConflicts">List where possible conflicting names will be added to.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeDeclarationConflictsAsync(System.String,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId},Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution,System.Collections.Generic.IDictionary{Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.Location},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by the new declaration created during rename.
            </summary>
            <param name="replacementText">The replacementText as given from the user.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="referencedSymbols">All referenced symbols that are part of this rename session.</param>
            <param name="baseSolution">The original solution when rename started.</param>
            <param name="newSolution">The resulting solution after rename.</param>
            <param name="reverseMappedLocations">A mapping from new to old locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>All locations where conflicts were caused because the new declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputeImplicitReferenceConflictsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation},System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renameSymbol">The original symbol that got renamed.</param>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="implicitReferenceLocations">All implicit reference locations.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.ComputePossibleImplicitUsageConflicts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Location,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Identifies the conflicts caused by implicitly referencing the renamed symbol.
            </summary>
            <param name="renamedSymbol">The new symbol (after rename).</param>
            <param name="semanticModel">The SemanticModel of the document in the new solution containing the renamedSymbol</param>
            <param name="originalDeclarationLocation">The location of the renamedSymbol in the old solution</param>
            <param name="newDeclarationLocationStartingPosition">The starting position of the renamedSymbol in the new solution</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>A list of implicit conflicts.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.LocalVariableConflict(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ISymbol})">
            <summary>
            Identifies potential Conflicts into the inner scope locals. This may give false positives.
            </summary>
            <param name="token">The Token that may introduce errors else where</param>
            <param name="newReferencedSymbols">The symbols that this token binds to after the rename
            has been applied</param>
            <returns>Returns if there is a potential conflict</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.IsIdentifierValid(System.String,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService)">
            <summary>
            Used to find if the replacement Identifier is valid
            </summary>
            <param name="replacementText"></param>
            <param name="syntaxFactsService"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService.GetExpansionTargetForLocation(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets the top most enclosing statement as target to call MakeExplicit on.
            It's either the enclosing statement, or if this statement is inside of a lambda expression, the enclosing
            statement of this lambda.
            </summary>
            <param name="token">The token to get the complexification target for.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.BaseSymbol">
            <summary>
            mentions that the result is for the base symbol of the rename
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Rename.RenameEntityKind.OverloadedSymbols">
            <summary>
            mentions that the result is for the overloaded symbols of the rename
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Rename.RenameLocations">
            <summary>
            A helper class that contains some of the methods and filters that must be used when
            processing the raw results from the FindReferences API.
            </summary>
            <summary>
            Holds the Locations of a symbol that should be renamed, along with the symbol and Solution
            for the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocations.ReferenceProcessing.GetRenamableSymbolAsync(Microsoft.CodeAnalysis.Document,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a symbol in a document, returns the "right" symbol that should be renamed in
            the case the name binds to things like aliases _and_ the underlying type at once.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocations.ReferenceProcessing.FindDefinitionSymbolAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a symbol, finds the symbol that actually defines the name that we're using.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocations.ReferenceProcessing.GetRenamableDefinitionLocationsAsync(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Given a ISymbol, returns the renameable locations for a given symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameLocations.FindAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Find the locations that need to be renamed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Rename.RenameOptions.RenameFile">
            <summary>
            Set to true if the file name should match the type name after a rename operation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Rename.RenameUtilities.ShouldRenameOnlyAffectDeclaringProject(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Renaming a private symbol typically confines the set of references and potential
            conflicts to that symbols declaring project. However, rename may cascade to
            non-public symbols which may then require other projects be considered.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService">
            <summary>
            a service that provides a semantic model that will re-use last known compilation if
            semantic version hasn't changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Don't call this directly. use Document extension method GetSemanticModelForNodeAsync or GetSemanticModelForSpanAsync instead.
            
            see the descriptions on the extension methods
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1">
            <summary>
            An interval tree represents an ordered tree data structure to store intervals of the form 
            [start, end).  It allows you to efficiently find all intervals that intersect or overlap 
            a provided interval.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree`2.AddIntervalInPlace(`0)">
            <summary>
            Warning.  Mutates the tree in place.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions.GetEffectiveSeverity(Microsoft.CodeAnalysis.DiagnosticDescriptor,Microsoft.CodeAnalysis.CompilationOptions,System.Collections.Immutable.ImmutableDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Gets project-level effective severity of the given <paramref name="descriptor"/> accounting for severity configurations from both the following sources:
            1. Compilation options from ruleset file, if any, and command line options such as /nowarn, /warnaserror, etc.
            2. Analyzer config documents at the project root directory or in ancestor directories.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForSpanAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given span. 
            otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetSemanticModelForNodeAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            this will return either regular semantic model or speculative semantic based on context. 
            any feature that is involved in typing or run on UI thread should use this to take advantage of speculative semantic model 
            whenever possible automatically.
            
            when using this API, semantic model should only be used to ask node inside of the given node except ones that belong to 
            member signature. otherwise, it might throw if semantic model returned by this API is a speculative semantic model.
            
            also, symbols from the semantic model returned by this API might have out of date location information. 
            if exact location (not relative location) is needed from symbol, regular GetSemanticModel should be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions.GetPartialSemanticModelAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Returns the semantic model for this document that may be produced from partial semantics. The semantic model
            is only guaranteed to contain the syntax tree for <paramref name="document"/> and nothing else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions.GetMappedFilePathIfExist(Microsoft.CodeAnalysis.FileLinePositionSpan)">
            <summary>
            Get mapped file path if exist, otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.GetAllMethodSymbolsOfPartialParts(Microsoft.CodeAnalysis.IMethodSymbol)">
            <summary>
            Returns the methodSymbol and any partial parts.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions.HasEventHandlerSignature(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Returns true for void returning methods with two parameters, where
            the first parameter is of <see cref="T:System.Object"/> type and the second
            parameter inherits from or equals <see cref="T:System.EventArgs"/> type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions.GetOverridableMembers(Microsoft.CodeAnalysis.INamedTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the set of members in the inheritance chain of <paramref name="containingType"/> that
            are overridable.  The members will be returned in furthest-base type to closest-base
            type order.  i.e. the overridable members of <see cref="T:System.Object"/> will be at the start
            of the list, and the members of the direct parent type of <paramref name="containingType"/> 
            will be at the end of the list.
            
            If a member has already been overridden (in <paramref name="containingType"/> or any base type) 
            it will not be included in the list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions.GetAllTypes(Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.Threading.CancellationToken)">
            <summary>
            Lazily returns all nested types contained (recursively) within this namespace or type.
            In case of a type, it is included itself as the first result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions.FindNamespaces(Microsoft.CodeAnalysis.INamespaceSymbol,System.String,System.Threading.CancellationToken)">
            <summary>
            Searches the namespace for namespaces with the provided name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsUnsafe(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Returns true if this symbol contains anything unsafe within it.  for example
            List&lt;int*[]&gt; is unsafe, as it "int* Goo { get; }"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsInaccessibleLocal(Microsoft.CodeAnalysis.ISymbol,System.Int32)">
            <returns>
            Returns true if symbol is a local variable and its declaring syntax node is 
            after the current position, false otherwise (including for non-local symbols)
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsEditorBrowsable(Microsoft.CodeAnalysis.ISymbol,System.Boolean,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.IMethodSymbol,System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},System.Collections.Generic.List{Microsoft.CodeAnalysis.IMethodSymbol},Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Checks a given symbol for browsability based on its declaration location, attributes 
            explicitly limiting browsability, and whether showing of advanced members is enabled. 
            The optional attribute constructor parameters may be used to specify the symbols of the
            constructors of the various browsability limiting attributes because finding these 
            repeatedly over a large list of symbols can be slow. If providing these constructor 
            symbols, they should be in the format provided by 
            EditorBrowsableHelpers.GetSpecial*AttributeConstructor(). If these are not provided,
            they will be found in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAwaitableNonDynamic(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32)">
            <summary>
            If the <paramref name="symbol"/> is a method symbol, returns <see langword="true"/> if the method's return type is "awaitable", but not if it's <see langword="dynamic"/>.
            If the <paramref name="symbol"/> is a type symbol, returns <see langword="true"/> if that type is "awaitable".
            An "awaitable" is any type that exposes a GetAwaiter method which returns a valid "awaiter". This GetAwaiter method may be an instance method or an extension method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.FilterToVisibleAndBrowsableSymbols``1(System.Collections.Immutable.ImmutableArray{``0},System.Boolean,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            First, remove symbols from the set if they are overridden by other symbols in the set.
            If a symbol is overridden only by symbols outside of the set, then it is not removed. 
            This is useful for filtering out symbols that cannot be accessed in a given context due
            to the existence of overriding members. Second, remove remaining symbols that are
            unsupported (e.g. pointer types in VB) or not editor browsable based on the EditorBrowsable
            attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.IAssemblySymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsAccessibleWithin(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within name type 'within', with an optional
            qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessible(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within', with an qualifier of
            type "throughTypeOpt". Sets "failedThroughTypeCheck" to true if it failed the "through
            type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean@)">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a INamedTypeSymbol
            or an IAssemblySymbol.  If 'symbol' is accessed off of an expression then
            'throughTypeOpt' is the type of that expression. This is needed to properly do protected
            access checks. Sets "failedThroughTypeCheck" to true if this protected check failed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions.FindImplementationsForInterfaceMemberAsync(Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId{Microsoft.CodeAnalysis.ITypeSymbol},Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId,Microsoft.CodeAnalysis.Solution,System.Threading.CancellationToken)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken)">
            <summary>
            Gets semantic information, such as type, symbols, and diagnostics, about the parent of a token.
            </summary>
            <param name="semanticModel">The SemanticModel object to get semantic information
            from.</param>
            <param name="token">The token to get semantic information from. This must be part of the
            syntax tree associated with the binding.</param>
            <param name="cancellationToken">A cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions.GetType(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Fetches the ITypeSymbol that should be used if we were generating a parameter or local that would accept <paramref name="expression"/>. If
            expression is a type, that's returned; otherwise this will see if it's something like a method group and then choose an appropriate delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions.HasIntervalThatIntersectsWith(Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree{Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector},Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            check whether the given span is intersects with the tree
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.GetLeadingWhitespaceOfLineAtPosition(Microsoft.CodeAnalysis.Text.SourceText,System.Int32)">
            <summary>
            Returns the leading whitespace of the line located at the specified position in the given snapshot.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions.TryOverlapsHiddenPosition(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.Text.TextSpan,System.Func{System.Int32,System.Threading.CancellationToken,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Same as OverlapsHiddenPosition but doesn't throw on cancellation.  Instead, returns false
            in that case.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.NameFormat">
            <summary>
            Standard format for displaying to the user.
            </summary>
            <remarks>
            No return type.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats.SignatureFormat">
            <summary>
            Contains enough information to determine whether two symbols have the same signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyExpressionLevelSemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within the same
            expression context, then the document/semantic-model will be forked after each edit 
            so that further edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplyMethodBodySemanticEditsAsync``1(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Performs several edits to a document.  If multiple edits are made within a method
            body then the document/semantic-model will be forked after each edit so that further
            edits can see if they're still safe to apply.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions.ApplySemanticEditsAsync``2(Microsoft.CodeAnalysis.Editing.SyntaxEditor,Microsoft.CodeAnalysis.Document,System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.ValueTuple{``1,System.Collections.Generic.IEnumerable{``1}}},System.Func{Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SemanticModel,``0,``1,System.Boolean},System.Func{Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.SyntaxNode,``0,``1,Microsoft.CodeAnalysis.SyntaxNode},System.Threading.CancellationToken)">
            <summary>
            Helper function for fix-all fixes where individual fixes may affect the viability
            of another.  For example, consider the following code:
            
                if ((double)x == (double)y)
                
            In this code either cast can be removed, but at least one cast must remain.  Even
            though an analyzer marks both, a fixer must not remove both.  One way to accomplish
            this would be to have the fixer do a semantic check after each application.  However
            This is extremely expensive, especially for hte common cases where one fix does
            not affect each other.
            
            To address that, this helper groups fixes at certain boundary points.  i.e. at 
            statement boundaries.  If there is only one fix within the boundary, it does not
            do any semantic verification.  However, if there are multiple fixes in a boundary
            it will call into <paramref name="canReplace"/> to validate if the subsequent fix
            can be made or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.CreateGetHashCodeMethodStatements(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.ISymbol},System.Boolean)">
            <summary>
            Generates an override of <see cref="M:System.Object.GetHashCode"/> similar to the one
            generated for anonymous types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.SimpleLocalDeclarationStatement(Microsoft.CodeAnalysis.Editing.SyntaxGenerator,Microsoft.CodeAnalysis.INamedTypeSymbol,System.String,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            In VB it's more idiomatic to write things like <c>Dim t = TryCast(obj, SomeType)</c>
            instead of <c>Dim t As SomeType = TryCast(obj, SomeType)</c>, so we just elide the type
            from the decl.  For C# we don't want to do this though.  We want to always include the
            type and let the simplifier decide if it should be <c>var</c> or not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions.IsSpecialCaseBinaryExpression(Microsoft.CodeAnalysis.Operations.IBinaryOperation,Microsoft.CodeAnalysis.Operations.BinaryOperatorKind,System.Threading.CancellationToken)">
            <summary>
            Returns true if the binaryExpression consists of an expression that can never be negative, 
            such as length or unsigned numeric types, being compared to zero with greater than, 
            less than, or equals relational operator.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsChildNode``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if is a given token is a child token of a certain type of parent node.
            </summary>
            <typeparam name="TParent">The type of the parent node.</typeparam>
            <param name="node">The node that we are testing.</param>
            <param name="childGetter">A function that, when given the parent node, returns the child token we are interested in.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.IsFoundUnder``1(Microsoft.CodeAnalysis.SyntaxNode,System.Func{``0,Microsoft.CodeAnalysis.SyntaxNode})">
            <summary>
            Returns true if this node is found underneath the specified child in the given parent.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the tokens
            
            tokens should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.AddAnnotations(Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.Tuple{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxAnnotation}})">
            <summary>
            create a new root node from the given root after adding annotations to the nodes
            
            nodes should belong to the given root
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceNodesAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNode},System.Func{Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxNode}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of nodes from the existing tree with the specified old nodes replaced with a newly computed nodes.
            </summary>
            <param name="root">The root of the tree that contains all the specified nodes.</param>
            <param name="nodes">The nodes from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement node for
            the argument nodes. The first argument is one of the original specified nodes. The second argument is
            the same node possibly rewritten with replaced descendants.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.ReplaceTokensAsync``1(``0,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken},System.Func{Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Threading.CancellationToken,System.Threading.Tasks.Task{Microsoft.CodeAnalysis.SyntaxToken}},System.Threading.CancellationToken)">
            <summary>
            Creates a new tree of tokens from the existing tree with the specified old tokens replaced with a newly computed tokens.
            </summary>
            <param name="root">The root of the tree that contains all the specified tokens.</param>
            <param name="tokens">The tokens from the tree to be replaced.</param>
            <param name="computeReplacementAsync">A function that computes a replacement token for
            the argument tokens. The first argument is one of the originally specified tokens. The second argument is
            the same token possibly rewritten with replaced trivia.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenForward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenForward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.s_findSkippedTokenBackward">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindSkippedTokenBackward(Microsoft.CodeAnalysis.SyntaxTriviaList,System.Int32)">
            <summary>
            Look inside a trivia list for a skipped token that contains the given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxNode,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.GetTouchingWordAsync(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService,System.Threading.CancellationToken,System.Boolean)">
            <summary>
            Returns the identifier, keyword, contextual keyword or preprocessor keyword touching this
            position, or a token of Kind = None if the caret is not touching either.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnRightOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the right.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions.FindTokenOnLeftOfPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            If the position is inside of token, return that token; otherwise, return the token to the left.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this text document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAdditionalDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this additional document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.TextDocument,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this analyzer config document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespacePosition(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line, or null if 
            the line is empty or contains only whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.GetFirstNonWhitespaceOffset(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Returns the first non-whitespace position on the given line as an offset
            from the start of the line, or null if the line is empty or contains only
            whitespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions.IsEmptyOrWhitespace(Microsoft.CodeAnalysis.Text.TextLine)">
            <summary>
            Determines whether the specified line is empty or contains whitespace only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.ToNormalizedSpans(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            merge provided spans to each distinct group of spans in ascending order
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses the specified node or token and is contained within its trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions.IsAround(Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Returns true if the span encompasses a span between the specified nodes or tokens
            and is contained within trivia around them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that is
            empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified span.
            </summary>
            <param name="span">TextSpan contained by the span set.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Initializes a new instance of <see cref="T:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection"/> that contains the specified list of spans.
            </summary>
            <param name="spans">The spans to be added.</param>
            <remarks>
            <para>The list of spans will be sorted and normalized (overlapping and adjoining spans will be combined).</para>
            <para>This constructor runs in O(N log N) time, where N = spans.Count.</para></remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="spans"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Union(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the union of two span sets.
            </summary>
            <param name="left">
            The first span set.
            </param>
            <param name="right">
            The second span set.
            </param>
            <returns>
            The new span set that corresponds to the union of <paramref name="left"/> and <paramref name="right"/>.
            </returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException">Either <paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Overlap(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the overlap of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the overlap of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> or <paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Intersection(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the intersection of two span sets.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the intersection of <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>This operator runs in O(N+M) time where N = left.Count, M = right.Count.</remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Difference(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Finds the difference between two sets. The difference is defined as everything in the first span set that is not in the second span set.
            </summary>
            <param name="left">The first span set.</param>
            <param name="right">The second span set.</param>
            <returns>The new span set that corresponds to the difference between <paramref name="left"/> and <paramref name="right"/>.</returns>
            <remarks>
            Empty spans in the second set do not affect the first set at all. This method returns empty spans in the first set that are not contained by any set in
            the second set.
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="left"/> is null.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="right"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Equality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are the same. 
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.op_Inequality(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection,Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether two span sets are not the same.
            </summary>
            <param name="left">The first set.</param>
            <param name="right">The second set.</param>
            <returns><c>true</c> if the two sets are not equivalent, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set overlaps with another span set.
            </summary>
            <param name="set">The span set to test.</param>
            <returns><c>true</c> if the span sets overlap, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OverlapsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set overlaps with another span.
            </summary>
            <param name="span">The span to test.</param>
            <returns><c>true</c> if this span set overlaps with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection)">
            <summary>
            Determines whether this span set intersects with another span set.
            </summary>
            <param name="set">Set to test.</param>
            <returns><c>true</c> if the span sets intersect, otherwise <c>false</c>.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="set"/> is null.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.IntersectsWith(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Determines whether this span set intersects with another span.
            </summary>
            <returns><c>true</c> if this span set intersects with the given span, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.GetHashCode">
            <summary>
            Gets a unique hash code for the span set.
            </summary>
            <returns>A 32-bit hash code associated with the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.Equals(System.Object)">
            <summary>
            Determines whether this span set is the same as another object.
            </summary>
            <param name="obj">The object to test.</param>
            <returns><c>true</c> if the two objects are equal, otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.ToString">
            <summary>
            Provides a string representation of the set.
            </summary>
            <returns>The string representation of the set.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.#ctor(Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection.OrderedSpanList)">
            <summary>
            Private constructor for use when the span list is already normalized.
            </summary>
            <param name="normalizedSpans">An already normalized span list.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Options.RuntimeOptions">
            <summary>
            Options that aren't persisted. options here will be reset to default on new process.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener.DiagnosticAsyncToken">
            <summary>
            Stores the source information for an <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken"/> value.  Helpful when 
            tracking down tokens which aren't properly disposed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider">
            <summary>
            Return <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for the given featureName
            
            We have this abstraction so that we can have isolated listener/waiter in unit tests
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider.GetListener(System.String)">
            <summary>
            Get <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener"/> for given feature.
            same provider will return a singleton listener for same feature
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider">
            <summary>
            use <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider" /> in product code to get
            <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener" /> and use
            <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider" /> in test to get waiter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.s_enabled">
            <summary>
            indicate whether asynchronous listener is enabled or not.
            it is tri-state since we want to retrieve this value, if never explicitly set, from environment variable
            and then cache it.
            we read value from environment variable (RoslynWaiterEnabled) because we want team, that doesn't have
            access to Roslyn code (InternalVisibleTo), can use this listener/waiter framework as well. 
            those team can enable this without using <see cref="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.Enable(System.Boolean)" /> API
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider._enableDiagnosticTokens">
            <summary>
            indicate whether <see cref="P:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener.TrackActiveTokens"/> is enabled or not
            it is tri-state since we want to retrieve this value, if never explicitly set, from environment variable
            and then cache it.
            we read value from environment variable (RoslynWaiterDiagnosticTokenEnabled) because we want team, that doesn't have
            access to Roslyn code (InternalVisibleTo), can use this listener/waiter framework as well. 
            those team can enable this without using <see cref="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.EnableDiagnosticTokens(System.Boolean)" /> API
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.s_enableDiagnosticTokens">
            <summary>
            Provides a default value for <see cref="F:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider._enableDiagnosticTokens"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.EnableDiagnosticTokens(System.Boolean)">
            <summary>
            Enable or disable TrackActiveTokens for test
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.GetWaiter(System.String)">
            <summary>
            Get Waiters for listeners for test
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.WaitAllAsync(System.String[],System.Action)">
            <summary>
            Wait for all of the <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter"/> instances to finish their
            work.
            </summary>
            <remarks>
            This is a very handy method for debugging hangs in the unit test.  Set a break point in the 
            loop, dig into the waiters and see all of the active <see cref="T:Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken"/> values 
            representing the remaining work.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider.GetTokens">
            <summary>
            Get all saved DiagnosticAsyncToken to investigate tests failure easier
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter.CreateExpeditedWaitTask">
            <summary>
            Returns a task which completes when all asynchronous operations currently tracked by this waiter are
            completed. Asynchronous operations are expedited when possible, meaning artificial delays placed before
            asynchronous operations are shortened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource.Delay(System.TimeSpan,System.Threading.CancellationToken)">
            <summary>
            Creates a task that will complete after a time delay, but can be expedited if an operation is waiting for
            the task to complete.
            </summary>
            <param name="delay">The time to wait before completing the returned task, or <c>TimeSpan.FromMilliseconds(-1)</c> to wait indefinitely.</param>
            <param name="cancellationToken">A cancellation token to observe while waiting for the task to complete.</param>
            <returns><see langword="true"/> if the delay compeleted normally; otherwise, <see langword="false"/> if the delay completed due to a request to expedite the delay.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <para><paramref name="delay"/> represents a negative time interval other than <c>TimeSpan.FromMilliseconds(-1)</c>.</para>
            <para>-or-</para>
            <para>The <paramref name="delay"/> argument's <see cref="P:System.TimeSpan.TotalMilliseconds"/> property is greater than <see cref="F:System.Int32.MaxValue"/>.</para>
            </exception>
            <exception cref="T:System.OperationCanceledException">The delay has been canceled.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.#ctor(System.Int32,System.Double,System.Boolean)">
            <summary><![CDATA[
            1) n  = Number of items in the filter
            
            2) p = Probability of false positives, (a double between 0 and 1).
            
            3) m = Number of bits in the filter
            
            4) k = Number of hash functions
            
            m = ceil((n * log(p)) / log(1.0 / (pow(2.0, log(2.0)))))
            
            k = round(log(2.0) * m / n)
            ]]></summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter.ComputeHash(System.String,System.Int32)">
            <summary>
            Modification of the murmurhash2 algorithm.  Code is simpler because it operates over
            strings instead of byte arrays.  Because each string character is two bytes, it is known
            that the input will be an even number of bytes (though not necessarily a multiple of 4).
            
            This is needed over the normal 'string.GetHashCode()' because we need to be able to generate
            'k' different well distributed hashes for any given string s.  Also, we want to be able to
            generate these hashes without allocating any memory.  My ideal solution would be to use an
            MD5 hash.  However, there appears to be no way to do MD5 in .NET where you can:
            
            a) feed it individual values instead of a byte[]
            
            b) have the hash computed into a byte[] you provide instead of a newly allocated one
            
            Generating 'k' pieces of garbage on each insert and lookup seems very wasteful.  So,
            instead, we use murmur hash since it provides well distributed values, allows for a
            seed, and allocates no memory.
            
            Murmur hash is public domain.  Actual code is included below as reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.AppendPartialLeadingTriviaText(Microsoft.CodeAnalysis.SyntaxToken,System.Text.StringBuilder,System.Int32)">
            <summary>
            If the token1 is expected to be part of the leading trivia of the token2 then the trivia
            before the token1FullSpanEnd, which the fullspan end of the token1 should be ignored
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers.GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            this will create a span that includes its trailing trivia of its previous token and leading trivia of its next token
            for example, for code such as "class A { int ...", if given tokens are "A" and "{", this will return span [] of "class[ A { ]int ..."
            which included trailing trivia of "class" which is previous token of "A", and leading trivia of "int" which is next token of "{"
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment">
            <summary>
            A documentation comment derived from either source text or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.HadXmlParseError">
            <summary>
            True if an error occurred when parsing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FullXmlFragment">
            <summary>
            The full XML text of this tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExampleText">
            <summary>
            The text in the &lt;example&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.SummaryText">
            <summary>
            The text in the &lt;summary&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ReturnsText">
            <summary>
            The text in the &lt;returns&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.RemarksText">
            <summary>
            The text in the &lt;remarks&gt; tag. Null if no tag existed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ParameterNames">
            <summary>
            The names of items in &lt;param&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.TypeParameterNames">
            <summary>
            The names of items in &lt;typeparam&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.ExceptionTypes">
            <summary>
            The types of items in &lt;exception&gt; tags.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CompletionListCref">
            <summary>
            The item named in the &lt;completionlist&gt; tag's cref attribute.
            Null if the tag or cref attribute didn't exist.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.s_NewLineAsStringArray">
            <summary>
            Used for <see cref="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder.TrimEachLine(System.String)"/> method, to prevent new allocation of string
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.s_cacheLastXmlFragmentParse">
            <summary>
            Cache of the most recently parsed fragment and the resulting DocumentationComment
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.FromXmlFragment(System.String)">
            <summary>
            Parses and constructs a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment" /> from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentationComment instance.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder">
            <summary>
            Helper class for parsing XML doc comments. Encapsulates the state required during parsing.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.CommentBuilder.Parse(System.String)">
            <summary>
            Parse and construct a <see cref="T:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment" /> from the given fragment of XML.
            </summary>
            <param name="xml">The fragment of XML to parse.</param>
            <returns>A DocumentationComment instance.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetParameterText(System.String)">
            <summary>
            Returns the text for a given parameter, or null if no documentation was given for the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetTypeParameterText(System.String)">
            <summary>
            Returns the text for a given type parameter, or null if no documentation was given for the type parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.GetExceptionTexts(System.String)">
            <summary>
            Returns the texts for a given exception, or an empty <see cref="T:System.Collections.Immutable.ImmutableArray"/> if no documentation was given for the exception.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment.Empty">
            <summary>
            An empty comment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialEditorBrowsableAttributeConstructor(Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Finds the constructor which takes exactly one argument, which must be of type EditorBrowsableState.
            It does not require that the EditorBrowsableAttribute and EditorBrowsableState types be those
            shipped by Microsoft, but it does demand the types found follow the expected pattern. If at any
            point that pattern appears to be violated, return null to indicate that an appropriate constructor
            could not be found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers.GetSpecialTypeLibAttributeConstructorsWorker(Microsoft.CodeAnalysis.Compilation,System.String,System.String)">
            <summary>
            The TypeLib*Attribute classes that accept TypeLib*Flags with FHidden as an option all have two constructors,
            one accepting a TypeLib*Flags and the other a short. This methods gets those two constructor symbols for any
            of these attribute classes. It does not require that the either of these types be those shipped by Microsoft,
            but it does demand the types found follow the expected pattern. If at any point that pattern appears to be
            violated, return an empty enumerable to indicate that no appropriate constructors were found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities.GetNextEnumValue(Microsoft.CodeAnalysis.INamedTypeSymbol)">
            <summary>
            Determines, using heuristics, what the next likely value is in this enum.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.ExtensionOrderer.TestAccessor.CheckForCycles``2(System.Collections.Generic.IEnumerable{System.Lazy{``0,``1}})">
            <summary>
            Helper for checking whether cycles exist in the extension ordering.
            Throws <see cref="T:System.ArgumentException"/> if a cycle is detected.
            </summary>
            <exception cref="T:System.ArgumentException">A cycle was detected in the extension ordering.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities.Convert(System.Int64,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Helper as VB's CType doesn't work without arithmetic overflow.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1">
            <summary>
            Helper class to allow one to do simple regular expressions over a sequence of objects (as
            opposed to a sequence of characters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Repeat``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m*)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.OneOrMore``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0})">
            <summary>
            Matcher equivalent to (m+)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Choice``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1|m_2|...|m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Sequence``1(Microsoft.CodeAnalysis.Shared.Utilities.Matcher{``0}[])">
            <summary>
            Matcher equivalent to (m_1 ... m_n)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.Matcher.Single``1(System.Func{``0,System.Boolean},System.String)">
            <summary>
            Matcher that matches an element if the provide predicate returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean)">
            <summary>
            Transforms baseName into a name that does not conflict with any name in 'reservedNames'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniqueness(System.Collections.Immutable.ImmutableArray{System.String},System.Collections.Immutable.ImmutableArray{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Ensures that any 'names' is unique and does not collide with any other name.  Names that
            are marked as IsFixed can not be touched.  This does mean that if there are two names
            that are the same, and both are fixed that you will end up with non-unique names at the
            end.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator.EnsureUniquenessInPlace(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.String},Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{System.Boolean},System.Func{System.String,System.Boolean},System.Boolean)">
            <summary>
            Updates the names in <paramref name="names"/> to be unique.  A name at a particular
            index <c>i</c> will not be touched if <c>isFixed[i]</c> is <see langword="true"/>. All
            other names will not collide with any other in <paramref name="names"/> and will all
            return <see langword="true"/> for <c>canUse(name)</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.ProgressTracker">
            <summary>
            Utility class that can be used to track the progress of an operation in a threadsafe manner.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.StreamingProgressTracker">
            <summary>
            Utility class that can be used to track the progress of an operation in a threadsafe manner.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker.GetWordParts(System.String)">
            <summary>
            Breaks an identifier string into constituent parts.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer">
            <summary>
            Provides a way to test two symbols for equivalence.  While there are ways to ask for
            different sorts of equivalence, the following must hold for two symbols to be considered
            equivalent.
            
            1) The kinds of the two symbols must match.
            
            2) The names of the two symbols must match.
            
            3) The arity of the two symbols must match.
            
            4) If the symbols are methods or parameterized properties, then the signatures of the two
            symbols must match.
            
            5) Both symbols must be definitions or must be instantiations.  If they are instantiations,
            then they must be instantiated in the same manner.
            
            6) The containing symbols of the two symbols must be equivalent.
            
            Note: equivalence does not concern itself with whole symbols.  Two types are considered
            equivalent if the above hold, even if one type has different members than the other.  Note:
            type parameters, and signature parameters are not considered 'children' when comparing
            symbols.
            
            Options are provided to tweak the above slightly.  For example, by default, symbols are
            equivalent only if they come from the same assembly or different assemblies of the same simple name.
            However, one can ask if two symbols are equivalent even if their assemblies differ.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.Equals(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.ISymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Compares given symbols <paramref name="x"/> and <paramref name="y"/> for equivalence and populates <paramref name="equivalentTypesWithDifferingAssemblies"/>
            with equivalent non-nested named type key-value pairs that are contained in different assemblies.
            These equivalent named type key-value pairs represent possibly equivalent forwarded types, but this API doesn't perform any type forwarding equivalence checks. 
            </summary>
            <remarks>This API is only supported for <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.IgnoreAssembliesInstance"/>.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer.EquivalenceVisitor.HandleNamedTypesWorker(Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.INamedTypeSymbol,Microsoft.CodeAnalysis.INamedTypeSymbol})">
            <summary>
            Worker for comparing two named types for equivalence. Note: The two
            types must have the same TypeKind.
            </summary>
            <param name="x">The first type to compare</param>
            <param name="y">The second type to compare</param>
            <param name="equivalentTypesWithDifferingAssemblies">
            Map of equivalent non-nested types to be populated, such that each key-value pair of named types are equivalent but reside in different assemblies.
            This map is populated only if we are ignoring assemblies for symbol equivalence comparison, i.e. <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer._assemblyComparerOpt"/> is true.
            </param>
            <returns>True if the two types are equivalent.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser">
            <summary>
            An XML parser that is designed to parse small fragments of XML such as those that appear in documentation comments.
            PERF: We try to re-use the same underlying <see cref="T:System.Xml.XmlReader"/> to reduce the allocation costs of multiple parses.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.ParseFragment``1(System.String,System.Action{System.Xml.XmlReader,``0},``0)">
            <summary>
            Parse the given XML fragment. The given callback is executed until either the end of the fragment
            is reached or an exception occurs.
            </summary>
            <typeparam name="TArg">Type of an additional argument passed to the <paramref name="callback"/> delegate.</typeparam>
            <param name="xmlFragment">The fragment to parse.</param>
            <param name="callback">Action to execute while there is still more to read.</param>
            <param name="arg">Additional argument passed to the callback.</param>
            <remarks>
            It is important that the <paramref name="callback"/> action advances the <see cref="T:System.Xml.XmlReader"/>,
            otherwise parsing will never complete.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.Reader">
            <summary>
            A text reader over a synthesized XML stream consisting of a single root element followed by a potentially
            infinite stream of fragments. Each time "SetText" is called the stream is rewound to the element immediately
            following the synthetic root node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser.Reader._text">
            <summary>
            Current text to validate.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7">
            <summary>
            Helper class to analyze the semantic effects of a speculated syntax node replacement on the parenting nodes.
            Given an expression node from a syntax tree and a new expression from a different syntax tree,
            it replaces the expression with the new expression to create a speculated syntax tree.
            It uses the original tree's semantic model to create a speculative semantic model and verifies that
            the syntax replacement doesn't break the semantics of any parenting nodes of the original expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.#ctor(`0,`0,Microsoft.CodeAnalysis.SemanticModel,System.Threading.CancellationToken,System.Boolean,System.Boolean)">
            <summary>
            Creates a semantic analyzer for speculative syntax replacement.
            </summary>
            <param name="expression">Original expression to be replaced.</param>
            <param name="newExpression">New expression to replace the original expression.</param>
            <param name="semanticModel">Semantic model of <paramref name="expression"/> node's syntax tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <param name="skipVerificationForReplacedNode">
            True if semantic analysis should be skipped for the replaced node and performed starting from parent of the original and replaced nodes.
            This could be the case when custom verifications are required to be done by the caller or
            semantics of the replaced expression are different from the original expression.
            </param>
            <param name="failOnOverloadResolutionFailuresInOriginalCode">
            True if semantic analysis should fail when any of the invocation expression ancestors of <paramref name="expression"/> in original code has overload resolution failures.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression">
            <summary>
            Original expression to be replaced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression">
            <summary>
            First ancestor of <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> which is either a statement, attribute, constructor initializer,
            field initializer, default parameter initializer or type syntax node.
            It serves as the root node for all semantic analysis for this syntax replacement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalSemanticModel">
            <summary>
            Semantic model for the syntax tree corresponding to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression">
            <summary>
            Node which replaces the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/>.
            Note that this node is a cloned version of <see cref="F:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7._newExpressionForReplace"/> node, which has been re-parented
            under the node to be speculated, i.e. <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression">
            <summary>
            Node created by replacing <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> under <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression"/> node.
            This node is used as the argument to the GetSpeculativeSemanticModel API and serves as the root node for all
            semantic analysis of the speculated tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SpeculativeSemanticModel">
            <summary>
            Speculative semantic model used for analyzing the semantics of the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementChangesSemantics">
            <summary>
            Determines whether performing the given syntax replacement will change the semantics of any parenting expressions
            by performing a bottom up walk from the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfOriginalExpression"/>
            in the original tree and simultaneously walking bottom up from <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression"/> up to <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SemanticRootOfReplacedExpression"/>
            in the speculated syntax tree and performing appropriate semantic comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.SymbolsForOriginalAndReplacedNodesAreCompatible">
            <summary>
            Checks whether the semantic symbols for the <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.OriginalExpression"/> and <see cref="P:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacedExpression"/> are non-null and compatible.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.ReplacementBreaksSystemObjectMethodResolution(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if removing the cast could cause the semantics of System.Object method call to change.
            E.g. Dim b = CStr(1).GetType() is necessary, but the GetType method symbol info resolves to the same with or without the cast.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7.IsSymbolSystemObjectInstanceMethod(Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is a non-overridable, non static method on System.Object (e.g. GetType)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.AliasAnnotation">
            <summary>
            This annotation will be used by the expansion/reduction to annotate expanded syntax nodes to store the information that an 
            alias was used before expansion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation">
            <summary>
            When applied to a SyntaxNode, prevents the simplifier from converting a type to 'var'.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SimplificationOptions">
            <summary>
            Contains the options that needs to be drilled down to the Simplification Engine
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferAliasToQualification">
            <summary>
            This option tells the simplification engine if the Qualified Name should be replaced by Alias
            if the user had initially not used the Alias
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferOmittingModuleNamesInQualification">
            <summary>
            This option influences the name reduction of members of a module in VB. If set to true, the 
            name reducer will e.g. reduce Namespace.Module.Member to Namespace.Member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInference">
            <summary>
            This option says that if we should simplify the Generic Name which has the type argument inferred
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferImplicitTypeInLocalDeclaration">
            <summary>
            This option says if we should simplify the Explicit Type in Local Declarations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToGenericType">
            <summary>
            This option says if we should simplify to NonGeneric Name rather than GenericName
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.AllowSimplificationToBaseType">
            <summary>
            This option says if we should simplify from Derived types to Base types in Static Member Accesses
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyMemberAccessWithThisOrMe">
            <summary>
            This option says if we should simplify away the <see langword="this"/> or <see langword="Me"/> in member access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyFieldAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in field access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyPropertyAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in property access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyMethodAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in method access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.QualifyEventAccess">
            <summary>
            This option says if we should simplify away the <see langword="this"/>. or <see langword="Me"/>. in event access expressions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferIntrinsicPredefinedTypeKeywordInDeclaration">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Declarations
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.PreferIntrinsicPredefinedTypeKeywordInMemberAccess">
            <summary>
            This option says if we should prefer keyword for Intrinsic Predefined Types in Member Access Expression
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.SimplificationOptions.NamingPreferences">
            <summary>
            This option describes the naming rules that should be applied to specified categories of symbols, 
            and the level to which those rules should be enforced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.Simplifier">
            <summary>
            Expands and Reduces subtrees.
            
            Expansion:
                 1) Makes inferred names explicit (on anonymous types and tuples).
                 2) Replaces names with fully qualified dotted names.
                 3) Adds parentheses around expressions
                 4) Adds explicit casts/conversions where implicit conversions exist
                 5) Adds escaping to identifiers
                 6) Rewrites extension method invocations with explicit calls on the class containing the extension method.
                 
            Reduction:
                1) Shortens dotted names to their minimally qualified form
                2) Removes unnecessary parentheses
                3) Removes unnecessary casts/conversions
                4) Removes unnecessary escaping
                5) Rewrites explicit calls to extension methods to use dot notation
                6) Removes unnecessary tuple element names and anonymous type member names
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation">
            <summary>
            The annotation the reducer uses to identify sub trees to be reduced.
            The Expand operations add this annotation to nodes so that the Reduce operations later find them.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.SpecialTypeAnnotation">
            <summary>
            This is the annotation used by the simplifier and expander to identify Predefined type and preserving
            them from over simplification
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Simplification.Simplifier.AddImportsAnnotation">
            <summary>
            The annotation <see cref="M:Microsoft.CodeAnalysis.CodeActions.CodeAction.CleanupDocumentAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)"/> used to identify sub trees to look for symbol annotations on.
            It will then add import directives for these symbol annotations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync``1(``0,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand``1(``0,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ExpandAsync(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.Document,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.Expand(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.Workspace,System.Func{Microsoft.CodeAnalysis.SyntaxNode,System.Boolean},System.Threading.CancellationToken)">
            <summary>
            Expand qualifying parts of the specified subtree, annotating the parts using the <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> annotation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce all sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the document. The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.SyntaxAnnotation,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the subtrees identified with the specified <paramref name="annotation"/>.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Text.TextSpan,Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the specified span.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Simplification.Simplifier.ReduceAsync(Microsoft.CodeAnalysis.Document,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextSpan},Microsoft.CodeAnalysis.Options.OptionSet,System.Threading.CancellationToken)">
            <summary>
            Reduce the sub-trees annotated with <see cref="P:Microsoft.CodeAnalysis.Simplification.Simplifier.Annotation" /> found within the specified spans.
            The annotated node and all child nodes will be reduced.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Simplification.SymbolAnnotation">
            <summary>
            An annotation that holds onto information about a type or namespace symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer.DocumentResetAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Resets all the document state cached by the analyzer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService">
            <summary>
            Register a solution crawler for a particular workspace
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionCrawler.NullSolutionCrawlerRegistrationService">
            <summary>
            null implementation of the service. it doesn't do anything since there is no way to observe
            its impact in this layer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptions.BackgroundAnalysisScopeOption">
            <summary>
            Option to turn configure background analysis scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptions.ClosedFileDiagnostic">
            <summary>
            This option is used by TypeScript and F#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionCrawler.SolutionCrawlerOptions.LowMemoryForcedMinimalBackgroundAnalysis">
            <summary>
            Enables forced <see cref="F:Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope.Minimal"/> scope when low VM is detected to improve performance.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker">
            <summary>
            Track approximate solution size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionSize.SolutionSizeTracker.GetSolutionSize(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Get approximate solution size at the point of call.
            
            This API is not supposed to return 100% accurate size. 
            
            if a feature require 100% accurate size, use Solution to calculate it. this API is supposed to
            lazy and very cheap on answering that question.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService">
            <summary>
            A service that enables storing and retrieving of information associated with solutions,
            projects or documents across runtime sessions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService._lock">
            <summary>
            This lock guards all mutable fields in this type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService.PersistentStorageReferenceCountedDisposableWrapper">
            <summary>
            A trivial wrapper that we can hand out for instances from the <see cref="T:Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService"/>
            that wraps the underlying <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> singleton.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Storage.StorageOptions.SolutionSizeThreshold">
            <summary>
            Solution size threshold to start to use a DB (Default: 50MB)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement">
             <summary>
             Simple wrapper struct for a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> that helps ensure that the statement
             is always <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/> after it is used.
             
             See https://sqlite.org/c3ref/stmt.html:
             The life-cycle of a prepared statement object usually goes like this:
                1) Create the prepared statement object using sqlite3_prepare_v2().
                2) Bind values to parameters using the sqlite3_bind_* () interfaces.
                3) Run the SQL by calling sqlite3_step() one or more times.
                4) Reset the prepared statement using sqlite3_reset() then go back to step 2. Do this zero or more times.
                5) Destroy the object using sqlite3_finalize().
            
             This type helps ensure that '4' happens properly by clients executing statement.
             Note that destroying/finalizing a statement is not the responsibility of a client
             as it will happen to all prepared statemnets when the <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/> is
             <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Close_OnlyForUseBySqlConnection"/>d.
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection">
            <summary>
            Encapsulates a connection to a sqlite database.  On construction an attempt will be made
            to open the DB if it exists, or create it if it does not.
            
            Connections are considered relatively heavyweight and are pooled until the <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage"/>
            is <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Dispose"/>d.  Connections can be used by different threads,
            but only as long as they are used by one thread at a time.  They are not safe for concurrent
            use by several threads.
            
            <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be created through the user of <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.GetResettableStatement(System.String)"/>.
            These statements are cached for the lifetime of the connection and are only finalized
            (i.e. destroyed) when the connection is closed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._handle">
            <summary>
            The raw handle to the underlying DB.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._faultInjector">
            <summary>
            For testing purposes to simulate failures during testing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection._queryToStatement">
            <summary>
            Our cache of prepared statements for given sql strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.IsInTransaction">
            <summary>
            Whether or not we're in a transaction.  We currently don't supported nested transactions.
            If we want that, we can achieve it through sqlite "save points".  However, that's adds a 
            lot of complexity that is nice to avoid.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement">
            <summary>
            Represents a prepared sqlite statement.  <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement"/>s can be 
            <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Step(System.Boolean)"/>ed (i.e. executed).  Executing a statement can result in 
            either <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.DONE"/> if the command completed and produced no
            value, or <see cref="F:Microsoft.CodeAnalysis.SQLite.Interop.Result.ROW"/> if it evaluated out to a sql row that can
            then be queried.
            
            If a statement is parameterized then parameters can be provided by the 
            BindXXX overloads.  Bind is 1-based (to match sqlite).  
            
            When done executing a statement, the statement should be <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlStatement.Reset"/>.
            The easiest way to ensure this is to just use a 'using' statement along with
            a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.ResettableSqlStatement"/>.  By resetting the statement, it can
            then be used in the future with new bound parameters.
            
            Finalization/destruction of the underlying raw sqlite statement is handled
            by <see cref="M:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection.Close_OnlyForUseBySqlPersistentStorage"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage">
            <summary>
            Implementation of an <see cref="T:Microsoft.CodeAnalysis.Host.IPersistentStorage"/> backed by SQLite.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3">
            <summary>
            Abstracts out access to specific tables in the DB.  This allows us to share overall
            logic around cancellation/pooling/error-handling/etc, while still hitting different
            db tables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWrites">
            <summary>
            Queue of actions we want to perform all at once against the DB in a single transaction.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3._writeQueueKeyToWriteTask">
            <summary>
            The task responsible for writing out all the batched actions we have for a particular
            queue.  When new reads come in for that queue they can 'await' this write-task completing
            so that all reads for the queue observe any previously completed writes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.StringInfoTableName">
            <summary>
            Inside the DB we have a table dedicated to storing strings that also provides a unique 
            integral ID per string.  This allows us to store data keyed in a much more efficient
            manner as we can use those IDs instead of duplicating strings all over the place.  For
            example, there may be many pieces of data associated with a file.  We don't want to 
            key off the file path in all these places as that would cause a large amount of bloat.
            
            Because the string table can map from arbitrary strings to unique IDs, it can also be
            used to create IDs for compound objects.  For example, given the IDs for the FilePath
            and Name of a Project, we can get an ID that represents the project itself by just
            creating a compound key of those two IDs.  This ID can then be used in other compound
            situations.  For example, a Document's ID is creating by compounding its Project's 
            ID, along with the IDs for the Document's FilePath and Name.
            
            The format of the table is:
            
             StringInfo
             --------------------------------------------------------------
             | Id (integer, primary key, auto increment) | Data (varchar) |
             --------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName">
            <summary>
            Inside the DB we have a table for data corresponding to the <see cref="T:Microsoft.CodeAnalysis.Solution"/>.  The 
            data is just a blob that is keyed by a string Id.  Data with this ID can be retrieved
            or overwritten.
            
            The format of the table is:
            
             SolutionData
             -------------------------------------------------------------------
             | DataId (primary key, varchar) | | Checksum (blob) | Data (blob) |
             -------------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Project"/>.
            The data is keyed off of an integral value produced by combining the ID of the Project and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Project,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             ProjectData
             -------------------------------------------------------------------
             | DataId (primary key, integer) | | Checksum (blob) | Data (blob) |
             -------------------------------------------------------------------
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName">
            <summary>
            Inside the DB we have a table for data that we want associated with a <see cref="T:Microsoft.CodeAnalysis.Document"/>.
            The data is keyed off of an integral value produced by combining the ID of the Document and
            the ID of the name of the data (see <see cref="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ReadStreamAsync(Microsoft.CodeAnalysis.Document,System.String,Microsoft.CodeAnalysis.Checksum,System.Threading.CancellationToken)"/>.
            
            This gives a very efficient integral key, and means that the we only have to store a 
            single mapping from stream name to ID in the string table.
            
            The format of the table is:
            
             DocumentData
             -------------------------------------------------------------------
             | DataId (primary key, integer) | | Checksum (blob) | Data (blob) |
             -------------------------------------------------------------------
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.GetPooledConnection">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection"/> from the connection pool, or creates one if none are available.
            </summary>
            <remarks>
            Database connections have a large amount of overhead, and should be returned to the pool when they are no
            longer in use. In particular, make sure to avoid letting a connection lease cross an <see langword="await"/>
            boundary, as it will prevent code in the asynchronous operation from using the existing connection.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateIds(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Solution,System.Boolean)">
            <remarks>
            We have a lot of ID information to put into the DB. IDs for all strings we intend to 
            intern, as well as compound IDs for our projects and documents. Inserting these 
            individually is far too slow as SQLite will lock the DB for each insert and will have
            to do all the journalling work to ensure ACID semantics.  To avoid that, we attempt
            to precompute all the information we'd need to put in the ID tables and perform it
            all at once per project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.BulkPopulateProjectIdsWorker(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project)">
            <summary>
            Returns 'true' if the bulk population succeeds, or false if it doesn't.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._documentIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a document, to the ID we use in the DB for the document.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetDocumentDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Document,System.String,System.Int64@)">
            <summary>
            Given a document, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the DocumentData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.DocumentDataTableName"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.FlushAllDelayMS">
            <summary>
            Amount of time to wait between flushing writes to disk.  500ms means we can flush
            writes to disk two times a second.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrayLength">
            <summary>
            We use a pool to cache reads/writes that are less than 4k.  Testing with Roslyn,
            99% of all writes (48.5k out of 49.5k) are less than that size.  So this helps
            ensure that we can pool as much as possible, without caching excessively large 
            arrays (for example, Roslyn does write out nearly 50 chunks that are larger than
            100k each).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.MaxPooledByteArrays">
            <summary>
            The max amount of byte[]s we cache.  This caps our cache at 4MB while allowing
            us to massively speed up writing (by batching writes).  Because we can write to
            disk two times a second.  That means a total of 8MB/s that can be written to disk
            using only our cache.  Given that Roslyn itself only writes about 50MB to disk
            after several minutes of analysis, this amount of bandwidth is more than sufficient.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._projectIdToIdMap">
            <summary>
            Mapping from the workspace's ID for a project, to the ID we use in the DB for the project.
            Kept locally so we don't have to hit the DB for the common case of trying to determine the 
            DB id for a project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.TryGetProjectDataId(Microsoft.CodeAnalysis.SQLite.Interop.SqlConnection,Microsoft.CodeAnalysis.Project,System.String,System.Int64@)">
            <summary>
            Given a project, and the name of a stream to read/write, gets the integral DB ID to 
            use to find the data inside the ProjectData table.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.ProjectDataTableName"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionAccessor">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.Accessor`3"/> responsible for storing and 
            retrieving data from <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage.SolutionDataTableName"/>.  Note that with the Solution 
            table there is no need for key->id translation.  i.e. the key acts as the ID itself.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._writeQueueGate">
            <summary>
            Lock protecting the write queues and <see cref="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SQLite.SQLitePersistentStorage._flushAllTask">
            <summary>
            Task kicked off to actually do the work of flushing all data to the DB.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKey">
            <summary>
            <para>
            A <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> is a lightweight identifier for a symbol that can be used to 
            resolve the "same" symbol across compilations.  Different symbols have different concepts 
            of "same-ness". Same-ness is recursively defined as follows:
            <list type="number">
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IArrayTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.ElementType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.IArrayTypeSymbol.Rank"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/>s are the "same" if 
                    they have equal <see cref="P:Microsoft.CodeAnalysis.IAssemblySymbol.Identity"/>.Name</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IEventSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.Arity"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>, and have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    equal <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingAssembly"/>.
                    <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/> is not used because module identity is not important in practice.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>,
                    equal <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.Arity"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.INamedTypeSymbol.TypeArguments"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.
                If the <see cref="T:Microsoft.CodeAnalysis.INamespaceSymbol"/> is the global namespace for a
                compilation, then it will only match another
                global namespace of another compilation.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IParameterSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    equal <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPointerTypeSymbol"/>s are the "same" if they have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IPointerTypeSymbol.PointedAtType"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/>s are the "same" if they have 
                    the "same" the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingType"/>, 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>, and have 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.Type"/>s and  
                    the "same" <see cref="P:Microsoft.CodeAnalysis.IParameterSymbol.RefKind"/>s.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.ITypeParameterSymbol"/> are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
              <item>Two <see cref="T:Microsoft.CodeAnalysis.IFieldSymbol"/>s are the "same" if they have
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.ContainingSymbol"/> and 
                    the "same" <see cref="P:Microsoft.CodeAnalysis.ISymbol.MetadataName"/>.</item>
            </list>
            </para>
            <para>
                Due to issues arising from errors and ambiguity, it's possible for a SymbolKey to resolve to
                multiple symbols. For example, in the following type:
                <code>
                class C
                {
                   int M();
                   bool M();
                }
                </code>
                The SymbolKey for both 'M' methods will be the same.  The SymbolKey will then resolve to both methods.
            </para>
            <para>
            <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s are not guaranteed to work across different versions of Roslyn.
            They can be persisted in their <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/> form and used across sessions with
            the same version of Roslyn. However, future versions may change the encoded format and may
            no longer be able to <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Boolean,System.Threading.CancellationToken)"/> previous
            keys.  As such, only persist if using for a cache that can be regenerated if necessary.
            </para>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKey.AnonymousFunctionOrDelegateSymbolKey">
            <summary>
            Anonymous functions and anonymous-delegates (the special VB synthesized delegate types),
            only come into existence when someone has explicitly written a lambda in their source 
            code. So to appropriately round-trip this symbol we store the location that the lambda
            was at so that we can find the symbol again when we resolve the key.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SymbolKey.FormatVersion">
            <summary>
            Current format version.  Any time we change anything about our format, we should
            change this.  This will help us detect and reject any cases where a person serializes
            out a SymbolKey from a previous version of Roslyn and then attempt to use it in a 
            newer version where the encoding has changed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.#ctor(System.String)">
            <summary>
            Constructs a new <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> using the result of a previous call to
            <see cref="M:Microsoft.CodeAnalysis.SymbolKey.ToString"/> from this same session.  Instantiating with a string 
            from any other source is not supported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Create(Microsoft.CodeAnalysis.ISymbol,System.Threading.CancellationToken)">
            <summary>
            Constructs a new <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> representing the provided <paramref name="symbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.GetComparer(System.Boolean,System.Boolean)">
            <summary>
            Returns an <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> that determines if two <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/>s
            represent the same effective symbol.
            </summary>
            <param name="ignoreCase">Whether or not casing should be considered when comparing keys. 
            For example, with <c>ignoreCase=true</c> then <c>X.SomeClass</c> and <c>X.Someclass</c> would be 
            considered the same effective symbol</param>
            <param name="ignoreAssemblyKeys">Whether or not the originating assembly of referenced
            symbols should be compared when determining if two symbols are effectively the same.
            For example, with <c>ignoreAssemblyKeys=true</c> then an <c>X.SomeClass</c> from assembly 
            <c>A</c> and <c>X.SomeClass</c> from assembly <c>B</c> will be considered the same
            effective symbol.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Tries to resolve this <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> in the given 
            <paramref name="compilation"/> to a matching symbol.  <paramref name="resolveLocations"/>
            should only be given <see langword="true"/> if the symbol was produced from a compilation
            that has the exact same source as the compilation we're resolving against.  Otherwise
            the locations resolved may not actually be correct in the final compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.ToString">
            <summary>
            Returns this <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> encoded as a string.  This can be persisted
            and used later with <see cref="M:Microsoft.CodeAnalysis.SymbolKey.#ctor(System.String)"/> to then try to resolve back
            to the corresponding <see cref="T:Microsoft.CodeAnalysis.ISymbol"/> in a future <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            
            This string form is not guaranteed to be reusable across all future versions of 
            Roslyn.  As such it should only be used for caching data, with the knowledge that
            the data may need to be recomputed if the cached data can no longer be used.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyReader.ReadSymbolKeyArray``1">
            <summary>
            Reads an array of symbols out from the key.  Note: the number of symbols returned 
            will either be the same as the original amount written, or <c>default</c> will be 
            returned. It will never be less or more.  <c>default</c> will be returned if any 
            elements could not be resolved to the requested <typeparamref name="TSymbol"/> type 
            in the provided <see cref="P:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyReader.Compilation"/>.
            
            Callers should <see cref="M:System.IDisposable.Dispose"/> the instance returned.  No check is
            necessary if <c>default</c> was returned before calling <see cref="M:System.IDisposable.Dispose"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolKey.SymbolKeyWriter.WriteSymbolKeyArray``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Writes out the provided symbols to the key.  The array provided must not
            be <c>default</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolKeyResolution">
            <summary>
            The result of <see cref="M:Microsoft.CodeAnalysis.SymbolKey.Resolve(Microsoft.CodeAnalysis.Compilation,System.Boolean,System.Boolean,System.Threading.CancellationToken)"/>.
            If the <see cref="T:Microsoft.CodeAnalysis.SymbolKey"/> could be uniquely mapped to a single <see cref="T:Microsoft.CodeAnalysis.ISymbol"/>
            then that will be returned in <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.Symbol"/>.  Otherwise, if 
            the key resolves to multiple symbols (which can happen in error scenarios), then 
            <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateSymbols"/> and <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateReason"/> will be returned.
            
            If no symbol can be found <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.Symbol"/> will be <c>null</c> and <see cref="P:Microsoft.CodeAnalysis.SymbolKeyResolution.CandidateSymbols"/>
            will be empty.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchLogService">
            <summary>
            Used so we can mock out logging in unit tests.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindPackagesWithTypeAsync(System.String,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches for packages that contain a type with the provided name and arity.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            They can use or ignore the arity depending on their capabilities. 
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindPackagesWithAssemblyAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Searches for packages that contain an assembly with the provided name.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService.FindReferenceAssembliesWithTypeAsync(System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Searches for reference assemblies that contain a type with the provided name and arity.
            Note: Implementations are free to return the results they feel best for the
            given data.  Specifically, they can do exact or fuzzy matching on the name.
            They can use or ignore the arity depending on their capabilities. 
            
            Implementations should return results in order from best to worst (from their
            perspective).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchUpdateEngine">
            <summary>
            Service that allows you to query the SymbolSearch database and which keeps 
            the database up to date.  
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationProvider">
            <summary>
            A class used to provide XML documentation to the compiler for members from metadata from an XML document source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.GetSourceStream(System.Threading.CancellationToken)">
            <summary>
            Gets the source stream for the XML document.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.CreateFromBytes(System.Byte[])">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/> from bytes representing XML documentation data.
            </summary>
            <param name="xmlDocCommentBytes">The XML document bytes.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.XmlDocumentationProvider.CreateFromFile(System.String)">
            <summary>
            Creates an <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/> from an XML documentation file.
            </summary>
            <param name="xmlDocCommentFilePath">The path to the XML file.</param>
            <returns>An <see cref="T:Microsoft.CodeAnalysis.XmlDocumentationProvider"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.XmlDocumentationProvider.NullXmlDocumentationProvider">
            <summary>
            A trivial XmlDocumentationProvider which never returns documentation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Utilities.ParameterName.NameBasedOnArgument">
            <summary>
            The name the underlying naming system came up with based on the argument itself.
            This might be a name like "_value".  We pass this along because it can help
            later parts of the GenerateConstructor process when doing things like field hookup.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Utilities.ParameterName.BestNameForParameter">
            <summary>
            The name we think should actually be used for this parameter.  This will include
            stripping the name of things like underscores.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutable">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.SetItem(System.Int32,`0)">
            <summary>
            Write <paramref name="value"/> to slot <paramref name="index"/>. 
            Fills in unallocated slots preceding the <paramref name="index"/>, if any.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableOrNull">
            <summary>
            Realizes the array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToDowncastedImmutable``1">
            <summary>
            Realizes the array, downcasting each element to a derived type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.ToImmutableAndFree">
            <summary>
            Realizes the array and disposes the builder in one operation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1.Enumerator">
            <summary>
            struct enumerator used in foreach.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder">
            <summary>
            The usage is:
                   var inst = PooledStringBuilder.GetInstance();
                   var sb = inst.builder;
                   ... Do Stuff...
                   ... sb.ToString() ...
                   inst.Free();
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder.CreatePool(System.Int32)">
            <summary>
            If someone need to create a private pool
            </summary>
            <param name="size">The size of the pool.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Factory">
            <remarks>
            Not using System.Func{T} because this file is linked into the (debugger) Formatter,
            which does not have that type (since it compiles against .NET 2.0).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1.ForgetTrackedObject(`0,`0)">
            <summary>
            Removes an object from leak tracking.  
            
            This is called when an object is returned to the pool.  It may also be explicitly 
            called if an object allocated from the pool is intentionally not being returned
            to the pool.  This can be of use with pooled arrays if the consumer wants to 
            return a larger array to the pool than was originally allocated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PooledObject`1">
            <summary>
            this is RAII object to automatically release pooled object when its owning pool
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SharedPools">
            <summary>
            Shared object pool for roslyn
            
            Use this shared pool if only concern is reducing object allocations.
            if perf of an object pool itself is also a concern, use ObjectPool directly.
            
            For example, if you want to create a million of small objects within a second, 
            use the ObjectPool directly. it should have much less overhead than using this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.BigDefault``1">
            <summary>
            pool that uses default constructor with 100 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.Default``1">
            <summary>
            pool that uses default constructor with 20 elements pooled
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseDictionary``1">
            <summary>
            pool that uses string as key with StringComparer.OrdinalIgnoreCase as key comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringIgnoreCaseHashSet">
            <summary>
            pool that uses string as element with StringComparer.OrdinalIgnoreCase as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.StringHashSet">
            <summary>
            pool that uses string as element with StringComparer.Ordinal as element comparer
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SharedPools.ByteArray">
            <summary>
            Used to reduce the # of temporary byte[]s created to satisfy serialization and
            other I/O requests
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SerializableBytes">
            <summary>
            Helpers to create temporary streams backed by pooled memory
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspacesResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_encountered_an_error_and_has_been_disabled">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; encountered an error and has been disabled..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_part_of_the_workspace">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is already part of the workspace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_present">
            <summary>
              Looks up a localized string similar to {0} is already present..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_already_referenced">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is already referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_open">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not open..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_part_of_the_workspace">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not part of the workspace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_present">
            <summary>
              Looks up a localized string similar to {0} is not present..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_not_referenced">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_is_still_open">
            <summary>
              Looks up a localized string similar to {0} is still open..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_must_be_a_non_null_and_non_empty_string">
            <summary>
              Looks up a localized string similar to &quot;{0}&quot; must be a non-null and non-empty string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_returned_an_uninitialized_ImmutableArray">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; returned an uninitialized ImmutableArray.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources._0_still_contains_open_documents">
            <summary>
              Looks up a localized string similar to {0} still contains open documents..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_language_name_cannot_be_specified_for_this_option">
            <summary>
              Looks up a localized string similar to A language name cannot be specified for this option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_language_name_must_be_specified_for_this_option">
            <summary>
              Looks up a localized string similar to A language name must be specified for this option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.A_subtraction_must_be_the_last_element_in_a_character_class">
            <summary>
              Looks up a localized string similar to A subtraction must be the last element in a character class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Absolute_path_expected">
            <summary>
              Looks up a localized string similar to Absolute path expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Abstract_Method">
            <summary>
              Looks up a localized string similar to Abstract Method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Add_braces_to_0_statement">
            <summary>
              Looks up a localized string similar to Add braces to &apos;{0}&apos; statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Added_colon">
            <summary>
              Looks up a localized string similar to Added:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_additional_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding additional documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_analyzer_config_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding analyzer config documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_analyzer_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding analyzer references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_metadata_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding metadata references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
            <summary>
              Looks up a localized string similar to Adding project reference from &apos;{0}&apos; to &apos;{1}&apos; will cause a circular reference..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_project_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding project references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Adding_projects_is_not_supported">
            <summary>
              Looks up a localized string similar to Adding projects is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.After_colon">
            <summary>
              Looks up a localized string similar to After:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Alternation_conditions_cannot_be_comments">
            <summary>
              Looks up a localized string similar to Alternation conditions cannot be comments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Alternation_conditions_do_not_capture_and_cannot_be_named">
            <summary>
              Looks up a localized string similar to Alternation conditions do not capture and cannot be named.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.An_element_with_the_same_key_but_a_different_value_already_exists">
            <summary>
              Looks up a localized string similar to An element with the same key but a different value already exists..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
            <summary>
              Looks up a localized string similar to An error occurred while reading the specified configuration file: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Arrays_with_more_than_one_dimension_cannot_be_serialized">
            <summary>
              Looks up a localized string similar to Arrays with more than one dimension cannot be serialized..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Async_Method">
            <summary>
              Looks up a localized string similar to Async Method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.At_least_one_diagnostic_must_be_supplied">
            <summary>
              Looks up a localized string similar to At least one diagnostic must be supplied..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Before_colon">
            <summary>
              Looks up a localized string similar to Before:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Begins_with_I">
            <summary>
              Looks up a localized string similar to Begins with I.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Can_t_resolve_analyzer_reference_colon_0">
            <summary>
              Looks up a localized string similar to Can&apos;t resolve analyzer reference: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Can_t_resolve_metadata_reference_colon_0">
            <summary>
              Looks up a localized string similar to Can&apos;t resolve metadata reference: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_deserialize_type_0">
            <summary>
              Looks up a localized string similar to Cannot deserialize type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_generate_code_for_unsupported_operator_0">
            <summary>
              Looks up a localized string similar to Cannot generate code for unsupported operator &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_include_class_0_in_character_range">
            <summary>
              Looks up a localized string similar to Cannot include class \{0} in character range.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
            <summary>
              Looks up a localized string similar to Cannot open project &apos;{0}&apos; because the file extension &apos;{1}&apos; is not associated with a language..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_open_project_0_because_the_language_1_is_not_supported">
            <summary>
              Looks up a localized string similar to Cannot open project &apos;{0}&apos; because the language &apos;{1}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cannot_serialize_type_0">
            <summary>
              Looks up a localized string similar to Cannot serialize type &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
            <summary>
              Looks up a localized string similar to Capture group numbers must be less than or equal to Int32.MaxValue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Capture_number_cannot_be_zero">
            <summary>
              Looks up a localized string similar to Capture number cannot be zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cast_is_redundant">
            <summary>
              Looks up a localized string similar to Cast is redundant..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_additional_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing additional documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_analyzer_config_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing analyzer config documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_compilation_options_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing compilation options is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_document_0_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing document &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_document_property_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing document properties is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_parse_options_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing parse options is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Changing_project_properties_is_not_supported">
            <summary>
              Looks up a localized string similar to Changing project properties is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Class">
            <summary>
              Looks up a localized string similar to Class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0">
            <summary>
              Looks up a localized string similar to Compilation is required to accomplish the task but is not supported by project {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Core_EditorConfig_Options">
            <summary>
              Looks up a localized string similar to Core EditorConfig Options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Could_not_find_location_to_generation_symbol_into">
            <summary>
              Looks up a localized string similar to Could not find location to generation symbol into..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.CSharp_files">
            <summary>
              Looks up a localized string similar to C# files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Cycle_detected_in_extensions">
            <summary>
              Looks up a localized string similar to Cycle detected in extensions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.DateTimeKind_must_be_Utc">
            <summary>
              Looks up a localized string similar to DateTimeKind must be Utc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Delegate">
            <summary>
              Looks up a localized string similar to Delegate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Deserialization_reader_for_0_read_incorrect_number_of_values">
            <summary>
              Looks up a localized string similar to Deserialization reader for &apos;{0}&apos; read incorrect number of values..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_location_was_from_a_different_tree">
            <summary>
              Looks up a localized string similar to Destination location was from a different tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_location_was_not_in_source">
            <summary>
              Looks up a localized string similar to Destination location was not in source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4">
            <summary>
              Looks up a localized string similar to Destination type must be a {0}, {1}, {2} or {3}, but given one is {4}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
            <summary>
              Looks up a localized string similar to Destination type must be a {0}, {1} or {2}, but given one is {3}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_type_must_be_a_0_but_given_one_is_1">
            <summary>
              Looks up a localized string similar to Destination type must be a {0}, but given one is {1}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
            <summary>
              Looks up a localized string similar to Destination type must be a {0} or a {1}, but given one is {2}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Diagnostic_must_have_span_0">
            <summary>
              Looks up a localized string similar to Diagnostic must have span &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Document_does_not_support_syntax_trees">
            <summary>
              Looks up a localized string similar to Document does not support syntax trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Documentation_comment_id_must_start_with_E_F_M_N_P_or_T">
            <summary>
              Looks up a localized string similar to Documentation comment id must start with E, F, M, N, P or T.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.dot_NET_Coding_Conventions">
            <summary>
              Looks up a localized string similar to .NET Coding Conventions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Duplicate_source_file_0_in_project_1">
            <summary>
              Looks up a localized string similar to Duplicate source file &apos;{0}&apos; in project &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Enable">
            <summary>
              Looks up a localized string similar to Enable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Enable_and_ignore_future_errors">
            <summary>
              Looks up a localized string similar to Enable and ignore future errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Enum">
            <summary>
              Looks up a localized string similar to Enum.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Error">
            <summary>
              Looks up a localized string similar to Error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Error_reading_content_of_source_file_0_1">
            <summary>
              Looks up a localized string similar to Error reading content of source file &apos;{0}&apos; -- &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Event">
            <summary>
              Looks up a localized string similar to Event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Exceptions_colon">
            <summary>
              Looks up a localized string similar to Exceptions:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expected_0">
            <summary>
              Looks up a localized string similar to Expected {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expected_0_line">
            <summary>
              Looks up a localized string similar to Expected {0} line..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expected_end_of_file">
            <summary>
              Looks up a localized string similar to Expected end-of-file..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expected_header_colon_0">
            <summary>
              Looks up a localized string similar to Expected header: &quot;{0}&quot;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Expression_level_preferences">
            <summary>
              Looks up a localized string similar to Expression-level preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Failure">
            <summary>
              Looks up a localized string similar to Failure.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Field_preferences">
            <summary>
              Looks up a localized string similar to Field preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
            <summary>
              Looks up a localized string similar to File &apos;{0}&apos; size of {1} exceeds maximum allowed size of {2}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.File_was_externally_modified_colon_0">
            <summary>
              Looks up a localized string similar to File was externally modified: {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Fix_all_0">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Fix_all_0_in_1">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos; in &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Fix_all_0_in_Solution">
            <summary>
              Looks up a localized string similar to Fix all &apos;{0}&apos; in Solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Illegal_backslash_at_end_of_pattern">
            <summary>
              Looks up a localized string similar to Illegal \ at end of pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Illegal_x_y_with_x_less_than_y">
            <summary>
              Looks up a localized string similar to Illegal {x,y} with x &gt; y.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Incomplete_character_escape">
            <summary>
              Looks up a localized string similar to Incomplete \p{X} character escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Indentation_and_spacing">
            <summary>
              Looks up a localized string similar to Indentation and spacing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Insufficient_hexadecimal_digits">
            <summary>
              Looks up a localized string similar to Insufficient hexadecimal digits.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Interface">
            <summary>
              Looks up a localized string similar to Interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_CodePage_value_colon_0">
            <summary>
              Looks up a localized string similar to Invalid CodePage value: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_group_name_Group_names_must_begin_with_a_word_character">
            <summary>
              Looks up a localized string similar to Invalid group name: Group names must begin with a word character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_number_of_parameters_for_binary_operator">
            <summary>
              Looks up a localized string similar to Invalid number of parameters for binary operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_number_of_parameters_for_unary_operator">
            <summary>
              Looks up a localized string similar to Invalid number of parameters for unary operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_project_block_expected_after_Project">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;=&quot; after Project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_project_block_expected_after_project_name">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;,&quot; after project name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_project_block_expected_after_project_path">
            <summary>
              Looks up a localized string similar to Invalid project block, expected &quot;,&quot; after project path..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_project_file_path_colon_0">
            <summary>
              Looks up a localized string similar to Invalid project file path: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Invalid_solution_file_path_colon_0">
            <summary>
              Looks up a localized string similar to Invalid solution file path: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
            <summary>
              Looks up a localized string similar to Label for node &apos;{0}&apos; is invalid, it must be within [0, {1})..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Language_keywords_vs_BCL_types_preferences">
            <summary>
              Looks up a localized string similar to Language keywords vs BCL types preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Location_must_be_null_or_from_source">
            <summary>
              Looks up a localized string similar to Location must be null or from source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Malformed">
            <summary>
              Looks up a localized string similar to malformed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Malformed_character_escape">
            <summary>
              Looks up a localized string similar to Malformed \p{X} character escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Malformed_named_back_reference">
            <summary>
              Looks up a localized string similar to Malformed \k&lt;...&gt; named back reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Matching_nodes_0_and_1_must_have_the_same_label">
            <summary>
              Looks up a localized string similar to Matching nodes &apos;{0}&apos; and &apos;{1}&apos; must have the same label..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Member_access_should_be_qualified">
            <summary>
              Looks up a localized string similar to Member access should be qualified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Metadata_is_already_referenced">
            <summary>
              Looks up a localized string similar to Metadata is already referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Metadata_is_not_referenced">
            <summary>
              Looks up a localized string similar to Metadata is not referenced..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Method">
            <summary>
              Looks up a localized string similar to Method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Missing_control_character">
            <summary>
              Looks up a localized string similar to Missing control character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Missing_prefix_colon_0">
            <summary>
              Looks up a localized string similar to Missing prefix: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Missing_suffix_colon_0">
            <summary>
              Looks up a localized string similar to Missing suffix: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Modifier_preferences">
            <summary>
              Looks up a localized string similar to Modifier preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Name_can_be_simplified">
            <summary>
              Looks up a localized string similar to Name can be simplified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Naming_rules">
            <summary>
              Looks up a localized string similar to Naming rules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Naming_styles">
            <summary>
              Looks up a localized string similar to Naming styles.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Nested_quantifier_0">
            <summary>
              Looks up a localized string similar to Nested quantifier {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.New_line_preferences">
            <summary>
              Looks up a localized string similar to New line preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.No_location_provided_to_add_statements_to">
            <summary>
              Looks up a localized string similar to No location provided to add statements to..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Node_0_must_be_contained_in_the_new_tree">
            <summary>
              Looks up a localized string similar to Node &apos;{0}&apos; must be contained in the new tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Node_0_must_be_contained_in_the_old_tree">
            <summary>
              Looks up a localized string similar to Node &apos;{0}&apos; must be contained in the old tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Node_is_of_the_wrong_type">
            <summary>
              Looks up a localized string similar to Node is of the wrong type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Non_Field_Members">
            <summary>
              Looks up a localized string similar to Non-Field Members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.None">
            <summary>
              Looks up a localized string similar to None.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Not_enough_close_parens">
            <summary>
              Looks up a localized string similar to Not enough )&apos;s.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Options_did_not_come_from_specified_Solution">
            <summary>
              Looks up a localized string similar to Options did not come from specified Solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Organize_usings">
            <summary>
              Looks up a localized string similar to Organize usings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Parameter_preferences">
            <summary>
              Looks up a localized string similar to Parameter preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Parentheses_preferences">
            <summary>
              Looks up a localized string similar to Parentheses preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Pascal_Case">
            <summary>
              Looks up a localized string similar to Pascal Case.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Populate_switch">
            <summary>
              Looks up a localized string similar to Populate switch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Prefix_0_does_not_match_expected_prefix_1">
            <summary>
              Looks up a localized string similar to Prefix &apos;{0}&apos; does not match expected prefix &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Prefix_0_is_not_expected">
            <summary>
              Looks up a localized string similar to Prefix &apos;{0}&apos; is not expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Private_Method">
            <summary>
              Looks up a localized string similar to Private Method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Private_or_Internal_Field">
            <summary>
              Looks up a localized string similar to Private or Internal Field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Private_or_Internal_Static_Field">
            <summary>
              Looks up a localized string similar to Private or Internal Static Field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Project_file_not_found_colon_0">
            <summary>
              Looks up a localized string similar to Project file not found: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution">
            <summary>
              Looks up a localized string similar to Project of ID {0} is required to accomplish the task but is not available from the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Property">
            <summary>
              Looks up a localized string similar to Property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Public_or_Protected_Field">
            <summary>
              Looks up a localized string similar to Public or Protected Field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Quantifier_x_y_following_nothing">
            <summary>
              Looks up a localized string similar to Quantifier {x,y} following nothing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Refactoring_Only">
            <summary>
              Looks up a localized string similar to Refactoring Only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Reference_to_undefined_group">
            <summary>
              Looks up a localized string similar to reference to undefined group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Reference_to_undefined_group_name_0">
            <summary>
              Looks up a localized string similar to Reference to undefined group name {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Reference_to_undefined_group_number_0">
            <summary>
              Looks up a localized string similar to Reference to undefined group number {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_control_characters_long">
            <summary>
              Looks up a localized string similar to All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_control_characters_short">
            <summary>
              Looks up a localized string similar to all control characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_diacritic_marks_long">
            <summary>
              Looks up a localized string similar to All diacritic marks. This includes the Mn, Mc, and Me categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_diacritic_marks_short">
            <summary>
              Looks up a localized string similar to all diacritic marks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_letter_characters_long">
            <summary>
              Looks up a localized string similar to All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_letter_characters_short">
            <summary>
              Looks up a localized string similar to all letter characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_numbers_long">
            <summary>
              Looks up a localized string similar to All numbers. This includes the Nd, Nl, and No categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_numbers_short">
            <summary>
              Looks up a localized string similar to all numbers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_punctuation_characters_long">
            <summary>
              Looks up a localized string similar to All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_punctuation_characters_short">
            <summary>
              Looks up a localized string similar to all punctuation characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_separator_characters_long">
            <summary>
              Looks up a localized string similar to All separator characters. This includes the Zs, Zl, and Zp categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_separator_characters_short">
            <summary>
              Looks up a localized string similar to all separator characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_symbols_long">
            <summary>
              Looks up a localized string similar to All symbols. This includes the Sm, Sc, Sk, and So categories..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_all_symbols_short">
            <summary>
              Looks up a localized string similar to all symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_alternation_long">
            <summary>
              Looks up a localized string similar to You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_alternation_short">
            <summary>
              Looks up a localized string similar to alternation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_any_character_group_long">
            <summary>
              Looks up a localized string similar to The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the &apos;s&apos; option, . matches any character..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_any_character_group_short">
            <summary>
              Looks up a localized string similar to any character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_backspace_character_long">
            <summary>
              Looks up a localized string similar to Matches a backspace character, \u0008.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_backspace_character_short">
            <summary>
              Looks up a localized string similar to backspace character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_balancing_group_long">
             <summary>
               Looks up a localized string similar to A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
                
            &apos;name1&apos; is the current group (optional), &apos;name2&apos; is a previously defined group, and &apos;subexpression&apos; is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Be [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_balancing_group_short">
            <summary>
              Looks up a localized string similar to balancing group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_base_group">
            <summary>
              Looks up a localized string similar to base-group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_bell_character_long">
            <summary>
              Looks up a localized string similar to Matches a bell (alarm) character, \u0007.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_bell_character_short">
            <summary>
              Looks up a localized string similar to bell character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_carriage_return_character_long">
            <summary>
              Looks up a localized string similar to Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_carriage_return_character_short">
            <summary>
              Looks up a localized string similar to carriage-return character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_character_class_subtraction_long">
             <summary>
               Looks up a localized string similar to Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.
            
            &apos;base_group&apos; is a positive or negative character group or range. The &apos;excluded_group&apos; component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions)..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_character_class_subtraction_short">
            <summary>
              Looks up a localized string similar to character class subtraction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_character_group">
            <summary>
              Looks up a localized string similar to character-group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_comment">
            <summary>
              Looks up a localized string similar to comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_conditional_expression_match_long">
             <summary>
               Looks up a localized string similar to This language element attempts to match one of two patterns depending on whether it can match an initial pattern.
            
            &apos;expression&apos; is the initial pattern to match, &apos;yes&apos; is the pattern to match if expression is matched, and &apos;no&apos; is the optional pattern to match if expression is not matched..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_conditional_expression_match_short">
            <summary>
              Looks up a localized string similar to conditional expression match.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_conditional_group_match_long">
             <summary>
               Looks up a localized string similar to This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.
            
            &apos;name&apos; is the name (or number) of a capturing group, &apos;yes&apos; is the expression to match if &apos;name&apos; (or &apos;number&apos;) has a match, and &apos;no&apos; is the optional expression to match if it does not..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_conditional_group_match_short">
            <summary>
              Looks up a localized string similar to conditional group match.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_contiguous_matches_long">
            <summary>
              Looks up a localized string similar to The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_contiguous_matches_short">
            <summary>
              Looks up a localized string similar to contiguous matches.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_control_character_long">
            <summary>
              Looks up a localized string similar to Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_control_character_short">
            <summary>
              Looks up a localized string similar to control character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_decimal_digit_character_long">
             <summary>
               Looks up a localized string similar to \d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.
            
            If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_decimal_digit_character_short">
            <summary>
              Looks up a localized string similar to decimal-digit character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_line_comment_long">
            <summary>
              Looks up a localized string similar to A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_line_comment_short">
            <summary>
              Looks up a localized string similar to end-of-line comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_only_long">
            <summary>
              Looks up a localized string similar to The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_only_short">
            <summary>
              Looks up a localized string similar to end of string only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_or_before_ending_newline_long">
             <summary>
               Looks up a localized string similar to The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.
            
            The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_or_before_ending_newline_short">
            <summary>
              Looks up a localized string similar to end of string or before ending newline.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_or_line_long">
             <summary>
               Looks up a localized string similar to The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.
            
            The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_end_of_string_or_line_short">
            <summary>
              Looks up a localized string similar to end of string or line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_escape_character_long">
            <summary>
              Looks up a localized string similar to Matches an escape character, \u001B.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_escape_character_short">
            <summary>
              Looks up a localized string similar to escape character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_excluded_group">
            <summary>
              Looks up a localized string similar to excluded-group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_expression">
            <summary>
              Looks up a localized string similar to expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_form_feed_character_long">
            <summary>
              Looks up a localized string similar to Matches a form-feed character, \u000C.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_form_feed_character_short">
            <summary>
              Looks up a localized string similar to form-feed character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_group_options_long">
             <summary>
               Looks up a localized string similar to This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:
            
                i	Use case-insensitive matching.
                m	Use multiline mode, where ^ and $ match the beginning and end of each line
            	(instead of the beginning and end of the input string).
                s	Use single-line mode, where the period (.) matches every character
            	(instead of every character exc [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_group_options_short">
            <summary>
              Looks up a localized string similar to group options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_hexadecimal_escape_long">
            <summary>
              Looks up a localized string similar to Matches an ASCII character, where ## is a two-digit hexadecimal character code..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_hexadecimal_escape_short">
            <summary>
              Looks up a localized string similar to hexadecimal escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_inline_comment_long">
            <summary>
              Looks up a localized string similar to The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_inline_comment_short">
            <summary>
              Looks up a localized string similar to inline comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_inline_options_long">
             <summary>
               Looks up a localized string similar to Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:
            
                i	Use case-insensitive matching.
                m	Use multiline mode, where ^ and $ match the beginning and end of each line
            	(instead of the beginning and end of the input string).
                s	Use single-line mode, where the period (.) matches every character
            	(instead of every charac [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_inline_options_short">
            <summary>
              Looks up a localized string similar to inline options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_issue_0">
            <summary>
              Looks up a localized string similar to Regex issue: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_letter_lowercase">
            <summary>
              Looks up a localized string similar to letter, lowercase.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_letter_modifier">
            <summary>
              Looks up a localized string similar to letter, modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_letter_other">
            <summary>
              Looks up a localized string similar to letter, other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_letter_titlecase">
            <summary>
              Looks up a localized string similar to letter, titlecase.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_letter_uppercase">
            <summary>
              Looks up a localized string similar to letter, uppercase.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_mark_enclosing">
            <summary>
              Looks up a localized string similar to mark, enclosing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_mark_nonspacing">
            <summary>
              Looks up a localized string similar to mark, nonspacing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_mark_spacing_combining">
            <summary>
              Looks up a localized string similar to mark, spacing combining.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_at_least_n_times_lazy_long">
            <summary>
              Looks up a localized string similar to The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_at_least_n_times_lazy_short">
            <summary>
              Looks up a localized string similar to match at least &apos;n&apos; times (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_at_least_n_times_long">
            <summary>
              Looks up a localized string similar to The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_at_least_n_times_short">
            <summary>
              Looks up a localized string similar to match at least &apos;n&apos; times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_between_m_and_n_times_lazy_long">
            <summary>
              Looks up a localized string similar to The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_between_m_and_n_times_lazy_short">
            <summary>
              Looks up a localized string similar to match at least &apos;n&apos; times (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_between_m_and_n_times_long">
            <summary>
              Looks up a localized string similar to The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_between_m_and_n_times_short">
            <summary>
              Looks up a localized string similar to match between &apos;m&apos; and &apos;n&apos; times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_exactly_n_times_lazy_long">
            <summary>
              Looks up a localized string similar to The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_exactly_n_times_lazy_short">
            <summary>
              Looks up a localized string similar to match exactly &apos;n&apos; times (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_exactly_n_times_long">
            <summary>
              Looks up a localized string similar to The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_exactly_n_times_short">
            <summary>
              Looks up a localized string similar to match exactly &apos;n&apos; times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_one_or_more_times_lazy_long">
            <summary>
              Looks up a localized string similar to The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_one_or_more_times_lazy_short">
            <summary>
              Looks up a localized string similar to match one or more times (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_one_or_more_times_long">
            <summary>
              Looks up a localized string similar to The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_one_or_more_times_short">
            <summary>
              Looks up a localized string similar to match one or more times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_more_times_lazy_long">
            <summary>
              Looks up a localized string similar to The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_more_times_lazy_short">
            <summary>
              Looks up a localized string similar to match zero or more times (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_more_times_long">
            <summary>
              Looks up a localized string similar to The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_more_times_short">
            <summary>
              Looks up a localized string similar to match zero or more times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_one_time_lazy_long">
            <summary>
              Looks up a localized string similar to The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_one_time_lazy_short">
            <summary>
              Looks up a localized string similar to match zero or one time (lazy).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_one_time_long">
            <summary>
              Looks up a localized string similar to The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_match_zero_or_one_time_short">
            <summary>
              Looks up a localized string similar to match zero or one time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_matched_subexpression_long">
            <summary>
              Looks up a localized string similar to This grouping construct captures a matched &apos;subexpression&apos;, where &apos;subexpression&apos; is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_matched_subexpression_short">
            <summary>
              Looks up a localized string similar to matched subexpression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_name">
            <summary>
              Looks up a localized string similar to name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_name_or_number">
            <summary>
              Looks up a localized string similar to name-or-number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_name1">
            <summary>
              Looks up a localized string similar to name1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_name2">
            <summary>
              Looks up a localized string similar to name2.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_named_backreference_long">
             <summary>
               Looks up a localized string similar to A named or numbered backreference.
            
            &apos;name&apos; is the name of a capturing group defined in the regular expression pattern..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_named_backreference_short">
            <summary>
              Looks up a localized string similar to named backreference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_named_matched_subexpression_long">
             <summary>
               Looks up a localized string similar to Captures a matched subexpression and lets you access it by name or by number.
            
            &apos;name&apos; is a valid group name, and &apos;subexpression&apos; is any valid regular expression pattern. &apos;name&apos; must not contain any punctuation characters and cannot begin with a number.
            
            If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing gro [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_named_matched_subexpression_short">
            <summary>
              Looks up a localized string similar to named matched subexpression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_character_group_long">
             <summary>
               Looks up a localized string similar to A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.
            
            Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from &quot;0&quot; through &quot;9&quot;, the range of lowercase letters from &quot;a&quot; through &quot;f&quot;, and the range of uppercase letters from &quot;A&quot; through &quot;F&quot;, use [0-9a-fA-F]..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_character_group_short">
            <summary>
              Looks up a localized string similar to negative character group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_character_range_long">
             <summary>
               Looks up a localized string similar to A negative character range specifies a list of characters that must not appear in an input string for a match to occur. &apos;firstCharacter&apos; is the character that begins the range, and &apos;lastCharacter&apos; is the character that ends the range.
            
            Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from &quot;0&quot; through &quot;9&quot;, the range of lowercase letters from &quot;a&quot; through &quot;f&quot;, and the range of uppercase letters from &quot;A&quot; through &quot;F&quot;, use [0-9a-fA-F]..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_character_range_short">
            <summary>
              Looks up a localized string similar to negative character range.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_unicode_category_long">
            <summary>
              Looks up a localized string similar to The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_negative_unicode_category_short">
            <summary>
              Looks up a localized string similar to negative unicode category.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_new_line_character_long">
            <summary>
              Looks up a localized string similar to Matches a new-line character, \u000A.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_new_line_character_short">
            <summary>
              Looks up a localized string similar to new-line character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_no">
            <summary>
              Looks up a localized string similar to no.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_digit_character_long">
             <summary>
               Looks up a localized string similar to \D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.
            
            If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_digit_character_short">
            <summary>
              Looks up a localized string similar to non-digit character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_white_space_character_long">
             <summary>
               Looks up a localized string similar to \S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.
            
            If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_white_space_character_short">
            <summary>
              Looks up a localized string similar to non-white-space character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_word_boundary_long">
            <summary>
              Looks up a localized string similar to The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_word_boundary_short">
            <summary>
              Looks up a localized string similar to non-word boundary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_word_character_long">
             <summary>
               Looks up a localized string similar to \W matches any non-word character. It matches any character except for those in the following Unicode categories:
            
                Ll	Letter, Lowercase
                Lu	Letter, Uppercase
                Lt	Letter, Titlecase
                Lo	Letter, Other
                Lm	Letter, Modifier
                Mn	Mark, Nonspacing
                Nd	Number, Decimal Digit
                Pc	Punctuation, Connector
            
            If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_non_word_character_short">
            <summary>
              Looks up a localized string similar to non-word character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_nonbacktracking_subexpression_long">
             <summary>
               Looks up a localized string similar to This construct disables backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)
            
            This option is recommended if you know that backtracking will not succeed. Preven [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_nonbacktracking_subexpression_short">
            <summary>
              Looks up a localized string similar to nonbacktracking subexpression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_noncapturing_group_long">
             <summary>
               Looks up a localized string similar to This construct does not capture the substring that is matched by a subexpression:
            
            The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.
            
            If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_noncapturing_group_short">
            <summary>
              Looks up a localized string similar to noncapturing group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_number_decimal_digit">
            <summary>
              Looks up a localized string similar to number, decimal digit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_number_letter">
            <summary>
              Looks up a localized string similar to number, letter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_number_other">
            <summary>
              Looks up a localized string similar to number, other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_numbered_backreference_long">
             <summary>
               Looks up a localized string similar to A numbered backreference, where &apos;number&apos; is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.
            
            There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot b [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_numbered_backreference_short">
            <summary>
              Looks up a localized string similar to numbered backreference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_other_control">
            <summary>
              Looks up a localized string similar to other, control.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_other_format">
            <summary>
              Looks up a localized string similar to other, format.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_other_not_assigned">
            <summary>
              Looks up a localized string similar to other, not assigned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_other_private_use">
            <summary>
              Looks up a localized string similar to other, private use.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_other_surrogate">
            <summary>
              Looks up a localized string similar to other, surrogate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_positive_character_group_long">
            <summary>
              Looks up a localized string similar to A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_positive_character_group_short">
            <summary>
              Looks up a localized string similar to positive character group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_positive_character_range_long">
            <summary>
              Looks up a localized string similar to A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  &apos;firstCharacter&apos; is the character that begins the range and &apos;lastCharacter&apos; is the character that ends the range. .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_positive_character_range_short">
            <summary>
              Looks up a localized string similar to positive character range.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_close">
            <summary>
              Looks up a localized string similar to punctuation, close.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_connector">
            <summary>
              Looks up a localized string similar to punctuation, connector.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_dash">
            <summary>
              Looks up a localized string similar to punctuation, dash.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_final_quote">
            <summary>
              Looks up a localized string similar to punctuation, final quote.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_initial_quote">
            <summary>
              Looks up a localized string similar to punctuation, initial quote.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_open">
            <summary>
              Looks up a localized string similar to punctuation, open.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_punctuation_other">
            <summary>
              Looks up a localized string similar to punctuation, other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_separator_line">
            <summary>
              Looks up a localized string similar to separator, line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_separator_paragraph">
            <summary>
              Looks up a localized string similar to separator, paragraph.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_separator_space">
            <summary>
              Looks up a localized string similar to separator, space.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_start_of_string_only_long">
            <summary>
              Looks up a localized string similar to The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_start_of_string_only_short">
            <summary>
              Looks up a localized string similar to start of string only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_start_of_string_or_line_long">
            <summary>
              Looks up a localized string similar to The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_start_of_string_or_line_short">
            <summary>
              Looks up a localized string similar to start of string or line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_subexpression">
            <summary>
              Looks up a localized string similar to subexpression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_symbol_currency">
            <summary>
              Looks up a localized string similar to symbol, currency.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_symbol_math">
            <summary>
              Looks up a localized string similar to symbol, math.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_symbol_modifier">
            <summary>
              Looks up a localized string similar to symbol, modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_symbol_other">
            <summary>
              Looks up a localized string similar to symbol, other.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_tab_character_long">
            <summary>
              Looks up a localized string similar to Matches a tab character, \u0009.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_tab_character_short">
            <summary>
              Looks up a localized string similar to tab character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_unicode_category_long">
            <summary>
              Looks up a localized string similar to The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_unicode_category_short">
            <summary>
              Looks up a localized string similar to unicode category.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_unicode_escape_long">
            <summary>
              Looks up a localized string similar to Matches a UTF-16 code unit whose value is #### hexadecimal..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_unicode_escape_short">
            <summary>
              Looks up a localized string similar to unicode escape.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_unicode_general_category_0">
            <summary>
              Looks up a localized string similar to Unicode General Category: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_vertical_tab_character_long">
            <summary>
              Looks up a localized string similar to Matches a vertical-tab character, \u000B.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_vertical_tab_character_short">
            <summary>
              Looks up a localized string similar to vertical-tab character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_white_space_character_long">
             <summary>
               Looks up a localized string similar to \s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:
            
                \f	The form feed character, \u000C
                \n	The newline character, \u000A
                \r	The carriage return character, \u000D
                \t	The tab character, \u0009
                \v	The vertical tab character, \u000B
                \x85	The ellipsis or NEXT LINE (NEL) character (), \u0085
                \p{Z}	Matches any separator character
            
            If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_white_space_character_short">
            <summary>
              Looks up a localized string similar to white-space character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_word_boundary_long">
             <summary>
               Looks up a localized string similar to The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.
            
            The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beg [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_word_boundary_short">
            <summary>
              Looks up a localized string similar to word boundary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_word_character_long">
             <summary>
               Looks up a localized string similar to \w matches any word character. A word character is a member of any of the following Unicode categories:
            
                Ll	Letter, Lowercase
                Lu	Letter, Uppercase
                Lt	Letter, Titlecase
                Lo	Letter, Other
                Lm	Letter, Modifier
                Mn	Mark, Nonspacing
                Nd	Number, Decimal Digit
                Pc	Punctuation, Connector
            
            If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9].
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_word_character_short">
            <summary>
              Looks up a localized string similar to word character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_yes">
            <summary>
              Looks up a localized string similar to yes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_negative_lookahead_assertion_long">
             <summary>
               Looks up a localized string similar to A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.
            
            A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_negative_lookahead_assertion_short">
            <summary>
              Looks up a localized string similar to zero-width negative lookahead assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_negative_lookbehind_assertion_long">
             <summary>
               Looks up a localized string similar to A zero-width negative lookbehind assertion, where for a match to be successful, &apos;subexpression&apos; must not occur at the input string to the left of the current position. Any substring that does not match &apos;subexpression&apos; is not included in the match result.
            
            Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or character [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_negative_lookbehind_assertion_short">
            <summary>
              Looks up a localized string similar to zero-width negative lookbehind assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_positive_lookahead_assertion_long">
             <summary>
               Looks up a localized string similar to A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in &apos;subexpression&apos;. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.
            
            Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_positive_lookahead_assertion_short">
            <summary>
              Looks up a localized string similar to zero-width positive lookahead assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_positive_lookbehind_assertion_long">
             <summary>
               Looks up a localized string similar to A zero-width positive lookbehind assertion, where for a match to be successful, &apos;subexpression&apos; must occur at the input string to the left of the current position. &apos;subexpression&apos; is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.
            
            Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Regex_zero_width_positive_lookbehind_assertion_short">
            <summary>
              Looks up a localized string similar to zero-width positive lookbehind assertion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories">
            <summary>
              Looks up a localized string similar to Remove the line below if you want to inherit .editorconfig settings from higher directories.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removed_colon">
            <summary>
              Looks up a localized string similar to Removed:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_additional_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing additional documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_analyzer_config_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing analyzer config documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_analyzer_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing analyzer references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_documents_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing documents is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_metadata_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing metadata references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_project_references_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing project references is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Removing_projects_is_not_supported">
            <summary>
              Looks up a localized string similar to Removing projects is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace">
            <summary>
              Looks up a localized string similar to Service of type &apos;{0}&apos; is required to accomplish the task but is not available from the workspace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Show_Stack_Trace">
            <summary>
              Looks up a localized string similar to Show Stack Trace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Solution_file_not_found_colon_0">
            <summary>
              Looks up a localized string similar to Solution file not found: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Specified_path_must_be_absolute">
            <summary>
              Looks up a localized string similar to Specified path must be absolute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Static_Field">
            <summary>
              Looks up a localized string similar to Static Field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Static_Method">
            <summary>
              Looks up a localized string similar to Static Method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Stream_is_too_long">
            <summary>
              Looks up a localized string similar to Stream is too long..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Struct">
            <summary>
              Looks up a localized string similar to Struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Suggestion">
            <summary>
              Looks up a localized string similar to Suggestion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Supplied_diagnostic_cannot_be_null">
            <summary>
              Looks up a localized string similar to Supplied diagnostic cannot be null..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Symbol_0_is_not_from_source">
            <summary>
              Looks up a localized string similar to Symbol &quot;{0}&quot; is not from source..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Symbol_specifications">
            <summary>
              Looks up a localized string similar to Symbol specifications.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0">
            <summary>
              Looks up a localized string similar to Syntax tree is required to accomplish the task but is not supported by document {0}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Temporary_storage_cannot_be_written_more_than_once">
            <summary>
              Looks up a localized string similar to Temporary storage cannot be written more than once..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_first_word_0_must_begin_with_a_lower_case_character">
            <summary>
              Looks up a localized string similar to The first word, &apos;{0}&apos;, must begin with a lower case character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_first_word_0_must_begin_with_an_upper_case_character">
            <summary>
              Looks up a localized string similar to The first word, &apos;{0}&apos;, must begin with an upper case character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_language_0_is_not_supported">
            <summary>
              Looks up a localized string similar to The language &apos;{0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
            <summary>
              Looks up a localized string similar to The member &apos;{0}&apos; is not declared within the declaration of the symbol..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_node_is_not_part_of_the_tree">
            <summary>
              Looks up a localized string similar to The node is not part of the tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_position_is_not_within_the_symbol_s_declaration">
            <summary>
              Looks up a localized string similar to The position is not within the symbol&apos;s declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_project_already_references_the_target_project">
            <summary>
              Looks up a localized string similar to The project already references the target project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_project_already_transitively_references_the_target_project">
            <summary>
              Looks up a localized string similar to The project already transitively references the target project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_already_contains_the_specified_document">
            <summary>
              Looks up a localized string similar to The solution already contains the specified document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_already_contains_the_specified_project">
            <summary>
              Looks up a localized string similar to The solution already contains the specified project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_does_not_contain_the_specified_document">
            <summary>
              Looks up a localized string similar to The solution does not contain the specified document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_solution_does_not_contain_the_specified_project">
            <summary>
              Looks up a localized string similar to The solution does not contain the specified project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_specified_document_is_not_a_version_of_this_document">
            <summary>
              Looks up a localized string similar to The specified document is not a version of this document..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_symbol_0_cannot_be_located_within_the_current_solution">
            <summary>
              Looks up a localized string similar to The symbol &apos;{0}&apos; cannot be located within the current solution..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.The_type_0_is_not_understood_by_the_serialization_binder">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; is not understood by the serialization binder..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
            <summary>
              Looks up a localized string similar to These non-leading words must begin with a lowercase letter: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
            <summary>
              Looks up a localized string similar to These non-leading words must begin with an upper case letter: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.These_words_cannot_contain_lower_case_characters_colon_0">
            <summary>
              Looks up a localized string similar to These words cannot contain lower case characters: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.These_words_cannot_contain_upper_case_characters_colon_0">
            <summary>
              Looks up a localized string similar to These words cannot contain upper case characters: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.These_words_must_begin_with_upper_case_characters_colon_0">
            <summary>
              Looks up a localized string similar to These words must begin with upper case characters: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.this_dot_and_Me_dot_preferences">
            <summary>
              Looks up a localized string similar to this. and Me. preferences.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.This_submission_already_references_another_submission_project">
            <summary>
              Looks up a localized string similar to This submission already references another submission project..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.This_workspace_does_not_support_opening_and_closing_documents">
            <summary>
              Looks up a localized string similar to This workspace does not support opening and closing documents..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Too_many_bars_in_conditional_grouping">
            <summary>
              Looks up a localized string similar to Too many | in (?()|).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Too_many_close_parens">
            <summary>
              Looks up a localized string similar to Too many )&apos;s.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Types">
            <summary>
              Looks up a localized string similar to Types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unknown_identifier">
            <summary>
              Looks up a localized string similar to Unknown identifier..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unknown_property">
            <summary>
              Looks up a localized string similar to Unknown property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unknown_property_0">
            <summary>
              Looks up a localized string similar to Unknown property &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unmerged_change_from_project_0">
            <summary>
              Looks up a localized string similar to Unmerged change from project &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unrecognized_control_character">
            <summary>
              Looks up a localized string similar to Unrecognized control character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unrecognized_escape_sequence_0">
            <summary>
              Looks up a localized string similar to Unrecognized escape sequence \{0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unrecognized_grouping_construct">
            <summary>
              Looks up a localized string similar to Unrecognized grouping construct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unrecognized_language_name">
            <summary>
              Looks up a localized string similar to Unrecognized language name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unterminated_character_class_set">
            <summary>
              Looks up a localized string similar to Unterminated [] set.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Unterminated_regex_comment">
            <summary>
              Looks up a localized string similar to Unterminated (?#...) comment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
            <summary>
              Looks up a localized string similar to Value too large to be represented as a 30 bit unsigned integer..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Variables_captured_colon">
            <summary>
              Looks up a localized string similar to Variables captured:.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Visual_Basic_files">
            <summary>
              Looks up a localized string similar to Visual Basic files.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Warning">
            <summary>
              Looks up a localized string similar to Warning.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access">
            <summary>
              Looks up a localized string similar to Adding imports will bring an extension method into scope with the same name as &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Workspace_error">
            <summary>
              Looks up a localized string similar to Workspace error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.Workspace_is_not_empty">
            <summary>
              Looks up a localized string similar to Workspace is not empty..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspacesResources.x_y_range_in_reverse_order">
            <summary>
              Looks up a localized string similar to [x-y] range in reverse order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AdhocWorkspace">
            <summary>
            A workspace that allows full manipulation of projects and documents,
            but does not persist changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.ClearSolution">
            <summary>
            Clears all projects and documents from the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Adds an entire solution to the workspace, replacing any existing solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProject(System.String,System.String)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Adds a project to the workspace. All previous projects remain intact.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddProjects(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Adds multiple projects to the workspace at once. All existing projects remain intact.
            </summary>
            <param name="projectInfos"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddDocument(Microsoft.CodeAnalysis.ProjectId,System.String,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Adds a document to the workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified document into the closed state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified additional document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified additional document into the closed state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.OpenAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Puts the specified analyzer config document into the open state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.AdhocWorkspace.CloseAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Puts the specified analyzer config document into the closed state
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.FileTextLoaderOptions.FileLengthThreshold">
            <summary>
            Hidden registry key to control maximum size of a text file we will read into memory. 
            we have this option to reduce a chance of OOM when user adds massive size files to the solution.
            Default threshold is 100MB which came from some internal data on big files and some discussion.
            
            User can override default value by setting DWORD value on FileLengthThreshold in 
            "[VS HIVE]\Roslyn\Internal\Performance\Text"
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.Path">
            <summary>
            Absolute path of the file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding">
            <summary>
            Specifies an encoding to be used if the actual encoding of the file 
            can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If <c>null</c> auto-detect heuristics are used to determine the encoding. 
            Note that if the stream starts with Byte Order Mark the value of <see cref="P:Microsoft.CodeAnalysis.FileTextLoader.DefaultEncoding"/> is ignored.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.#ctor(System.String,System.Text.Encoding)">
            <summary>
            Creates a content loader for specified file.
            </summary>
            <param name="path">An absolute file path.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> is null.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> is not an absolute path.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FileTextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException"></exception>
            <exception cref="T:System.IO.InvalidDataException"></exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.PrimaryWorkspace.Workspace">
            <summary>
            The primary workspace, usually set by the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.PrimaryWorkspace.Register(Microsoft.CodeAnalysis.Workspace)">
            <summary>
            Register a workspace as the primary workspace. Only one workspace can be the primary.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.AdditionalDocument">
            <summary>
            Represents an additional file passed down to analyzers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.BranchId">
            <summary>
            solution branch Id
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Checksum">
            <summary>
            Checksum of data can be used later to see whether two data are same or not
            without actually comparing data itself
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Checksum.HashSize">
            <summary>
            The intended size of the <see cref="T:Microsoft.CodeAnalysis.Checksum.HashData"/> structure. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Checksum.From(System.Byte[])">
            <summary>
            Create Checksum from given byte array. if byte array is bigger than
            <see cref="F:Microsoft.CodeAnalysis.Checksum.HashSize"/>, it will be truncated to the size
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Checksum.From(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Create Checksum from given byte array. if byte array is bigger than
            <see cref="F:Microsoft.CodeAnalysis.Checksum.HashSize"/>, it will be truncated to the size
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Checksum.HashData">
            <summary>
            This structure stores the 20-byte hash as an inline value rather than requiring the use of
            <c>byte[]</c>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DefaultTextDocumentServiceProvider">
            <summary>
            <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> for regular C#/VB files.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Document">
            <summary>
            Represents a source code document that is part of a project.
            It provides access to the source text, parsed syntax tree and the corresponding semantic model.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Document._model">
            <summary>
            A cached reference to the <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Document._syntaxTreeResultTask">
            <summary>
            A cached task that can be returned once the tree has already been created. This is only set if <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns true,
            so the inner value can be non-null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SourceCodeKind">
            <summary>
            The kind of source code this document contains.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.HasInfoChanged(Microsoft.CodeAnalysis.TextDocument)">
            <summary>
            True if the info of the document change (name, folders, file path; not the content)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree@)">
            <summary>
            Get the current syntax tree for the document if the text is already loaded and the tree is already parsed.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)"/> to fetch the tree, which will parse the tree
            if it's not already parsed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Get the current syntax tree version for the document if the text is already loaded and the tree is already parsed.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxVersionAsync(System.Threading.CancellationToken)"/> to fetch the version, which will load the tree
            if it's not already available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetTopLevelChangeTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's top level signature if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the syntax tree. This is generally the newer of the text version and the project's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree">
            <summary>
            <see langword="true"/> if this Document supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)"/> and <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)"/> methods.
            
            If <see langword="false"/> then these methods will return <see langword="null"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel">
            <summary>
            <see langword="true"/> if this Document supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/> method.
            
            If <see langword="false"/> then that method will return <see langword="null"/> instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree" /> for this document asynchronously.
            </summary>
            <returns>
            The returned syntax tree can be null if the <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            Gets the root node of the current syntax tree if the syntax tree has already been parsed and the tree is still cached.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)"/> to fetch the root node, which will parse
            the document if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/> will be null if <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSyntaxTree"/> returns false.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSyntaxRootSynchronously(System.Threading.CancellationToken)">
            <summary>
            Only for features that absolutely must run synchronously (probably because they're
            on the UI thread).  Right now, the only feature this is for is Outlining as VS will
            block on that feature from the UI thread when a document is opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.TryGetSemanticModel(Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Gets the current semantic model for this document if the model is already computed and still cached.
            In almost all cases, you should call <see cref="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)"/>, which will compute the semantic model
            if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetSemanticModelAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the semantic model for this document asynchronously.
            </summary>
            <returns>
            The returned <see cref="T:Microsoft.CodeAnalysis.SemanticModel"/> may be null if <see cref="P:Microsoft.CodeAnalysis.Document.SupportsSemanticModel"/> returns false.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSourceCodeKind(Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new instance of this document updated to have the source code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new instance of this document updated to have the text specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithSyntaxRoot(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Creates a new instance of this document updated to have a syntax tree rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithName(System.String)">
            <summary>
            Creates a new instance of this document updated to have the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFolders(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new instance of this document updated to have the specified folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFilePath(System.String)">
            <summary>
            Creates a new instance of this document updated to have the specified file path.
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Get the text changes between this document and a prior version of the same document.
            The changes, when applied to the text of the old document, will produce the text of the current document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetLinkedDocumentIds">
            <summary>
            Gets the list of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s that are linked to this
            <see cref="T:Microsoft.CodeAnalysis.Document" />. <see cref="T:Microsoft.CodeAnalysis.Document"/>s are considered to be linked if they
            share the same <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath" />. This <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> is excluded from the
            result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.WithFrozenPartialSemantics(System.Threading.CancellationToken)">
             <summary>
             Creates a branched version of this document that has its semantic model frozen in whatever state it is available at the time,
             assuming a background process is constructing the semantics asynchronously. Repeated calls to this method may return
             documents with increasingly more complete semantics.
            
             Use this method to gain access to potentially incomplete semantics quickly.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Document.GetOptionsAsync(System.Threading.CancellationToken)">
            <summary>
            Returns the options that should be applied to this document. This consists of global options from <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>,
            merged with any settings the user has specified at the document levels.
            </summary>
            <remarks>
            This method is async because this may require reading other files. In files that are already open, this is expected to be cheap and complete synchronously.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentId">
            <summary>
            An identifier that can be used to retrieve the same <see cref="T:Microsoft.CodeAnalysis.Document"/> across versions of the
            workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentId.CreateNewId(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> instance.
            </summary>
            <param name="projectId">The project id this document id is relative to.</param>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentInfo">
            <summary>
            A class that represents all the arguments necessary to create a new document instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Id">
            <summary>
            The Id of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.Folders">
            <summary>
            The names of the logical nested folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.SourceCodeKind">
            <summary>
            The kind of the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.FilePath">
            <summary>
            The file path of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.IsGenerated">
            <summary>
            True if the document is a side effect of the build.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.TextLoader">
            <summary>
            A loader that can retrieve the document text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentServiceProvider">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.DocumentInfo.#ctor(Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.Host.IDocumentServiceProvider)">
            <summary>
            Create a new instance of a <see cref="T:Microsoft.CodeAnalysis.DocumentInfo"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes">
            <summary>
            type that contains information regarding this document itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Id">
            <summary>
            The Id of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.Folders">
            <summary>
            The names of the logical nested folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.SourceCodeKind">
            <summary>
            The kind of the source code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.FilePath">
            <summary>
            The file path of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.DocumentInfo.DocumentAttributes.IsGenerated">
            <summary>
            True if the document is a side effect of the build.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DocumentState.TreeTextSource">
            <summary>
            A source for <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> constructed from an syntax tree.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.IChecksummedObject">
            <summary>
            Indicates whether a type has checksum or not
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTextDifferencingService.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,System.Threading.CancellationToken)">
            <summary>
            Computes the text changes between two documents.
            </summary>
            <param name="oldDocument">The old version of the document.</param>
            <param name="newDocument">The new version of the document.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An array of changes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.IDocumentTextDifferencingService.GetTextChangesAsync(Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.Document,Microsoft.CodeAnalysis.TextDifferenceTypes,System.Threading.CancellationToken)">
            <summary>
            Computes the text changes between two documents.
            </summary>
            <param name="oldDocument">The old version of the document.</param>
            <param name="newDocument">The new version of the document.</param>
            <param name="preferredDifferenceType">The type of differencing to perform. Not supported by all text differencing services.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An array of changes.</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.MetadataOnlyImage.s_lifetime">
            <summary>
            A map to ensure that the streams from the temporary storage service that back the metadata we create stay alive as long
            as the metadata is alive.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.PreservationMode">
            <summary>
            The mode in which value is preserved.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveValue">
            <summary>
            The value is guaranteed to have the same contents across multiple accesses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.PreservationMode.PreserveIdentity">
            <summary>
            The value is guaranteed to the same instance across multiple accesses.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Project">
            <summary>
            Represents a project that is part of a <see cref="P:Microsoft.CodeAnalysis.Project.Solution"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Solution">
            <summary>
            The solution this project is part of.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Id">
            <summary>
            The ID of the project. Multiple <see cref="T:Microsoft.CodeAnalysis.Project"/> instances may share the same ID. However, only
            one project may have this ID in any given solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.OutputFilePath">
            <summary>
            The path to the output file, or null if it is not known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file, or null if it is not known.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.DefaultNamespace">
            <summary>
            The default namespace of the project ("" if not defined, which means global namespace),
            or null if it is unknown or not applicable. 
            </summary>
            <remarks>
            Right now VB doesn't have the concept of "default namespace". But we conjure one in workspace 
            by assigning the value of the project's root namespace to it. So various feature can choose to 
            use it for their own purpose.
            In the future, we might consider officially exposing "default namespace" for VB project 
            (e.g. through a "defaultnamespace" msbuild property)
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.SupportsCompilation">
            <summary>
            <see langword="true"/> if this <see cref="T:Microsoft.CodeAnalysis.Project"/> supports providing data through the
            <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> method.
            
            If <see langword="false"/> then <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> method will return <see langword="null"/> instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.LanguageServices">
            <summary>
            The language services from the host environment associated with this project's language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Language">
            <summary>
            The language associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AssemblyName">
            <summary>
            The name of the assembly this project represents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Name">
            <summary>
            The name of the project. This may be different than the assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.MetadataReferences">
            <summary>
            The list of all other metadata sources (assemblies) that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ProjectReferences">
            <summary>
            The list of all other projects within the same solution that this project references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AllProjectReferences">
            <summary>
            The list of all other projects that this project references, including projects that 
            are not part of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerReferences">
            <summary>
            The list of all the diagnostic analyzer references for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerOptions">
            <summary>
            The options used by analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.CompilationOptions">
            <summary>
            The options used when building the compilation for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.ParseOptions">
            <summary>
            The options used when parsing documents for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.IsSubmission">
            <summary>
            Returns true if this is a submission project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.HasDocuments">
            <summary>
            True if the project has any documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.DocumentIds">
            <summary>
            All the document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AdditionalDocumentIds">
            <summary>
            All the additional document IDs associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Documents">
            <summary>
            All the documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AdditionalDocuments">
            <summary>
            All the additional documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.AnalyzerConfigDocuments">
            <summary>
            All the <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>s associated with this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains a document with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains an additional document with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the project contains an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/> with the specified ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the documentId in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Get the document in this project with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the additional document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Get the analyzer config document in this project with the specified document Id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Tries to get the cached <see cref="T:Microsoft.CodeAnalysis.Compilation"/> for this project if it has already been created and is still cached. In almost all
            cases you should call <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> which will either return the cached <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            or create a new one otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)">
            <summary>
            Get the <see cref="T:Microsoft.CodeAnalysis.Compilation"/> for this project asynchronously.
            </summary>
            <returns>
            Returns the produced <see cref="T:Microsoft.CodeAnalysis.Compilation"/>, or <see langword="null"/> if the project language of this project doesn't support producing compilations.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.HasSuccessfullyLoadedAsync(System.Threading.CancellationToken)">
            <summary>
            Determines if the compilation returned by <see cref="M:Microsoft.CodeAnalysis.Project.GetCompilationAsync(System.Threading.CancellationToken)"/> and all its referenced compilation are from fully loaded projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetChanges(Microsoft.CodeAnalysis.Project)">
            <summary>
            Gets an object that lists the added, changed and removed documents between this project and the specified project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Project.Version">
            <summary>
            The project version. This equates to the version of the project file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetLatestDocumentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The version of the most recently modified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The most recent version of the project, its documents and all dependent projects and documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetDependentSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project including the semantics of referenced projects.
            This version changes whenever the consumable declarations of this project and/or projects it depends on change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.GetSemanticVersionAsync(System.Threading.CancellationToken)">
            <summary>
            The semantic version of this project not including the semantics of referenced projects.
            This version changes only when the consumable declarations of this project change.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAssemblyName(System.String)">
            <summary>
            Creates a new instance of this project updated to have the new assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithDefaultNamespace(System.String)">
            <summary>
            Creates a new instance of this project updated to have the new default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithCompilationOptions(Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithParseOptions(Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Creates a new instance of this project updated to have the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to include the specified project reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to include the specified project references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithProjectReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Creates a new instance of this project updated to replace existing project references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to include the specified metadata reference
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to include the specified metadata references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveMetadataReference(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithMetadataReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new instance of this project updated to replace existing metadata reference
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer reference 
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to include the specified analyzer references
            in addition to already existing ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerReference(Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.WithAnalyzerReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Creates a new instance of this project updated to replace existing analyzer references 
            with the specified ones.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddDocument(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAdditionalDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new additional document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAdditionalDocument(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new additional document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.AddAnalyzerConfigDocument(System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new analyzer config document in a new instance of this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified additional document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Project.RemoveAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new instance of this project updated to no longer include the specified analyzer config document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedDocuments">
            <summary>
            Get Documents with any changes, including textual and non-textual changes
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectChanges.GetChangedDocuments(System.Boolean)">
            <summary>
            Get Changed Documents:
            When onlyGetDocumentsWithTextChanges is true, only get documents with text changes (we only check text source, not actual content);
            otherwise get documents with any changes i.e. DocumentState changes:
            <see cref="P:Microsoft.CodeAnalysis.DocumentState.ParseOptions"/>, <see cref="P:Microsoft.CodeAnalysis.DocumentState.SourceCodeKind"/>, <see cref="P:Microsoft.CodeAnalysis.TextDocumentState.FilePath"/>
            </summary>
            <param name="onlyGetDocumentsWithTextChanges"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectDependencyGraph">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> models the dependencies between projects in a solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap">
             <summary>
             The map of projects to dependencies. This field is always fully initialized. Projects which do not reference
             any other projects do not have a key in this map (i.e. they are omitted, as opposed to including them with
             an empty value).
            
             <list type="bullet">
             <item><description>This field is always fully initialized</description></item>
             <item><description>Projects which do not reference any other projects do not have a key in this map (i.e.
             they are omitted, as opposed to including them with an empty value)</description></item>
             <item><description>The keys in this map always contained in <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._projectIds"/></description></item>
             <item><description>The values in this map <em>might not</em> be contained in <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._projectIds"/> (i.e.
             projects are allowed to have references to projects which are not part of the solution)</description></item>
             </list>
             </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap">
            <summary>
            The lazily-initialized map of projects to projects which reference them. This field is either null, or
            fully-computed. Projects which are not referenced by any other project do not have a key in this map (i.e.
            they are omitted, as opposed to including them with an empty value).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectDirectlyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that this project directly depends on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatDirectlyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly depend on this project.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.TryGetProjectsThatThisProjectTransitivelyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively this project depends on, if it has already been
            cached.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatThisProjectTransitivelyDependsOn(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively this project depends on
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetProjectsThatTransitivelyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively depend on this project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetTopologicallySortedProjects(System.Threading.CancellationToken)">
            <summary>
            Returns all the projects for the solution in a topologically sorted order with respect
            to their dependencies. Projects that depend on other projects will always show up later in this sequence
            than the projects they depend on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.GetDependencySets(System.Threading.CancellationToken)">
            <summary>
            Returns a sequence of sets, where each set contains items with shared interdependency,
            and there is no dependency between sets.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.TestAccessor.TryGetProjectsThatTransitivelyDependOnThisProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the list of projects that directly or transitively depend on this project, if it has already been
            cached.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the addition of additional project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the addition of additional project references.
            </summary>
            <param name="existingReverseReferencesMap">The previous <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/>, or
            <see langword="null"/> if the reverse references map was not computed for the previous graph.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._transitiveReferencesMap"/> for the addition of additional project references. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForAdditionalProjectReferences(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IReadOnlyList{Microsoft.CodeAnalysis.ProjectId})">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._reverseTransitiveReferencesMap"/> for the addition of new projects.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the removal of a project.
            </summary>
            <param name="existingForwardReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> prior to the removal.</param>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal.
            This map serves as a hint to the removal process; i.e. it is assumed correct if it contains data, but may be
            omitted without impacting correctness.</param>
            <param name="removedProjectId">The ID of the project which is being removed.</param>
            <returns>The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._referencesMap"/> for the project dependency graph once the project is removed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the removal of a project.
            </summary>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal,
            or <see langword="null"/> if the value prior to removal was not computed for the graph.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._transitiveReferencesMap"/> for the removal of a project.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._reverseTransitiveReferencesMap"/> for the removal of a project.
            </summary>
            <seealso cref="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewTransitiveReferencesMapForRemovedProject(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId)"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectDependencyGraph.ComputeNewReverseReferencesMapForRemovedProjectReference(System.Collections.Immutable.ImmutableDictionary{Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableHashSet{Microsoft.CodeAnalysis.ProjectId}},Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Computes a new <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> for the removal of a project reference.
            </summary>
            <param name="existingReverseReferencesMap">The <see cref="F:Microsoft.CodeAnalysis.ProjectDependencyGraph._lazyReverseReferencesMap"/> prior to the removal,
            or <see langword="null"/> if the reverse references map was not computed for the prior graph.</param>
            <param name="projectId">The project ID from which a project reference is being removed.</param>
            <param name="referencedProjectId">The target of the project reference which is being removed.</param>
            <returns>The updated (complete) reverse references map, or <see langword="null"/> if the reverse references
            map could not be incrementally updated.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectId">
            <summary>
            An identifier that can be used to refer to the same <see cref="T:Microsoft.CodeAnalysis.Project"/> across versions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectId.Id">
            <summary>
            The system generated unique id.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectId.CreateNewId(System.String)">
            <summary>
            Create a new ProjectId instance.
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectInfo">
            <summary>
            A class that represents all the arguments necessary to create a new project instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Id">
            <summary>
            The unique Id of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Version">
            <summary>
            The version of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Name">
            <summary>
            The name of the project. This may differ from the project's filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AssemblyName">
            <summary>
            The name of the assembly that this project will create, without file extension.
            </summary>,
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Language">
            <summary>
            The language of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.OutputFilePath">
            <summary>
            The path to the output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.DefaultNamespace">
            <summary>
            The default namespace of the project ("" if not defined, which means global namespace),
            or null if it is unknown or not applicable. 
            </summary>
            <remarks>
            Right now VB doesn't have the concept of "default namespace", but we conjure one in workspace 
            by assigning the value of the project's root namespace to it. So various features can choose to 
            use it for their own purpose.
            In the future, we might consider officially exposing "default namespace" for VB project 
            (e.g. through a "defaultnamespace" msbuild property)
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.IsSubmission">
            <summary>
            True if this is a submission project for interactive sessions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HasAllInformation">
            <summary>
            True if project information is complete. In some workspace hosts, it is possible
            a project only has partial information. In such cases, a project might not have all
            information on its files or references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.RunAnalyzers">
            <summary>
            True if we should run analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.CompilationOptions">
            <summary>
            The initial compilation options for the project, or null if the default options should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ParseOptions">
            <summary>
            The initial parse options for the source code documents in this project, or null if the default options should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.Documents">
            <summary>
            The list of source documents initially associated with the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectReferences">
            <summary>
            The project references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.MetadataReferences">
            <summary>
            The metadata references initially defined for the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AnalyzerReferences">
            <summary>
            The analyzers initially associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AdditionalDocuments">
            <summary>
            The list of non-source documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.AnalyzerConfigDocuments">
            <summary>
            The list of analyzerconfig documents associated with this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.HostObjectType">
            <summary>
            Type of the host object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Boolean,System.Type,System.Boolean,System.Boolean)">
            <summary>
            Create a new instance of a ProjectInfo.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Boolean,System.Type)">
            <summary>
            Create a new instance of a ProjectInfo.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectInfo.Create(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.String,System.String,System.String,System.String,Microsoft.CodeAnalysis.CompilationOptions,Microsoft.CodeAnalysis.ParseOptions,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentInfo},System.Boolean,System.Type,System.String)">
            <summary>
            Create a new instance of a ProjectInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes">
            <summary>
            type that contains information regarding this project itself but
            no tree information such as document info
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Id">
            <summary>
            The unique Id of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Version">
            <summary>
            The version of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Name">
            <summary>
            The name of the project. This may differ from the project's filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.AssemblyName">
            <summary>
            The name of the assembly that this project will create, without file extension.
            </summary>,
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.Language">
            <summary>
            The language of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.FilePath">
            <summary>
            The path to the project file or null if there is no project file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.OutputFilePath">
            <summary>
            The path to the output file (module or assembly).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.OutputRefFilePath">
            <summary>
            The path to the reference assembly output file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.DefaultNamespace">
            <summary>
            The default namespace of the project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.IsSubmission">
            <summary>
            True if this is a submission project for interactive sessions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.HasAllInformation">
            <summary>
            True if project information is complete. In some workspace hosts, it is possible
            a project only has partial information. In such cases, a project might not have all
            information on its files or references.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectInfo.ProjectAttributes.RunAnalyzers">
            <summary>
            True if we should run analyzers for this project.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectReference.Aliases">
            <summary>
            Aliases for the reference. Empty if the reference has no aliases.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ProjectReference.EmbedInteropTypes">
            <summary>
            True if interop types defined in the referenced project should be embedded into the referencing project.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState._documentStates">
            <summary>
            The documents in this project. They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState._additionalDocumentStates">
            <summary>
            The additional documents in this project. They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState._analyzerConfigDocumentStates">
            <summary>
            The analyzer config documents in this project.  They are sorted by <see cref="P:Microsoft.CodeAnalysis.DocumentId.Id"/> to provide a stable sort for
            <see cref="M:Microsoft.CodeAnalysis.ProjectState.GetChecksumAsync(System.Threading.CancellationToken)"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.ProjectState._lazyAnalyzerConfigSet">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigSet"/> to be used for analyzer options for specific trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ProjectState.ContainsReferenceToProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Determines whether <see cref="P:Microsoft.CodeAnalysis.ProjectState.ProjectReferences"/> contains a reference to a specified project.
            </summary>
            <param name="projectId">The target project of the reference.</param>
            <returns><see langword="true"/> if this project references <paramref name="projectId"/>; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.RecoverableTextAndVersion">
            <summary>
            A recoverable TextAndVersion source that saves its text to temporary storage.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Solution">
            <summary>
            Represents a set of projects and their source code documents. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Workspace">
            <summary>
            The Workspace this solution is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Id">
            <summary>
            The Id of the solution. Multiple solution instances may share the same Id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.FilePath">
            <summary>
            The path to the solution file or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Version">
            <summary>
            The solution version. This equates to the solution file's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.ProjectIds">
            <summary>
            A list of all the ids for all the projects contained by the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Projects">
            <summary>
            A list of all the projects contained by the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetLatestProjectVersion">
            <summary>
            The version of the most recently modified project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if the solution contains a project with the specified project ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the project in this solution with the specified project ID. 
            
            If the id is not an id of a project that is part of this solution the method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProject(Microsoft.CodeAnalysis.IAssemblySymbol,System.Threading.CancellationToken)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Project"/> associated with an assembly symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the additional document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the analyzer config document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentId(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the documentId in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the additional document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the analyzer config document in this solution with the specified document ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocument(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets the document in this solution with the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            Returns the new project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectId,System.String,System.String,System.String)">
            <summary>
            Creates a new solution instance that includes a project with the specified language and names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Create a new solution instance that includes a project with the specified project information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Create a new solution instance without the project specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the new
            assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the reference assembly output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectDefaultNamespace(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the project file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectOptionsChanged(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Update a project as a result of option changes.
            
            this is a temporary workaround until editorconfig becomes real part of roslyn solution snapshot.
            until then, this will explicitly fork current solution snapshot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasAllInformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified runAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer
            include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to contain
            the specified list of project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance with the project documents in the order by the specified document ids.
            The specified document ids must be the same as what is already in the project; no adding or removing is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.SyntaxNode,System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            document instance defined by its name and root <see cref="T:Microsoft.CodeAnalysis.SyntaxNode"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.TextLoader,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the project updated to include a new document with
            the arguments specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocument(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Create a new solution instance with the corresponding project updated to include a new 
            document instanced defined by the document info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.Solution"/> instance with the corresponding <see cref="T:Microsoft.CodeAnalysis.Project"/>s updated to include
            the documents specified by <paramref name="documentInfos"/>.
            </summary>
            <returns>A new <see cref="T:Microsoft.CodeAnalysis.Solution"/> with the documents added.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            additional document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            additional document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.String,Microsoft.CodeAnalysis.Text.SourceText,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Creates a new solution instance with the corresponding project updated to include a new
            analyzer config document instance defined by its name and text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.AddAnalyzerConfigDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Creates a new Solution instance that contains a new compiler configuration document like a .editorconfig file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.RemoveAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified additional document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentName(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the new name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentFolders(Microsoft.CodeAnalysis.DocumentId,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the document specified updated to be contained in
            the sequence of logical folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentFilePath(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the specified file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSyntaxRoot(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have a syntax tree
            rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new solution instance with the document specified updated to have the source
            code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithFrozenPartialCompilationIncludingSpecificDocument(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Creates a branch of the solution that has its compilations frozen in whatever state they are in at the time, assuming a background compiler is
            busy building this compilations.
            
            A compilation for the project containing the specified document id will be guaranteed to exist with at least the syntax tree for the document.
            
            This not intended to be the public API, use Document.WithFrozenPartialSemantics() instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetIsolatedSolution">
            <summary>
            Gets a copy of the solution isolated from the original so that they do not share computed state.
            
            Use isolated solutions when doing operations that are likely to access a lot of text,
            syntax trees or compilations that are unlikely to be needed again after the operation is done. 
            When the isolated solution is reclaimed so will the computed state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithDocumentText(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with all the documents specified updated to have the same specified text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetChanges(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Gets an objects that lists the added, changed and removed projects between
            this solution and the specified solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetDocumentIdsWithFilePath(System.String)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s in this <see cref="T:Microsoft.CodeAnalysis.Solution"/> with a
            <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath"/> that matches the given file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.GetProjectDependencyGraph">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> that details the dependencies between projects for this solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Solution.Options">
            <summary>
            Returns the options that should be applied to this solution. This is equivalent to <see cref="P:Microsoft.CodeAnalysis.Workspace.Options" /> when the <see cref="T:Microsoft.CodeAnalysis.Solution"/> 
            instance was created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Creates a new solution instance with the specified <paramref name="options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Solution.WithOptions(Microsoft.CodeAnalysis.Options.SerializableOptionSet)">
            <summary>
            Creates a new solution instance with the specified serializable <paramref name="options"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionId">
            <summary>
            An identifier that can be used to refer to the same Solution across versions. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionId.Id">
            <summary>
            The unique id of the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionId.CreateNewId(System.String)">
            <summary>
            Create a new Solution Id
            </summary>
            <param name="debugName">An optional name to make this id easier to recognize while debugging.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionInfo">
            <summary>
            A class that represents all the arguments necessary to create a new solution instance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Id">
            <summary>
            The unique Id of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Version">
            <summary>
            The version of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.FilePath">
            <summary>
            The path to the solution file, or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.Projects">
            <summary>
            A list of projects initially associated with the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionInfo.Create(Microsoft.CodeAnalysis.SolutionId,Microsoft.CodeAnalysis.VersionStamp,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectInfo})">
            <summary>
            Create a new instance of a SolutionInfo.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes">
            <summary>
            type that contains information regarding this solution itself but
            no tree information such as project info
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.Id">
            <summary>
            The unique Id of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.Version">
            <summary>
            The version of the solution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionInfo.SolutionAttributes.FilePath">
            <summary>
            The path to the solution file, or null if there is no solution file.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionServices">
            <summary>
            This class basically holds onto a set of services and gets reused across solution instances.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState">
            <summary>
            Represents a set of projects and their source code documents. 
            
            this is a green node of Solution like ProjectState/DocumentState are for 
            Project and Document.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker">
            <summary>
            Tracks the changes made to a project and provides the facility to get a lazily built
            compilation for that project.  As the compilation is being built, the partial results are
            stored as well so that they can be used in the 'in progress' workspace snapshot.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState.CompilationTracker._stateDoNotAccessDirectly">
            <summary>
            Access via the <see cref="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.ReadState"/> and <see cref="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.WriteState(Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State,Microsoft.CodeAnalysis.SolutionState)"/> methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.#ctor(Microsoft.CodeAnalysis.ProjectState)">
            <summary>
            Creates a tracker for the provided project.  The tracker will be in the 'empty' state
            and will have no extra information beyond the project itself.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.HasCompilation">
            <summary>
            Returns true if this tracker currently either points to a compilation, has an in-progress
            compilation being computed, or has a skeleton reference.  Note: this is simply a weak
            statement about the tracker at this exact moment in time.  Immediately after this returns
            the tracker might change and may no longer have a final compilation (for example, if the
            retainer let go of it) or might not have an in-progress compilation (for example, if the
            background compiler finished with it).
            
            Because of the above limitations, this should only be used by clients as a weak form of
            information about the tracker.  For example, a client may see that a tracker has no
            compilation and may choose to throw it away knowing that it could be reconstructed at a
            later point if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.Fork(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.SolutionState.CompilationTranslationAction,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of the compilation info, retaining any already built
            compilation state as the now 'old' state
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.Clone">
            <summary>
            Creates a fork with the same final project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.GetPartialCompilationState(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.ProjectState@,Microsoft.CodeAnalysis.Compilation@,System.Threading.CancellationToken)">
            <summary>
            Tries to get the latest snapshot of the compilation without waiting for it to be
            fully built. This method takes advantage of the progress side-effect produced during
            <see cref="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.BuildCompilationInfoAsync(Microsoft.CodeAnalysis.SolutionState,System.Threading.CancellationToken)"/>. It will either return the already built compilation, any
            in-progress compilation or any known old compilation in that order of preference.
            The compilation state that is returned will have a compilation that is retained so
            that it cannot disappear.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.TryGetCompilation(Microsoft.CodeAnalysis.Compilation@)">
            <summary>
            Gets the final compilation if it is available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.BuildCompilationInfoAsync(Microsoft.CodeAnalysis.SolutionState,System.Threading.CancellationToken)">
            <summary>
            Builds the compilation matching the project state. In the process of building, also
            produce in progress snapshots that can be accessed from other threads.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.FinalizeCompilationAsync(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Add all appropriate references to the compilation and set it as our final compilation
            state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectReference,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference to this compilation info's compilation with respect to
            another project. For cross language references produce a skeletal assembly. If the
            compilation is not available, it is built. If a skeletal assembly reference is
            needed and does not exist, it is also built.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.GetPartialMetadataReference(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Attempts to get (without waiting) a metadata reference to a possibly in progress
            compilation. Only actual compilation references are returned. Could potentially 
            return null if nothing can be provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.GetMetadataOnlyImageReferenceAsync(Microsoft.CodeAnalysis.SolutionState,Microsoft.CodeAnalysis.ProjectReference,System.Threading.CancellationToken)">
            <summary>
            Gets a metadata reference to the metadata-only-image corresponding to the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.ContainsSymbolsWithNameFromDeclarationOnlyCompilation(System.String,Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            check whether the compilation contains any declaration symbol from syntax trees with
            given name
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.ContainsSymbolsWithNameFromDeclarationOnlyCompilation(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            check whether the compilation contains any declaration symbol from syntax trees with given name
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.GetSyntaxTreesWithNameFromDeclarationOnlyCompilation(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            get all syntax trees that contain declaration node with the given name
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State">
            <summary>
            The base type of all <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker"/> states. The state of a <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker" />
            starts at <see cref="F:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.Empty"/>, and then will progress through the other states until it finally reaches
            <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.FinalState" />.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.Empty">
            <summary>
            The base <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State"/> that starts with everything empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.DeclarationOnlyCompilation">
            <summary>
            A strong reference to the declaration-only compilation. This compilation isn't used to produce symbols,
            nor does it have any references. It just holds the declaration table alive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.Compilation">
            <summary>
            The best compilation that is available. May be an in-progress, full declaration, a final compilation, or <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.HasSuccessfullyLoaded">
            <summary>
            Specifies whether <see cref="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.FinalCompilation"/> and all compilations it depends on contain full information or not. This can return
            <see langword="null"/> if the state isn't at the point where it would know, and it's necessary to transition to <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.FinalState"/> to figure that out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.FinalCompilation">
            <summary>
            The final compilation if available, otherwise <see langword="null"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.InProgressState">
            <summary>
            A state where we are holding onto a previously built compilation, and have a known set of transformations
            that could get us to a more final state.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.LightDeclarationState">
            <summary>
            Declaration-only state that has no associated references or symbols. just declaration table only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.FullDeclarationState">
            <summary>
            A built compilation for the tracker that contains the fully built DeclarationTable,
            but may not have references initialized
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.FinalState">
            <summary>
            The final state a compilation tracker reaches. The <see cref="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.DeclarationOnlyCompilation"/> is available,
            as well as the real <see cref="P:Microsoft.CodeAnalysis.SolutionState.CompilationTracker.State.FinalCompilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.BranchId">
            <summary>
            branch id of this solution
            
            currently, it only supports one level of branching. there is a primary branch of a workspace and all other
            branches that are branched from the primary branch.
            
            one still can create multiple forked solutions from an already branched solution, but versions among those
            can't be reliably used and compared. 
            
            version only has a meaning between primary solution and branched one or between solutions from same branch.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.Workspace">
            <summary>
            The Workspace this solution is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.Id">
            <summary>
            The Id of the solution. Multiple solution instances may share the same Id.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.FilePath">
            <summary>
            The path to the solution file or null if there is no solution file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.Version">
            <summary>
            The solution version. This equates to the solution file's version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.SolutionState.ProjectIds">
            <summary>
            A list of all the ids for all the projects contained by the solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetLatestProjectVersion">
            <summary>
            The version of the most recently modified project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            True if the solution contains a project with the specified project ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the additional document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ContainsAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            True if the solution contains the analyzer config document in one of its projects
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetProjectState(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.Project"/> associated with an assembly symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddProject(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Create a new solution instance that includes a project with the specified project information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveProject(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Create a new solution instance without the project specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAssemblyName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the new
            assembly name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOutputRefFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the output file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectDefaultNamespace(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the default namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectName(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectFilePath(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Creates a new solution instance with the project specified updated to have the project file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectCompilationOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectParseOptions(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified parse options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectOptionsChanged(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Update a new solution instance with a fork of the specified project.
            
            this is a temporary workaround until editorconfig becomes real part of roslyn solution snapshot.
            until then, this will explicitly fork current solution snapshot
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithHasAllInformation(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified hasAllInformation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithRunAnalyzers(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Create a new solution instance with the project specified updated to have
            the specified runAnalyzers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to include
            the specified project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer
            include the specified project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ProjectReference})">
            <summary>
            Create a new solution instance with the project specified updated to contain
            the specified list of project references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectDocumentsOrder(Microsoft.CodeAnalysis.ProjectId,System.Collections.Immutable.ImmutableList{Microsoft.CodeAnalysis.DocumentId})">
            <summary>
            Creates a new solution instance with the project documents in the order by the specified document ids.
            The specified document ids must be the same as what is already in the project; no adding or removing is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectMetadataReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to include the 
            specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Create a new solution instance with the project specified updated to no longer include
            the specified analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithProjectAnalyzerReferences(Microsoft.CodeAnalysis.ProjectId,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference})">
            <summary>
            Create a new solution instance with the project specified updated to include only the
            specified analyzer references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddDocuments(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Create a new solution instance with the corresponding projects updated to include new 
            documents defined by the document info.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.AddDocumentsToMultipleProjects``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo},System.Func{Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.ProjectState,``0},System.Func{Microsoft.CodeAnalysis.ProjectState,System.Collections.Immutable.ImmutableArray{``0},System.ValueTuple{Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.SolutionState.CompilationTranslationAction}})">
            <summary>
            Core helper that takes a set of <see cref="T:Microsoft.CodeAnalysis.DocumentInfo" />s and does the application of the appropriate documents to each project.
            </summary>
            <param name="documentInfos">The set of documents to add.</param>
            <param name="addDocumentsToProjectState">Returns the new <see cref="T:Microsoft.CodeAnalysis.ProjectState"/> with the documents added, and the <see cref="T:Microsoft.CodeAnalysis.SolutionState.CompilationTranslationAction"/> needed as well.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.RemoveAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Creates a new solution instance that no longer includes the specified additional document.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentName(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentFolders(Microsoft.CodeAnalysis.DocumentId,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates a new solution instance with the document specified updated to be contained in
            the sequence of logical folders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentFilePath(Microsoft.CodeAnalysis.DocumentId,System.String)">
            <summary>
            Creates a new solution instance with the document specified updated to have the specified file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentText(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextAndVersion,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            and version specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentSyntaxRoot(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the document specified updated to have a syntax tree
            rooted by the specified syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentSourceCodeKind(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Creates a new solution instance with the document specified updated to have the source
            code kind specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAdditionalDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the additional document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithAnalyzerConfigDocumentTextLoader(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with the analyzer config document specified updated to have the text
            supplied by the text loader.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.ForkProject(Microsoft.CodeAnalysis.ProjectState,Microsoft.CodeAnalysis.SolutionState.CompilationTranslationAction,Microsoft.CodeAnalysis.ProjectDependencyGraph,System.Collections.Immutable.ImmutableDictionary{System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId}},System.Boolean)">
            <summary>
            Creates a new snapshot with an updated project and an action that will produce a new
            compilation matching the new project out of an old compilation. All dependent projects
            are fixed-up if the change to the new project affects its public metadata, and old
            dependent compilations are forgotten.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetDocumentIdsWithFilePath(System.String)">
            <summary>
            Gets the set of <see cref="T:Microsoft.CodeAnalysis.DocumentId"/>s in this <see cref="T:Microsoft.CodeAnalysis.Solution"/> with a
            <see cref="P:Microsoft.CodeAnalysis.TextDocument.FilePath"/> that matches the given file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetIsolatedSolution">
            <summary>
            Gets a copy of the solution isolated from the original so that they do not share computed state.
            
            Use isolated solutions when doing operations that are likely to access a lot of text,
            syntax trees or compilations that are unlikely to be needed again after the operation is done. 
            When the isolated solution is reclaimed so will the computed state.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithFrozenPartialCompilationIncludingSpecificDocument(Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Creates a branch of the solution that has its compilations frozen in whatever state they are in at the time, assuming a background compiler is
            busy building this compilations.
            
            A compilation for the project containing the specified document id will be guaranteed to exist with at least the syntax tree for the document.
            
            This not intended to be the public API, use Document.WithFrozenPartialSemantics() instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.WithDocumentText(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.DocumentId},Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Creates a new solution instance with all the documents specified updated to have the same specified text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetCompilationAsync(Microsoft.CodeAnalysis.ProjectId,System.Threading.CancellationToken)">
            <summary>
            Returns the compilation for the specified <see cref="T:Microsoft.CodeAnalysis.ProjectId"/>.  Can return <see langword="null"/> when the project
            does not support compilations.
            </summary>
            <remarks>
            The compilation is guaranteed to have a syntax tree for each document of the project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetCompilationAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Returns the compilation for the specified <see cref="T:Microsoft.CodeAnalysis.ProjectState"/>.  Can return <see langword="null"/> when the project
            does not support compilations.
            </summary>
            <remarks>
            The compilation is guaranteed to have a syntax tree for each document of the project.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.HasSuccessfullyLoadedAsync(Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Return reference completeness for the given project and all projects this references.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.SolutionState.s_assemblyOrModuleSymbolToProjectMap">
            <summary>
            Symbols need to be either <see cref="T:Microsoft.CodeAnalysis.IAssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IModuleSymbol"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetMetadataReferenceAsync(Microsoft.CodeAnalysis.ProjectReference,Microsoft.CodeAnalysis.ProjectState,System.Threading.CancellationToken)">
            <summary>
            Get a metadata reference for the project's compilation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetPartialMetadataReference(Microsoft.CodeAnalysis.ProjectReference,Microsoft.CodeAnalysis.ProjectState)">
            <summary>
            Attempt to get the best readily available compilation for the project. It may be a
            partially built compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SolutionState.GetProjectDependencyGraph">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.ProjectDependencyGraph"/> that details the dependencies between projects for this solution.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextAndVersion">
            <summary>
            A class that represents both a source text and its version stamp.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Text">
            <summary>
            The source text.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.Version">
            <summary>
            The version of the source text
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.FilePath">
            <summary>
            An optional file path that identifies the origin of the source text. Empty if not available.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextAndVersion.LoadDiagnostic">
            <summary>
            If an error occurred while loading the text the corresponding diagnostic, otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextAndVersion.Create(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> instance.
            </summary>
            <param name="text">The text</param>
            <param name="version">The version</param>
            <param name="filePath">An optional file path that identifies the original of the source text.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextAndVersion.Create(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.VersionStamp,System.String,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            Create a new <see cref="T:Microsoft.CodeAnalysis.TextAndVersion"/> instance.
            </summary>
            <param name="text">The text</param>
            <param name="version">The version</param>
            <param name="filePath">An optional file path that identifies the original of the source text.</param>
            <param name="loadDiagnostic">Diagnostic describing failure to load the source text.</param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextDifferenceTypes">
            <summary>
            A bitwise combination of the enumeration values to use when computing differences with 
            <see cref="T:Microsoft.CodeAnalysis.IDocumentTextDifferencingService" />. 
            </summary>
            <remarks>
            Since computing differences can be slow with large data sets, you should not use the Character type
            unless the given text is relatively small.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Line">
            <summary>
            Compute the line difference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Word">
            <summary>
            Compute the word difference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDifferenceTypes.Character">
            <summary>
            Compute the character difference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Project">
            <summary>
            The project this document belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Id">
            <summary>
            The document's identifier. Many document instances may share the same ID, but only one
            document in a solution may have that ID.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.FilePath">
            <summary>
            The path to the document file or null if there is no document file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Name">
            <summary>
            The name of the document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Folders">
            <summary>
            The sequence of logical folders the document is contained in.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocument.Services">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.TryGetText(Microsoft.CodeAnalysis.Text.SourceText@)">
            <summary>
            Get the current text for the document if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.TryGetTextVersion(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            Gets the version of the document's text if it is already loaded and available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the current text for the document asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextSynchronously(System.Threading.CancellationToken)">
            <summary>
            Fetches the current text for the document synchronously.
            </summary>
            <remarks>This is internal for the same reason <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeSynchronously(System.Threading.CancellationToken)"/> is internal:
            we have specialized cases where we need it, but we worry that making it public will do more harm than good.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTextVersionSynchronously(System.Threading.CancellationToken)">
            <summary>
            Fetches the current version for the document synchronously.
            </summary>
            <remarks>This is internal for the same reason <see cref="M:Microsoft.CodeAnalysis.Document.GetSyntaxTreeSynchronously(System.Threading.CancellationToken)"/> is internal:
            we have specialized cases where we need it, but we worry that making it public will do more harm than good.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.GetTopLevelChangeTextVersionAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the version of the document's top level signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.HasInfoChanged(Microsoft.CodeAnalysis.TextDocument)">
            <summary>
            True if the info of the document change (name, folders, file path; not the content).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocument.HasTextChanged(Microsoft.CodeAnalysis.TextDocument,System.Boolean)">
            <summary>
            Only checks if the source of the text has changed, no content check is done.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextDocumentKind">
            <summary>
            Indicates kind of a <see cref="T:Microsoft.CodeAnalysis.TextDocument"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.Document">
            <summary>
            Indicates a regular source <see cref="T:Microsoft.CodeAnalysis.Document"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.AdditionalDocument">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.AdditionalDocument"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentKind.AnalyzerConfigDocument">
            <summary>
            Indicates an <see cref="T:Microsoft.CodeAnalysis.AnalyzerConfigDocument"/>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.TextDocumentState.sourceText">
             <summary>
             A direct reference to our source text.  This is only kept around in specialized scenarios.
             Specifically, we keep this around when a document is opened.  By providing this we can allow
             clients to easily get to the text of the document in a non-blocking fashion if that's all
             that they need.
            
             Note: this facility does not extend to getting the version as well.  That's because the
             version of a document depends on both the current source contents and the contents from 
             the previous version of the document.  (i.e. if the contents are the same, then we will
             preserve the same version, otherwise we'll move the version forward).  Because determining
             the version depends on comparing text, and because getting the old text may block, we 
             do not have the ability to know the version of the document up front, and instead can
             only retrieve is asynchronously through <see cref="P:Microsoft.CodeAnalysis.TextDocumentState.TextAndVersionSource"/>.
             </summary> 
        </member>
        <member name="P:Microsoft.CodeAnalysis.TextDocumentState.Services">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.Host.IDocumentServiceProvider"/> associated with this document
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextDocumentState.HasTextChanged(Microsoft.CodeAnalysis.TextDocumentState,System.Boolean)">
            <summary>
            Only checks if the source of the text has changed, no content check is done.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TextLoader">
            <summary>
            A class that represents access to a source text and its version from a storage location.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionAsync(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document.
            </summary>
            <exception cref="T:System.IO.IOException" />
            <exception cref="T:System.IO.InvalidDataException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.LoadTextAndVersionSynchronously(Microsoft.CodeAnalysis.Workspace,Microsoft.CodeAnalysis.DocumentId,System.Threading.CancellationToken)">
            <summary>
            Load a text and a version of the document in the workspace.
            </summary>
            <exception cref="T:System.IO.IOException" />
            <exception cref="T:System.IO.InvalidDataException"/>
            <exception cref="T:System.OperationCanceledException"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.TextAndVersion)">
            <summary>
            Creates a new <see cref="T:Microsoft.CodeAnalysis.TextLoader"/> from an already existing source text and version.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.TextLoader.From(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.VersionStamp,System.String)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.TextLoader"/> from a <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextContainer"/> and version. 
            
            The text obtained from the loader will be the current text of the container at the time
            the loader is accessed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.TreeAndVersion">
            <summary>
            A class that represents both a tree and its top level signature version
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Tree">
            <summary>
            The syntax tree
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.TreeAndVersion.Version">
            <summary>
            The version of the top level signature of the tree
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.VersionStamp">
            <summary>
            VersionStamp should be only used to compare versions returned by same API.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp.s_globalVersion">
            <summary>
            global counter to avoid collision within same session. 
            it starts with a big initial number just for a clarity in debugging
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._utcLastModified">
            <summary>
            time stamp
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._localIncrement">
            <summary>
            indicate whether there was a collision on same item
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.VersionStamp._globalIncrement">
            <summary>
            unique version in same session
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create">
            <summary>
            Creates a new instance of a VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.Create(System.DateTime)">
            <summary>
            Creates a new instance of a version stamp based on the specified DateTime.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion(Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            compare two different versions and return either one of the versions if there is no collision, otherwise, create a new version
            that can be used later to compare versions between different items
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.GetNewerVersion">
            <summary>
            Gets a new VersionStamp that is guaranteed to be newer than its base one
            this should only be used for same item to move it to newer version
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.ToString">
            <summary>
            Returns the serialized text form of the VersionStamp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.CanReusePersistedVersion(Microsoft.CodeAnalysis.VersionStamp,Microsoft.CodeAnalysis.VersionStamp)">
            <summary>
            check whether given persisted version is re-usable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.VersionStamp.TestAccessor.IsNewerThan(Microsoft.CodeAnalysis.VersionStamp@)">
            <summary>
            True if this VersionStamp is newer than the specified one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocumentsWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the source text's container,
            updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContextWithChanges(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Gets the document from the corresponding workspace's current solution that is associated with the source text's container 
            in its current project context, updated to contain the same text as the source if necessary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetRelatedDocuments(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the documents from the corresponding workspace's current solution that are associated with the text container. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.TextExtensions.GetOpenDocumentInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the document from the corresponding workspace's current solution that is associated with the text container 
            in its current project context.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_utf8Encoding">
            <summary>
            Encoding to use when there is no byte order mark (BOM) on the stream. This encoder may throw a <see cref="T:System.Text.DecoderFallbackException"/>
            if the stream contains invalid UTF-8 bytes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Text.EncodedStringText.s_fallbackEncoding">
            <summary>
            Encoding to use when UTF-8 fails. We try to find the following, in order, if available:
                1. The default ANSI codepage
                2. CodePage 1252.
                3. Latin1.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Create(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)">
            <summary>
            Initializes an instance of <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the provided stream. This version differs
            from <see cref="M:Microsoft.CodeAnalysis.Text.SourceText.From(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean)"/> in two ways:
            1. It attempts to minimize allocations by trying to read the stream into a byte array.
            2. If <paramref name="defaultEncoding"/> is null, it will first try UTF8 and, if that fails, it will
               try CodePage 1252. If CodePage 1252 is not available on the system, then it will try Latin1.
            </summary>
            <param name="stream">The stream containing encoded text.</param>
            <param name="defaultEncoding">
            Specifies an encoding to be used if the actual encoding can't be determined from the stream content (the stream doesn't start with Byte Order Mark).
            If not specified auto-detect heuristics are used to determine the encoding. If these heuristics fail the decoding is assumed to be Encoding.Default.
            Note that if the stream starts with Byte Order Mark the value of <paramref name="defaultEncoding"/> is ignored.
            </param>
            <param name="canBeEmbedded">Indicates if the file can be embedded in the PDB.</param>
            <param name="checksumAlgorithm">Hash algorithm used to calculate document checksum.</param>
            <exception cref="T:System.IO.InvalidDataException">
            The stream content can't be decoded using the specified <paramref name="defaultEncoding"/>, or
            <paramref name="defaultEncoding"/> is null and the stream appears to be a binary file.
            </exception>
            <exception cref="T:System.IO.IOException">An IO error occurred while reading from the stream.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.Decode(System.IO.Stream,System.Text.Encoding,Microsoft.CodeAnalysis.Text.SourceHashAlgorithm,System.Boolean,System.Boolean)">
            <summary>
            Try to create a <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> from the given stream using the given encoding.
            </summary>
            <param name="data">The input stream containing the encoded text. The stream will not be closed.</param>
            <param name="encoding">The expected encoding of the stream. The actual encoding used may be different if byte order marks are detected.</param>
            <param name="checksumAlgorithm">The checksum algorithm to use.</param>
            <param name="throwIfBinaryDetected">Throw <see cref="T:System.IO.InvalidDataException"/> if binary (non-text) data is detected.</param>
            <param name="canBeEmbedded">Indicates if the text can be embedded in the PDB.</param>
            <returns>The <see cref="T:Microsoft.CodeAnalysis.Text.SourceText"/> decoded from the stream.</returns>
            <exception cref="T:System.Text.DecoderFallbackException">The decoder was unable to decode the stream with the given encoding.</exception>
            <exception cref="T:System.IO.IOException">Error reading from stream.</exception> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromStream(System.IO.Stream,System.ArraySegment{System.Byte}@)">
            <summary>
            Some streams are easily represented as bytes.
            </summary>
            <param name="data">The stream</param>
            <param name="bytes">The bytes, if available.</param>
            <returns>
            True if the stream's bytes could easily be read, false otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Text.EncodedStringText.TryGetBytesFromFileStream(System.IO.FileStream,System.ArraySegment{System.Byte}@)">
            <summary>
            Read the contents of a FileStream into a byte array.
            </summary>
            <param name="stream">The FileStream with encoded text.</param>
            <param name="bytes">A byte array filled with the contents of the file.</param>
            <returns>True if a byte array could be created.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace">
            <summary>
            A workspace provides access to a active set of source code projects and documents and their
            associated syntax trees, compilations and semantic models. A workspace has a current solution
            that is an immutable snapshot of the projects and documents. This property may change over time
            as the workspace is updated either from live interactions in the environment or via call to the
            workspace's <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.IgnoreUnchangeableDocumentsWhenApplyingChanges">
            <summary>
            Determines whether changes made to unchangeable documents will be silently ignored or cause exceptions to be thrown
            when they are applied to workspace via <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker)"/>. 
            A document is unchangeable if <see cref="P:Microsoft.CodeAnalysis.Host.IDocumentOperationService.CanApplyChange"/> is false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.#ctor(Microsoft.CodeAnalysis.Host.HostServices,System.String)">
            <summary>
            Constructs a new workspace instance.
            </summary>
            <param name="host">The <see cref="T:Microsoft.CodeAnalysis.Host.HostServices"/> this workspace uses</param>
            <param name="workspaceKind">A string that can be used to identify the kind of workspace. Usually this matches the name of the class.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetTestLogger(System.Action{System.String})">
            <summary>
            Sets an internal logger that will receive some messages.
            </summary>
            <param name="writeLineMessageLogger">An action called to write a single line to the log.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Services">
            <summary>
            Services provider by the host for implementing workspace features.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.PrimaryBranchId">
            <summary>
            primary branch id that current solution has
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.PartialSemanticsEnabled">
            <summary>
            Override this property if the workspace supports partial semantics for documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Kind">
            <summary>
            The kind of the workspace.
            This is generally <see cref="F:Microsoft.CodeAnalysis.WorkspaceKind.Host"/> if originating from the host environment, but may be
            any other name used for a specific kind of workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionInfo,Microsoft.CodeAnalysis.Options.SerializableOptionSet)">
            <summary>
            Create a new empty solution instance associated with this workspace, and with the given options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CreateSolution(Microsoft.CodeAnalysis.SolutionId)">
            <summary>
            Create a new empty solution instance associated with this workspace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution">
             <summary>
             The current solution.
            
             The solution is an immutable model of the current set of projects and source documents.
             It provides access to source text, syntax trees and semantics.
            
             This property may change as the workspace reacts to changes in the environment or
             after <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> is called.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetCurrentSolution(Microsoft.CodeAnalysis.Solution)">
            <summary>
            Sets the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> of this workspace. This method does not raise a <see cref="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged"/> event.
            </summary>
            <remarks>
            This method does not guarantee that linked files will have the same contents. Callers
            should enforce that policy before passing in the new solution.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.Options">
            <summary>
            Gets or sets the set of all global options and <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            Setter also force updates the <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> to have the updated <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetOptions(Microsoft.CodeAnalysis.Options.OptionSet)">
            <summary>
            Sets global options and <see cref="P:Microsoft.CodeAnalysis.Workspace.Options"/> to have the new options.
            NOTE: This method also updates <see cref="P:Microsoft.CodeAnalysis.Workspace.CurrentSolution"/> to a new solution instance with updated <see cref="P:Microsoft.CodeAnalysis.Solution.Options"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask(System.Action,System.String)">
            <summary>
            Executes an action as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ScheduleTask``1(System.Func{``0},System.String)">
            <summary>
            Execute a function as a background task, as part of a sequential queue of tasks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.Document)">
            <summary>
            Override this method to act immediately when the text of a document has changed, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentClosing(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Override this method to act immediately when a document is closing, as opposed
            to waiting for the corresponding workspace changed event to fire asynchronously.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolution">
            <summary>
            Clears all solution data and empties the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearSolutionData">
             <summary>
             This method is called when a solution is cleared.
            
             Override this method if you want to do additional work when a solution is cleared.
             Call the base method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearProjectData(Microsoft.CodeAnalysis.ProjectId)">
             <summary>
             This method is called when an individual project is removed.
            
             Override this method if you want to do additional work when a project is removed.
             Call the base method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ClearDocumentData(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called to clear an individual document is removed.
            
             Override this method if you want to do additional work when a document is removed.
             Call the base method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose">
            <summary>
            Disposes this workspace. The workspace can longer be used after it is disposed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.Dispose(System.Boolean)">
             <summary>
             Call this method when the workspace is disposed.
            
             Override this method to do additional work when the workspace is disposed.
             Call this method at the end of your method.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionAdded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionReloaded(Microsoft.CodeAnalysis.SolutionInfo)">
            <summary>
            Call this method to respond to a solution being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnSolutionRemoved">
             <summary>
             This method is called when the solution is removed from the workspace.
            
             Override this method if you want to do additional work when the solution is removed.
             Call the base method at the end of your method.
             Call this method to respond to a solution being removed/cleared/closed in the host environment.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectAdded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being added/opened in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReloaded(Microsoft.CodeAnalysis.ProjectInfo)">
            <summary>
            Call this method to respond to a project being reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectRemoved(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Call this method to respond to a project being removed from the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectCanBeRemoved(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Currently projects can always be removed, but this method still exists because it's protected and we don't
            want to break people who may have derived from <see cref="T:Microsoft.CodeAnalysis.Workspace"/> and either called it, or overridden it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAssemblyNameChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's assembly name is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnOutputFilePathChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's output file path is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnOutputRefFilePathChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's output ref file path is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectNameChanged(Microsoft.CodeAnalysis.ProjectId,System.String,System.String)">
            <summary>
            Call this method when a project's name is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDefaultNamespaceChanged(Microsoft.CodeAnalysis.ProjectId,System.String)">
            <summary>
            Call this method when a project's default namespace is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnCompilationOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
            <summary>
            Call this method when a project's compilation options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnParseOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
            <summary>
            Call this method when a project's parse options are changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Call this method when a project reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnMetadataReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Call this method when a metadata reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Call this method when an analyzer reference is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnHasAllInformationChanged(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Call this method when status of project has changed to incomplete.
            See <see cref="P:Microsoft.CodeAnalysis.ProjectInfo.HasAllInformation"/> for more information.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnRunAnalyzersChanged(Microsoft.CodeAnalysis.ProjectId,System.Boolean)">
            <summary>
            Call this method when a project's RunAnalyzers property is changed in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentsAdded(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentInfo})">
            <summary>
            Call this method when multiple document are added to one or more projects in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentReloaded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when a document is reloaded in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when a document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a additional document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentTextLoaderChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.TextLoader)">
            <summary>
            Call this method when the text of a analyzer config document is changed on disk.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentInfoChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when the document info changes, such as the name, folders or file path.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of a document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of an additional document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode)">
            <summary>
            Call this method when the text of an analyzer config document is updated in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnyDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode,System.Action{Microsoft.CodeAnalysis.DocumentId},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.DocumentId}},System.Func{Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.PreservationMode,Microsoft.CodeAnalysis.Solution},Microsoft.CodeAnalysis.WorkspaceChangeKind,System.Boolean)">
            <summary>
            When a <see cref="T:Microsoft.CodeAnalysis.Document"/>s text is changed, we need to make sure all of the linked
            files also have their content updated in the new solution before applying it to the
            workspace to avoid the workspace having solutions with linked files where the contents
            do not match.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentSourceCodeKindChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.SourceCodeKind)">
            <summary>
            Call this method when the SourceCodeKind of a document changes in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when an additional document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAdditionalDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when an additional document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo)">
            <summary>
            Call this method when an analyzer config document is added to a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnAnalyzerConfigDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when an analyzer config document is removed from a project in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UpdateReferencesAfterAdd">
            <summary>
            Updates all projects to properly reference other projects as project references instead of metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)">
            <summary>
            Determines if the specific kind of change is supported by the <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CanAddProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Returns <see langword="true"/> if a reference to referencedProject can be added to
            referencingProject.  <see langword="false"/> otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)">
             <summary>
             Apply changes made to a solution back to the workspace.
            
             The specified solution must be one that originated from this workspace. If it is not, or the workspace
             has been updated since the solution was obtained from the workspace, then this method returns false. This method
             will still throw if the solution contains changes that are not supported according to the <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/>
             method.
             </summary>
             <exception cref="T:System.NotSupportedException">Thrown if the solution contains changes not supported according to the
             <see cref="M:Microsoft.CodeAnalysis.Workspace.CanApplyChange(Microsoft.CodeAnalysis.ApplyChangesKind)"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectChanges(Microsoft.CodeAnalysis.ProjectChanges)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> for each project
             that has been added, removed or changed.
            
             Override this method if you want to modify how project changes are applied.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectAdded(Microsoft.CodeAnalysis.ProjectInfo)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a project to the current solution.
            
             Override this method to implement the capability of adding projects.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectRemoved(Microsoft.CodeAnalysis.ProjectId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a project from the current solution.
            
             Override this method to implement the capability of removing projects.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyCompilationOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.CompilationOptions)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to change the compilation options.
            
             Override this method to implement the capability of changing compilation options.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyParseOptionsChanged(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ParseOptions)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to change the parse options.
            
             Override this method to implement the capability of changing parse options.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a project reference to a project.
            
             Override this method to implement the capability of adding project references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyProjectReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a project reference from a project.
            
             Override this method to implement the capability of removing project references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyMetadataReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a metadata reference to a project.
            
             Override this method to implement the capability of adding metadata references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyMetadataReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a metadata reference from a project.
            
             Override this method to implement the capability of removing metadata references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerReferenceAdded(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add an analyzer reference to a project.
            
             Override this method to implement the capability of adding analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerReferenceRemoved(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an analyzer reference from a project.
            
             Override this method to implement the capability of removing analyzer references.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new document to a project.
            
             Override this method to implement the capability of adding documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove a document from a project.
            
             Override this method to implement the capability of removing documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of a document.
            
             Override this method to implement the capability of changing document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyDocumentInfoChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.DocumentInfo)">
             <summary>
             This method is called to change the info of a document.
            
             Override this method to implement the capability of changing a document's info.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new additional document to a project.
            
             Override this method to implement the capability of adding additional documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an additional document from a project.
            
             Override this method to implement the capability of removing additional documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAdditionalDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of an additional document.
            
             Override this method to implement the capability of changing additional document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentAdded(Microsoft.CodeAnalysis.DocumentInfo,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to add a new analyzer config document to a project.
            
             Override this method to implement the capability of adding analyzer config documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentRemoved(Microsoft.CodeAnalysis.DocumentId)">
             <summary>
             This method is called during <see cref="M:Microsoft.CodeAnalysis.Workspace.TryApplyChanges(Microsoft.CodeAnalysis.Solution)"/> to remove an analyzer config document from a project.
            
             Override this method to implement the capability of removing analyzer config documents.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.ApplyAnalyzerConfigDocumentTextChanged(Microsoft.CodeAnalysis.DocumentId,Microsoft.CodeAnalysis.Text.SourceText)">
             <summary>
             This method is called to change the text of an analyzer config document.
            
             Override this method to implement the capability of changing analyzer config document text.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckSolutionIsEmpty">
            <summary>
            Throws an exception is the solution is not empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if the project is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectIsNotInCurrentSolution(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception is the project is part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project does not have a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectReference)">
            <summary>
            Throws an exception if a project already has a specific project reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveTransitiveProjectReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Throws an exception if project has a transitive reference to another project.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project does not have a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveMetadataReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Throws an exception if a project already has a specific metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectHasAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project does not have a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckProjectDoesNotHaveAnalyzerReference(Microsoft.CodeAnalysis.ProjectId,Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference)">
            <summary>
            Throws an exception if a project already has a specific analyzer reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAdditionalDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an additional document is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAnalyzerConfigDocumentIsInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an analyzer config is not part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if a document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAdditionalDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if an additional document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CheckAnalyzerConfigDocumentIsNotInCurrentSolution(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Throws an exception if the analyzer config document is already part of the current solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetProjectName(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets the name to use for a project in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for a document in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetAdditionalDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for an additional document in an error message.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetAnalyzerConfigDocumentName(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Gets the name to use for an analyzer document in an error message.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Workspace.TextTracker">
            <summary>
            A class that responds to text buffer changes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._bufferToDocumentInCurrentContextMap">
            <summary>
            Tracks the document ID in the current context for a source text container for an opened text buffer.
            </summary>
            <remarks>For each entry in this map, there must be a corresponding entry in <see cref="F:Microsoft.CodeAnalysis.Workspace._bufferToAssociatedDocumentsMap"/> where the document ID in current context is one of associated document IDs.</remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Workspace._bufferToAssociatedDocumentsMap">
            <summary>
            Tracks all the associated document IDs for a source text container for an opened text buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanOpenDocuments">
            <summary>
            True if this workspace supports manually opening and closing documents.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Workspace.CanChangeActiveContextDocument">
            <summary>
            True if this workspace supports manually changing the active context document of a text buffer by calling <see cref="M:Microsoft.CodeAnalysis.Workspace.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId)" />.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenAdditionalDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified additional document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseAdditionalDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified additional document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OpenAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId,System.Boolean)">
            <summary>
            Open the specified analyzer config document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.CloseAnalyzerConfigDocument(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Close the specified analyzer config document in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.IsDocumentOpen(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Determines if the document is currently open in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetOpenDocumentIds(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Gets a list of the currently opened documents.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetRelatedDocumentIds(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the ids for documents associated with a text container.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Gets the id for the document associated with the given text container in its current context.
            Documents are normally associated with a text container when the documents are opened.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Finds the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> related to the given <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> that
            is in the current context. If the <see cref="T:Microsoft.CodeAnalysis.DocumentId"/> is currently closed, then 
            it is returned directly. If it is open, then this returns the same result that 
            <see cref="M:Microsoft.CodeAnalysis.Workspace.GetDocumentIdInCurrentContext(Microsoft.CodeAnalysis.Text.SourceTextContainer)"/> would return for the
            <see cref="T:Microsoft.CodeAnalysis.Text.SourceTextContainer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.SetDocumentContext(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method to tell the host environment to change the current active context to this document. Only supported if
            <see cref="P:Microsoft.CodeAnalysis.Workspace.CanChangeActiveContextDocument"/> returns true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnDocumentContextUpdated(Microsoft.CodeAnalysis.DocumentId)">
            <summary>
            Call this method when a document has been made the active context in the host environment.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UpdateCurrentContextMapping_NoLock(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.DocumentId)">
            <returns>The DocumentId of the current context document attached to the textContainer, if any.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.AdjustReloadedSolution(Microsoft.CodeAnalysis.Solution,Microsoft.CodeAnalysis.Solution)">
            <summary>
             This method is called during OnSolutionReload.  Override this method if you want to manipulate
             the reloaded solution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.OnProjectOptionsChanged(Microsoft.CodeAnalysis.ProjectId)">
            <summary>
            Update a project as a result of option changes.
            
            this is a temporary workaround until editorconfig becomes real part of roslyn solution snapshot.
            until then, this will explicitly move current solution forward when such event happened
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceChanged">
            <summary>
            An event raised whenever the current solution is changed.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.WorkspaceFailed">
            <summary>
            An event raised whenever the workspace or part of its solution model
            fails to access a file or other external resource.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentOpened">
            <summary>
            An event that is fired when a documents is opened in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentClosed">
            <summary>
            An event that is fired when a document is closed in the editor.
            </summary>
        </member>
        <member name="E:Microsoft.CodeAnalysis.Workspace.DocumentActiveContextChanged">
            <summary>
            An event that is fired when the active context document associated with a buffer 
            changes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.TryGetWorkspace(Microsoft.CodeAnalysis.Text.SourceTextContainer,Microsoft.CodeAnalysis.Workspace@)">
            <summary>
            Gets the workspace associated with the specific text container.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.RegisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Register a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.UnregisterText(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Unregister a correspondence between a text container and a workspace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Workspace.GetWorkspaceRegistration(Microsoft.CodeAnalysis.Text.SourceTextContainer)">
            <summary>
            Returns a <see cref="T:Microsoft.CodeAnalysis.WorkspaceRegistration" /> for a given text container.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs">
            <summary>
            The <see cref="T:System.EventArgs"/> describing any kind of workspace change.
            </summary>
            <remarks>
            When linked files are edited, one document change event is fired per linked file. All of
            these events contain the same <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/>, and they all contain the same
            <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>. This is so that we can trigger document change events on all
            affected documents without reporting intermediate states in which the linked file contents
            do not match.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution">
            <remarks>
            If linked documents are being changed, there may be multiple events with the same
            <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/> and <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution">
            <remarks>
            If linked documents are being changed, there may be multiple events with the same
            <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.OldSolution"/> and <see cref="P:Microsoft.CodeAnalysis.WorkspaceChangeEventArgs.NewSolution"/>.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionChanged">
            <summary>
            The current solution changed for an unspecified reason.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionAdded">
            <summary>
            A solution was added to the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionRemoved">
            <summary>
            The current solution was removed from the workspace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionCleared">
            <summary>
            The current solution was cleared of all projects and documents.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.SolutionReloaded">
            <summary>
            The current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectAdded">
            <summary>
            A project was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectRemoved">
            <summary>
            A project was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectChanged">
            <summary>
            A project in the current solution was changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.ProjectReloaded">
            <summary>
            A project in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentAdded">
            <summary>
            A document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentRemoved">
            <summary>
            A document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentReloaded">
            <summary>
            A document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged">
            <summary>
            A document in the current solution was changed.
            </summary>
            <remarks>
            When linked files are edited, one <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged"/> event is fired per
            linked file. All of these events contain the same OldSolution, and they all contain
            the same NewSolution. This is so that we can trigger document change events on all
            affected documents without reporting intermediate states in which the linked file
            contents do not match. Each <see cref="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentChanged"/> event does not represent
            an incremental update from the previous event in this special case.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentAdded">
            <summary>
            An additional document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentRemoved">
            <summary>
            An additional document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentReloaded">
            <summary>
            An additional document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AdditionalDocumentChanged">
            <summary>
            An additional document in the current solution was changed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.DocumentInfoChanged">
            <summary>
            The document in the current solution had is info changed; name, folders, filepath
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentAdded">
            <summary>
            An analyzer config document was added to the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentRemoved">
            <summary>
            An analyzer config document was removed from the current solution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentReloaded">
            <summary>
            An analyzer config document in the current solution was reloaded.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.WorkspaceChangeKind.AnalyzerConfigDocumentChanged">
            <summary>
            An analyzer config document in the current solution was changed.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.WorkspaceKind">
            <summary>
             Known workspace kinds
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.DesktopAnalyzerAssemblyLoader">
            <summary>
            Loads analyzer assemblies from their original locations in the file system.
            Assemblies will only be loaded from the locations specified when the loader
            is instantiated.
            </summary>
            <remarks>
            This type is meant to be used in scenarios where it is OK for the analyzer
            assemblies to be locked on disk for the lifetime of the host; for example,
            csc.exe and vbc.exe. In scenarios where support for updating or deleting
            the analyzer on disk is required a different loader should be used.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``2(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1})">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ArrayBuilderExtensions.SelectAsArray``3(Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an array builder to immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Create(System.Int32)">
            <summary>
            Create BitArray with at least the specified number of bits.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.AllSet(System.Int32)">
            <summary>
            return a bit array with all bits set from index 0 through bitCount-1
            </summary>
            <param name="capacity"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.Clone">
            <summary>
            Make a copy of a bit array.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.BitVector.IsNull">
            <summary>
            Is the given bit array null?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.IntersectWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by bitwise AND-ing each element with the other bit vector.
            For the purposes of the intersection, any bits beyond the current length will be treated as zeroes.
            Return true if any changes were made to the bits of this bit vector.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.BitVector.UnionWith(Microsoft.CodeAnalysis.BitVector@)">
            <summary>
            Modify this bit vector by '|'ing each element with the other bit vector.
            </summary>
            <returns>
            True if any bits were set as a result of the union.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.ImmutableArrayExtensions">
            <summary>
            The collection of extension methods for the <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <exception cref="T:System.ArgumentNullException">If items is null (default)</exception>
            <remarks>If the sequence is null, this will throw <see cref="T:System.ArgumentNullException"/></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return an empty array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Converts a sequence to an immutable array.
            </summary>
            <typeparam name="T">Elemental type of the sequence.</typeparam>
            <param name="items">The sequence to convert.</param>
            <returns>An immutable copy of the contents of the sequence.</returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutable``1(``0[])">
            <summary>
            Converts an array to an immutable array. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrNull``1(``0[])">
            <summary>
            Converts a array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns></returns>
            <remarks>If the sequence is null, this will return the default (null) array.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.AsImmutableOrEmpty``1(``0[])">
            <summary>
            Converts an array to an immutable array.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items">The sequence to convert</param>
            <returns>If the array is null, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ToImmutable(System.IO.MemoryStream)">
            <summary>
            Reads bytes from specified <see cref="T:System.IO.MemoryStream"/>.
            </summary>
            <param name="stream">The stream.</param>
            <returns>Read-only content of the stream.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1})">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The array to map</param>
            <param name="map">The mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,``1,``2},``1)">
            <summary>
            Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Int32,``1,``2},``1)">
            <summary>
             Maps an immutable array to another immutable array.
            </summary>
            <typeparam name="TItem"></typeparam>
            <typeparam name="TArg"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="items">The sequence to map</param>
            <param name="map">The mapping delegate</param>
            <param name="arg">The extra input used by mapping delegate</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SelectAsArray``2(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Maps a subset of immutable array to another immutable array.
            </summary>
            <typeparam name="TItem">Type of the source array items</typeparam>
            <typeparam name="TResult">Type of the transformed array items</typeparam>
            <param name="array">The array to transform</param>
            <param name="predicate">The condition to use for filtering the array content.</param>
            <param name="selector">A transform function to apply to each element that is not filtered out by <paramref name="predicate"/>.</param>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.ZipAsArray``3(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``1},System.Func{``0,``1,``2})">
            <summary>
            Zips two immutable arrays together through a mapping function, producing another immutable array.
            </summary>
            <returns>If the items's length is 0, this will return an empty immutable array.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.WhereAsArray``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>
            Creates a new immutable array based on filtered elements by the predicate. The array must not be null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array">The array to process</param>
            <param name="predicate">The delegate that defines the conditions of the element to search for.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Cast``2(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Casts the immutable array of a Type to an immutable array of its base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.SetEquals``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether this instance and another immutable array are equal.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="array1"></param>
            <param name="array2"></param>
            <param name="comparer">The comparer to determine if the two arrays are equal.</param>
            <returns>True if the two arrays are equal</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.NullToEmpty``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an empty array if the input array is null (default)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ImmutableArrayExtensions.Distinct``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns an array of distinct elements, preserving the order in the original array.
            If the array has no duplicates, the original array is returned. The original array must not be null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2">
            <summary>
            A MultiDictionary that allows only adding, and preserves the order of values added to the 
            dictionary. Thread-safe for reading, but not for adding.
            </summary>
            <remarks>
            Always uses the default comparer.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Add(`0,`1)">
            <summary>
            Add a value to the dictionary.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Item(`0)">
            <summary>
            Get all values associated with K, in the order they were added.
            Returns empty read-only array if no values were present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.Keys">
            <summary>
            Get a collection of all the keys.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2.ValueSet._value">
            <summary>
            Each value is either a single V or an <see cref="T:Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1"/>.
            Never null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.RelativePathResolver.#ctor(System.Collections.Immutable.ImmutableArray{System.String},System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.RelativePathResolver"/> class.
            </summary>
            <param name="searchPaths">An ordered set of fully qualified 
            paths which are searched when resolving assembly names.</param>
            <param name="baseDirectory">Directory used when resolving relative paths.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.FailFast.Assert(System.Boolean,System.String)">
            <summary>
            Checks for the given <paramref name="condition"/>; if the <paramref name="condition"/> is <c>true</c>, 
            immediately terminates the process without running any pending <c>finally</c> blocks or finalizers
            and causes a crash dump to be collected (if the system is configured to do so). 
            Otherwise, the process continues normally.
            </summary>
            <param name="condition">The conditional expression to evaluate.</param>
            <param name="message">An optional message to be recorded in the dump in case of failure. Can be <c>null</c>.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler">
            <summary>
            Set by the host to a fail fast trigger, 
            if the host desires to crash the process on a fatal exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler">
            <summary>
            Set by the host to a fail fast trigger, 
            if the host desires to NOT crash the process on a non fatal exception.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessCanceled(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error. 
            Unless the exception is <see cref="T:System.OperationCanceledException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>. The exception is passed through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrashUnlessCanceled(System.Exception)">
            <summary>
            Use in an exception filter to report a non fatal error. 
            Unless the exception is <see cref="T:System.OperationCanceledException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler"/>. The exception isn't passed through (the method returns true).
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportUnlessNotImplemented(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error. 
            Unless the exception is <see cref="T:System.NotImplementedException"/> 
            it calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/>. The exception is passed through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Report(System.Exception)">
            <summary>
            Use in an exception filter to report a fatal error.
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.Handler"/> and passes the exception through (the method returns false).
            </summary>
            <returns>False to avoid catching the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrash(System.Exception)">
            <summary>
            Report a non-fatal error.
            Calls <see cref="P:Microsoft.CodeAnalysis.ErrorReporting.FatalError.NonFatalHandler"/> and doesn't pass the exception through (the method returns true).
            This is generally expected to be used within an exception filter as that allows us to
            capture data at the point the exception is thrown rather than when it is handled.
            However, it can also be used outside of an exception filter. If the exception has not
            already been thrown the method will throw and catch it itself to ensure we get a useful
            stack trace.
            </summary>
            <returns>True to catch the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrashAndPropagate(System.Exception)">
            <summary>
            Report a non-fatal error like <see cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrash(System.Exception)"/> but propagates the exception.
            </summary>
            <returns>False to propagate the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrashUnlessCanceledAndPropagate(System.Exception)">
            <summary>
            Report a non-fatal error like <see cref="M:Microsoft.CodeAnalysis.ErrorReporting.FatalError.ReportWithoutCrash(System.Exception)"/> but propagates the exception.
            </summary>
            <returns>False to propagate the exception.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.StackGuard.EnsureSufficientExecutionStack(System.Int32)">
            <summary>
                Ensures that the remaining stack space is large enough to execute
                the average function.
            </summary>
            <param name="recursionDepth">how many times the calling function has recursed</param>
            <exception cref="T:System.InsufficientExecutionStackException">
                The available stack space is insufficient to execute
                the average function.
            </exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.VerifySource(Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Text.TextChangeRange})">
            <summary>
            Verify nodes match source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.FindFirstDifference(System.String,System.String)">
            <summary>
            Return the index of the first difference between
            the two strings, or -1 if the strings are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.SyntaxTreeExtensions.IsHiddenPosition(Microsoft.CodeAnalysis.SyntaxTree,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Returns <c>true</c> if the provided position is in a hidden region inaccessible to the user.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AnnotationTable`1">
            <summary>
            An AnnotationTable helps you attach your own annotation types/instances to syntax.  
            
            It maintains a map between your instances and actual SyntaxAnnotation's used to annotate the nodes
            and offers an API that matches the true annotation API on SyntaxNode.
            
            The table controls the lifetime of when you can find and retrieve your annotations. You won't be able to 
            find your annotations via HasAnnotations/GetAnnotations unless you use the same annotation table for these operations
            that you used for the WithAdditionalAnnotations operation.  
            
            Your custom annotations are not serialized with the syntax tree, so they won't move across boundaries unless the 
            same AnnotationTable is available on both ends.
            
            also, note that this table is not thread safe.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1">
            <summary>
            Represents a value that can be retrieved synchronously or asynchronously by many clients.
            The value will be computed on-demand the moment the first client asks for it. While being
            computed, more clients can request the value. As long as there are outstanding clients the
            underlying computation will proceed.  If all outstanding clients cancel their request then
            the underlying value computation will be cancelled as well.
            
            Creators of an <see cref="T:Roslyn.Utilities.AsyncLazy`1" /> can specify whether the result of the computation is
            cached for future requests or not. Choosing to not cache means the computation functions are kept
            alive, whereas caching means the value (but not functions) are kept alive once complete.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._asynchronousComputeFunction">
            <summary>
            The underlying function that starts an asynchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it.  Otherwise,
            it is kept around in case the value needs to be computed again.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._synchronousComputeFunction">
            <summary>
            The underlying function that starts a synchronous computation of the resulting value.
            Null'ed out once we've computed the result and we've been asked to cache it, or if we
            didn't get any synchronous function given to us in the first place.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._cacheResult">
            <summary>
            Whether or not we should keep the value around once we've computed it.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._cachedResult">
            <summary>
            The Task that holds the cached result.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.s_gate">
            <summary>
            Mutex used to protect reading and writing to all mutable objects and fields.  Traces
            indicate that there's negligible contention on this lock, hence we can save some memory
            by using a single lock for all AsyncLazy instances.  Only trivial and non-reentrant work
            should be done while holding the lock.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._requests">
            <summary>
            The hash set of all currently outstanding asynchronous requests. Null if there are no requests,
            and will never be empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._asynchronousComputationCancellationSource">
            <summary>
            If an asynchronous request is active, the CancellationTokenSource that allows for
            cancelling the underlying computation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1._computationActive">
            <summary>
            Whether a computation is active or queued on any thread, whether synchronous or
            asynchronous.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(`0)">
            <summary>
            Creates an AsyncLazy that always returns the value, analogous to <see cref="M:System.Threading.Tasks.Task.FromResult``1(``0)" />.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.#ctor(System.Func{System.Threading.CancellationToken,System.Threading.Tasks.Task{`0}},System.Func{System.Threading.CancellationToken,`0},System.Boolean)">
            <summary>
            Creates an AsyncLazy that supports both asynchronous computation and inline synchronous
            computation.
            </summary>
            <param name="asynchronousComputeFunction">A function called to start the asynchronous
            computation. This function should be cheap and non-blocking.</param>
            <param name="synchronousComputeFunction">A function to do the work synchronously, which
            is allowed to block. This function should not be implemented by a simple Wait on the
            asynchronous value. If that's all you are doing, just don't pass a synchronous function
            in the first place.</param>
            <param name="cacheResult">Whether the result should be cached once the computation is
            complete.</param>
        </member>
        <member name="M:Roslyn.Utilities.AsyncLazy`1.TakeLock(System.Threading.CancellationToken)">
            <summary>
            Takes the lock for this object and if acquired validates the invariants of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.AsyncLazy`1.Request">
            <remarks>
            This inherits from <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> to avoid allocating two objects when we can just use one.
            The public surface area of <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> should probably be avoided in favor of the public
            methods on this class for correct behavior.
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.AsyncLazy`1.Request._cancellationToken">
            <summary>
            The <see cref="T:System.Threading.CancellationToken"/> associated with this request. This field will be initialized before
            any cancellation is observed from the token.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.BKTree">
             <summary>
             NOTE: Only use if you truly need a BK-tree.  If you just want to compare words, use
             the <see cref="T:Roslyn.Utilities.SpellChecker"/> type instead.
            
             An implementation of a Burkhard-Keller tree.  Introduced in:
             
             'Some approaches to best-match file searching.'
             Communications of the ACM CACM
             Volume 16 Issue 4, April 1973 
             Pages 230-236 
             http://dl.acm.org/citation.cfm?doid=362003.362025
             </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Edge.ChildNodeIndex">
            <summary>Where the child node can be found in <see cref="F:Roslyn.Utilities.BKTree._nodes"/>.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.WordSpan">
            <summary>
            The string this node corresponds to.  Specifically, this span is the range of
            <see cref="F:Roslyn.Utilities.BKTree._concatenatedLowerCaseWords"/> for that string.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.EdgeCount">
            <summary>How many child edges this node has.</summary>
        </member>
        <member name="F:Roslyn.Utilities.BKTree.Node.FirstEdgeIndex">
            <summary>Where the first edge can be found in <see cref="F:Roslyn.Utilities.BKTree._edges"/>.  The edges 
            are in the range _edges[FirstEdgeIndex, FirstEdgeIndex + EdgeCount)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ImmutableHashMapExtensions.GetOrAdd``3(Roslyn.Collections.Immutable.ImmutableHashMap{``0,``1}@,``0,System.Func{``0,``2,``1},``2)">
            <summary>
            Obtains the value for the specified key from a dictionary, or adds a new value to the dictionary where the key did not previously exist.
            </summary>
            <typeparam name="TKey">The type of key stored by the dictionary.</typeparam>
            <typeparam name="TValue">The type of value stored by the dictionary.</typeparam>
            <typeparam name="TArg">The type of argument supplied to the value factory.</typeparam>
            <param name="location">The variable or field to atomically update if the specified <paramref name="key" /> is not in the dictionary.</param>
            <param name="key">The key for the value to retrieve or add.</param>
            <param name="valueFactory">The function to execute to obtain the value to insert into the dictionary if the key is not found.</param>
            <param name="factoryArgument">The argument to pass to the value factory.</param>
            <returns>The value obtained from the dictionary or <paramref name="valueFactory" /> if it was not present.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfNull``1(``0,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is null.  This method executes in
            all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfFalse(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is false.  This method executes
            in all builds
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Contract.ThrowIfTrue(System.Boolean,System.String)">
            <summary>
            Throws a non-accessible exception if the provided value is true. This method executes in
            all builds.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.EditDistance">
            <summary>
             NOTE: Only use if you truly need an edit distance.  If you just want to compare words, use
             the <see cref="T:Roslyn.Utilities.SpellChecker"/> type instead.
            
             Implementation of the Damerau-Levenshtein edit distance algorithm from:
             An Extension of the String-to-String Correction Problem:
             Published in Journal of the ACM (JACM)
             Volume 22 Issue 2, April 1975.
            
             Important, unlike many edit distance algorithms out there, this one implements a true metric
             that satisfies the triangle inequality.  (Unlike the "Optimal String Alignment" or "Restricted
             string edit distance" solutions which do not).  This means this edit distance can be used in
             other domains that require the triangle inequality (like BKTrees).
            
             Specifically, this implementation satisfies the following inequality: D(x, y) + D(y, z) >= D(x, z)
             (where D is the edit distance).
            </summary> 
        </member>
        <member name="T:Roslyn.Utilities.IReferenceCountedDisposable`1">
            <summary>
            A covariant interface form of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> that lets you re-cast an <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>
            to a more base type. This can include types that do not implement <see cref="T:System.IDisposable"/> if you want to prevent a caller from accidentally
            disposing <see cref="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target"/> directly.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Roslyn.Utilities.IReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:System.IDisposable.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:System.IDisposable.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:System.IDisposable.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:System.IDisposable.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.IReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``1(``0@,System.Func{``0})">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <returns>The target value.</returns>
        </member>
        <member name="M:Roslyn.Utilities.LazyInitialization.EnsureInitialized``2(``0@,System.Func{``1,``0},``1)">
            <summary>
            Ensure that the given target value is initialized (not null) in a thread-safe manner.
            </summary>
            <typeparam name="T">The type of the target value. Must be a reference type.</typeparam>
            <param name="target">The target to initialize.</param>
            <typeparam name="U">The type of the <paramref name="state"/> argument passed to the value factory.</typeparam>
            <param name="valueFactory">A factory delegate to create a new instance of the target value. Note that this delegate may be called
            more than once by multiple threads, but only one of those values will successfully be written to the target.</param>
            <param name="state">An argument passed to the value factory.</param>
            <returns>The target value.</returns>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock">
            <summary>
            A lightweight mutual exclusion object which supports waiting with cancellation and prevents
            recursion (i.e. you may not call Wait if you already hold the lock)
            </summary>
            <remarks>
            <para>
            The <see cref="T:Roslyn.Utilities.NonReentrantLock"/> provides a lightweight mutual exclusion class that doesn't
            use Windows kernel synchronization primitives.
            </para>
            <para>
            The implementation is distilled from the workings of <see cref="T:System.Threading.SemaphoreSlim"/>
            The basic idea is that we use a regular sync object (Monitor.Enter/Exit) to guard the setting
            of an 'owning thread' field. If, during the Wait, we find the lock is held by someone else
            then we register a cancellation callback and enter a "Monitor.Wait" loop. If the cancellation
            callback fires, then it "pulses" all the waiters to wake them up and check for cancellation.
            Waiters are also "pulsed" when leaving the lock.
            </para>
            <para>
            All public members of <see cref="T:Roslyn.Utilities.NonReentrantLock"/> are thread-safe and may be used concurrently
            from multiple threads.
            </para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._syncLock">
            <summary>
            A synchronization object to protect access to the <see cref="F:Roslyn.Utilities.NonReentrantLock._owningThreadId"/> field and to be pulsed
            when <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/> is called and during cancellation.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock._owningThreadId">
            <summary>
            The <see cref="P:System.Environment.CurrentManagedThreadId" /> of the thread that holds the lock. Zero if no thread is holding
            the lock.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.#ctor(System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="useThisInstanceForSynchronization">If false (the default), then the class
            allocates an internal object to be used as a sync lock.
            If true, then the sync lock object will be the NonReentrantLock instance itself. This
            saves an allocation but a client may not safely further use this instance in a call to
            Monitor.Enter/Exit or in a "lock" statement.
            </param>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.Factory">
            <summary>
            Shared factory for use in lazy initialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Wait(System.Threading.CancellationToken)">
            <summary>
            Blocks the current thread until it can enter the <see cref="T:Roslyn.Utilities.NonReentrantLock"/>, while observing a
            <see cref="T:System.Threading.CancellationToken"/>.
            </summary>
            <remarks>
            Recursive locking is not supported. i.e. A thread may not call Wait successfully twice without an
            intervening <see cref="M:Roslyn.Utilities.NonReentrantLock.Release"/>.
            </remarks>
            <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken"/> token to
            observe.</param>
            <exception cref="T:System.OperationCanceledException"><paramref name="cancellationToken"/> was
            canceled.</exception>
            <exception cref="T:System.Threading.LockRecursionException">The caller already holds the lock</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.Release">
            <summary>
            Exit the mutual exclusion.
            </summary>
            <remarks>
            The calling thread must currently hold the lock.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.LockHeldByMe">
            <summary>
            Determine if the lock is currently held by the calling thread.
            </summary>
            <returns>True if the lock is currently held by the calling thread.</returns>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.AssertHasLock">
            <summary>
            Throw an exception if the lock is not held by the calling thread.
            </summary>
            <exception cref="T:System.InvalidOperationException">The lock is not currently held by the calling thread.</exception>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsLocked">
            <summary>
            Checks if the lock is currently held.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.NonReentrantLock.IsOwnedByMe">
            <summary>
            Checks if the lock is currently held by the calling thread.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.TakeOwnership">
            <summary>
            Take ownership of the lock (by the calling thread). The lock may not already
            be held by any other code.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.ReleaseOwnership">
            <summary>
            Release ownership of the lock. The lock must already be held by the calling thread.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.NonReentrantLock.s_cancellationTokenCanceledEventHandler">
            <summary>
            Action object passed to a cancellation token registration.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.NonReentrantLock.CancellationTokenCanceledEventHandler(System.Object)">
            <summary>
            Callback executed when a cancellation token is canceled during a Wait.
            </summary>
            <param name="obj">The syncLock that protects a <see cref="T:Roslyn.Utilities.NonReentrantLock"/> instance.</param>
        </member>
        <member name="T:Roslyn.Utilities.NonReentrantLock.SemaphoreDisposer">
            <summary>
            Since we want to avoid boxing the return from <see cref="M:Roslyn.Utilities.NonReentrantLock.DisposableWait(System.Threading.CancellationToken)"/>, this type must be public.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1">
             <summary>
             A reference-counting wrapper which allows multiple uses of a single disposable object in code, which is
             deterministically released (by calling <see cref="M:System.IDisposable.Dispose"/>) when the last reference is
             disposed.
             </summary>
             <remarks>
             <para>Each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> represents a counted reference (also
             referred to as a <em>reference</em> in the following documentation) to a target object. Each of these
             references has a lifetime, starting when it is constructed and continuing through its release. During
             this time, the reference is considered <em>alive</em>. Each reference which is alive owns exactly one
             reference to the target object, ensuring that it will not be disposed while still in use. A reference is
             released through either of the following actions:</para>
            
             <list type="bullet">
             <item>The reference is explicitly released by a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</item>
             <item>The reference is no longer in use by managed code and gets reclaimed by the garbage collector.</item>
             </list>
            
             <para>While each instance of <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> should be explicitly disposed when
             the object is no longer needed by the code owning the reference, this implementation will not leak resources
             in the event one or more callers fail to do so. When all references to an object are explicitly released
             (i.e. by calling <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>), the target object will itself be deterministically released by a
             call to <see cref="M:System.IDisposable.Dispose"/> when the last reference to it is released. However, in the event
             one or more references is not explicitly released, the underlying object will still become eligible for
             non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the
             two actions described previously.</para>
            
             <para>When using <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/>, certain steps must be taken to ensure the
             target object is not disposed early.</para>
            
             <list type="number">
             <para>Use <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> consistently. In other words, do not mix code using
             reference-counted wrappers with code that references to the target directly.</para>
             <para>Only use the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)"/> constructor one time per target object.
             Additional references to the same target object must only be obtained by calling
             <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>.</para>
             <para>Do not call <see cref="M:System.IDisposable.Dispose"/> on the target object directly. It will be called
             automatically at the appropriate time, as described above.</para>
             </list>
            
             <para>All public methods on this type adhere to their pre- and post-conditions and will not invalidate state
             even in concurrent execution.</para>
             </remarks>
             <typeparam name="T">The type of disposable object.</typeparam>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._instance">
            <summary>
            The target of this reference. This value is initialized to a non-<see langword="null"/> value in the
            constructor, and set to <see langword="null"/> when the current reference is disposed.
            </summary>
            <remarks>
            <para>This value is only cleared in order to support cases where one or more references is garbage
            collected without having <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> called.</para>
            </remarks>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1._boxedReferenceCount">
             <summary>
             The boxed reference count, which is shared by all references with the same <see cref="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target"/> object.
             </summary>
             <remarks>
             <para>This field serves as the synchronization object for the current type, since it is shared among all
             counted reference to the same target object. Accesses to <see cref="F:System.Runtime.CompilerServices.StrongBox`1.Value"/> should only
             occur when this object is locked.</para>
            
             <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
             available in source control history. The use of exclusive locks was not causing any measurable
             performance overhead even on 28-thread machines at the time this was written.</para>
             </remarks>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.#ctor(`0)">
            <summary>
            Initializes a new reference counting wrapper around an <see cref="T:System.IDisposable"/> object.
            </summary>
            <remarks>
            <para>The reference count is initialized to 1.</para>
            </remarks>
            <param name="instance">The object owned by this wrapper.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="instance"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:Roslyn.Utilities.ReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReferenceImpl(`0,System.Runtime.CompilerServices.StrongBox{System.Int32})">
            <summary>
            Provides the implementation for <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/>.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.Dispose">
            <summary>
            Releases the current reference, causing the underlying object to be disposed if this was the last
            reference.
            </summary>
            <remarks>
            <para>After this instance is disposed, the <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/> method can no longer be used to
            object a new reference to the target, even if other references to the target object are still in
            use.</para>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference">
            <summary>
            Represents a weak reference to a <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> which is capable of
            obtaining a new counted reference up until the point when the object is no longer accessible.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference._weakInstance">
            <summary>
            DO NOT DISPOSE OF THE TARGET.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReferenceCountedDisposable`1.WeakReference.TryAddReference">
             <summary>
             Increments the reference count for the disposable object, and returns a new disposable reference to
             it.
             </summary>
             <remarks>
             <para>Unlike <see cref="M:Roslyn.Utilities.ReferenceCountedDisposable`1.TryAddReference"/>, this method is capable of
             adding a reference to the underlying instance all the way up to the point where it is finally
             disposed.</para>
            
             <para>The returned object is an independent reference to the same underlying object. Disposing of
             the returned value multiple times will only cause the reference count to be decreased once.</para>
             </remarks>
             <returns>A new <see cref="T:Roslyn.Utilities.ReferenceCountedDisposable`1"/> pointing to the same underlying object,
             if it has not yet been disposed; otherwise, <see langword="null"/> if the underlying object has
             already been disposed.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceCountedDisposableCache`2">
            <summary>
            Implements a reference-counted cache, where key/value pairs are associated with a count. When the count of a pair goes to zero,
            the value is evicted. Values can also be explicitly evicted at any time. In that case, any new calls to <see cref="M:Roslyn.Utilities.ReferenceCountedDisposableCache`2.GetOrCreate(`0,System.Func{`0,`1})"/>
            will return a new value, and the existing holders of the evicted value will still dispose it once they're done with it.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SemaphoreSlimFactory">
            <summary>
            Container for a <see cref="T:System.Threading.SemaphoreSlim"/> factory.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SemaphoreSlimFactory.Instance">
            <summary>
            Factory object that may be used for lazy initialization. Creates AsyncSemaphore instances with an initial count of 1.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SimpleTaskQueue">
            <summary>
            schedules task to run in sequence.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.SimpleTaskQueue._gate">
            <summary>
            An object to synchronize reads/writes of all mutable fields of this class.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SoftCrashException">
            <summary>
            TODO: remove this exception: https://github.com/dotnet/roslyn/issues/40476
            
            this represents soft crash request compared to hard crash which will bring down VS.
            
            by soft crash, it means everything same as hard crash except it should use NFW and info bar
            to inform users about unexpected condition instead of killing VS as traditional crash did.
            
            in other words, no one should ever try to recover from this exception. but they must try to not hard crash.
            
            this exception is based on cancellation exception since, in Roslyn code, cancellation exception is so far
            only safest exception to throw without worrying about crashing VS 99%. there is still 1% case it will bring
            down VS and those places should be guarded on this exception as we find such place.
            
            for now, this is an opt-in based. if a feature wants to move to soft crash (ex, OOP), one should catch
            exception and translate that to this exception and then add handler which report NFW and info bar in their
            code path and make sure it doesn't bring down VS.
            
            as we use soft-crash in more places, we should come up with more general framework.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.WordSimilarityChecker._substringsAreSimilar">
            <summary>
            Whether or words should be considered similar if one is contained within the other
            (regardless of edit distance).  For example if is true then IService would be considered
            similar to IServiceFactory despite the edit distance being quite high at 7.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WordSimilarityChecker.AreSimilar(System.String,System.String,System.Boolean,System.Double@)">
            <summary>
            Returns true if 'originalText' and 'candidateText' are likely a misspelling of each other.
            Returns false otherwise.  If it is a likely misspelling a similarityWeight is provided
            to help rank the match.  Lower costs mean it was a better match.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.SyntaxPath">
            <summary>
            Stores the "path" from the root of a tree to a node, allowing the node to be recovered in a
            later snapshot of the tree, under certain circumstances.
            
            The implementation stores the child indices to represent the path, so any edit which affects
            the child indices could render this object unable to recover its node.  NOTE: One thing C#
            IDE has done in the past to do a better job of this is to store the fully qualified name of
            the member to at least be able to descend into the same member.  We could apply the same sort
            of logic here.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.SyntaxPath.TryResolve(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNodeOrToken@)">
            <summary>
            Attempts to recover the node at this path in the provided tree.  If the node is found
            then 'true' is returned, otherwise the result is 'false' and 'node' will be null.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConstantValueSource`1">
            <summary>
            This value source keeps a strong reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ValueSource`1">
            <summary>
            A class that abstracts the accessing of a value that is guaranteed to be available at some point.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.WeakValueSource`1">
            <summary>
            A <see cref="T:Roslyn.Utilities.ValueSource`1"/> that keeps a weak reference to a value.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.VoidResult">
            <summary>
            Explicitly indicates result is void
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.WeakEventHandler`1.Create``1(``0,System.Action{``0,System.Object,`0})">
            <summary>
            Creates an event handler that holds onto the target weakly.
            </summary>
            <param name="target">The target that is held weakly, and passed as an argument to the invoker.</param>
            <param name="invoker">An action that will receive the event arguments as well as the target instance. 
            The invoker itself must not capture any state.</param>
        </member>
        <member name="M:Roslyn.Utilities.ArrayExtensions.BinarySearchUpperBound(System.Int32[],System.Int32)">
            <summary>
            Search a sorted integer array for the target value in O(log N) time.
            </summary>
            <param name="array">The array of integers which must be sorted in ascending order.</param>
            <param name="value">The target value.</param>
            <returns>An index in the array pointing to the position where <paramref name="value"/> should be
            inserted in order to maintain the sorted order. All values to the right of this position will be
            strictly greater than <paramref name="value"/>. Note that this may return a position off the end
            of the array if all elements are less than or equal to <paramref name="value"/>.</returns>
        </member>
        <member name="M:Roslyn.Utilities.CompilerOptionParseUtilities.ParseFeatureFromMSBuild(System.String)">
            <summary>
            Parse the value provided to an MSBuild Feature option into a list of entries.  This will 
            leave name=value in their raw form.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ConcurrentSet`1">
            <summary>
            A concurrent, simplified HashSet.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultConcurrencyLevel">
            <summary>
            The default concurrency level is 2. That means the collection can cope with up to two
            threads making simultaneous modifications without blocking.
            Note ConcurrentDictionary's default concurrency level is dynamic, scaling according to
            the number of processors.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1.DefaultCapacity">
            <summary>
            Taken from ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ConcurrentSet`1._dictionary">
            <summary>
            The backing dictionary. The values are never used; just the keys.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor">
            <summary>
            Construct a concurrent set with the default concurrency level.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Construct a concurrent set using the specified equality comparer.
            </summary>
            <param name="equalityComparer">The equality comparer for values in the set.</param>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.Count">
            <summary>
            Obtain the number of elements in the set.
            </summary>
            <returns>The number of elements in the set.</returns>
        </member>
        <member name="P:Roslyn.Utilities.ConcurrentSet`1.IsEmpty">
            <summary>
            Determine whether the set is empty.</summary>
            <returns>true if the set is empty; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Contains(`0)">
            <summary>
            Determine whether the given value is in the set.
            </summary>
            <param name="value">The value to test.</param>
            <returns>true if the set contains the specified value; otherwise, false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Add(`0)">
            <summary>
            Attempts to add a value to the set.
            </summary>
            <param name="value">The value to add.</param>
            <returns>true if the value was added to the set. If the value already exists, this method returns false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Remove(`0)">
            <summary>
            Attempts to remove a value from the set.
            </summary>
            <param name="value">The value to remove.</param>
            <returns>true if the value was removed successfully; otherwise false.</returns>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.Clear">
            <summary>
            Clear the set
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ConcurrentSet`1.GetEnumerator">
            <summary>
            Obtain an enumerator that iterates through the elements in the set.
            </summary>
            <returns>An enumerator for the set.</returns>
        </member>
        <member name="T:Roslyn.Utilities.ConsList`1">
            <summary>
            a simple Lisp-like immutable list.  Good to use when lists are always accessed from the head.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynDebug.Assert(System.Boolean,System.String)">
            <inheritdoc cref="M:System.Diagnostics.Debug.Assert(System.Boolean,System.String)"/>
        </member>
        <member name="T:Roslyn.Utilities.DocumentationCommentXmlNames">
            <summary>
            Names of well-known XML attributes and elements.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.EncodingExtensions.GetMaxCharCountOrThrowIfHuge(System.Text.Encoding,System.IO.Stream)">
            <summary>
            Get maximum char count needed to decode the entire stream.
            </summary>
            <exception cref="T:System.IO.IOException">Stream is so big that max char count can't fit in <see cref="T:System.Int32"/>.</exception> 
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(``0[])">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.List{``0})">
            <remarks>
            This method is necessary to avoid an ambiguity between <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})"/> and <see cref="M:Roslyn.Utilities.EnumerableExtensions.IsEmpty``1(System.Collections.Generic.ICollection{``0})"/>.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.EnumerableExtensions.AsSingleton``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of specified sequence if it has exactly one, and default(TSource) otherwise.
            Unlike <see cref="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})"/> doesn't throw if there is more than one element in the sequence.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.Functions`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Roslyn.Utilities.Predicates`1">
            <summary>
            Cached versions of commonly used delegates.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Roslyn.Utilities.EnumUtilities.ConvertEnumUnderlyingTypeToUInt64(System.Object,Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Convert a boxed primitive (generally of the backing type of an enum) into a ulong.
            </summary>
            <remarks>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.FileNameUtilities">
            <summary>
            Implements a few file name utilities that are needed by the compiler.
            In general the compiler is not supposed to understand the format of the paths.
            In rare cases it needs to check if a string is a valid file name or change the extension 
            (embedded resources, netmodules, output name).
            The APIs are intentionally limited to cover just these rare cases. Do not add more APIs.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IsFileName(System.String)">
            <summary>
            Returns true if the string represents an unqualified file name. 
            The name may contain any characters but directory and volume separators.
            </summary>
            <param name="path">Path.</param>
            <returns>
            True if <paramref name="path"/> is a simple file name, false if it is null or includes a directory specification.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfExtension(System.String)">
            <summary>
            Returns the offset in <paramref name="path"/> where the dot that starts an extension is, or -1 if the path doesn't have an extension.
            </summary>
            <remarks>
            Returns 0 for path ".goo".
            Returns -1 for path "goo.".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetExtension(System.String)">
            <summary>
            Returns an extension of the specified path string.
            </summary>
            <remarks>
            The same functionality as <see cref="M:System.IO.Path.GetExtension(System.String)"/> but doesn't throw an exception
            if there are invalid characters in the path.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)">
            <summary>
            Removes extension from path.
            </summary>
            <remarks>
            Returns "goo" for path "goo.".
            Returns "goo.." for path "goo...".
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.ChangeExtension(System.String,System.String)">
            <summary>
            Returns path with the extension changed to <paramref name="extension"/>.
            </summary>
            <returns>
            Equivalent of <see cref="M:System.IO.Path.ChangeExtension(System.String,System.String)"/>
            
            If <paramref name="path"/> is null, returns null. 
            If path does not end with an extension, the new extension is appended to the path.
            If extension is null, equivalent to <see cref="M:Roslyn.Utilities.FileNameUtilities.RemoveExtension(System.String)"/>.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.IndexOfFileName(System.String)">
            <summary>
            Returns the position in given path where the file name starts.
            </summary>
            <returns>-1 if path is null.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileNameUtilities.GetFileName(System.String,System.Boolean)">
            <summary>
            Get file name from path.
            </summary>
            <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)"/> doesn't check for invalid path characters.</remarks>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.Hash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Byte},System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.ReadOnlySpan{System.Char})">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Roslyn.Utilities.Hash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="T:Roslyn.Utilities.SetWithInsertionOrder`1">
            <summary>
            A set that returns the inserted values in insertion order.
            The mutation operations are not thread-safe.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Empty">
            <summary>
            Null or empty.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Relative">
            <summary>
            "file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentDirectory">
            <summary>
            ".\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentParent">
            <summary>
            "..\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToCurrentRoot">
            <summary>
            "\dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.RelativeToDriveDirectory">
            <summary>
            "C:dir\file"
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.PathKind.Absolute">
            <summary>
            "C:\file" or "\\machine" (UNC).
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ExceptionUtilities.UnexpectedValue(System.Object)">
            <summary>
            Creates an <see cref="T:System.InvalidOperationException"/> with information about an unexpected value.
            </summary>
            <param name="o">The unexpected value.</param>
            <returns>The <see cref="T:System.InvalidOperationException"/>, which should be thrown by the caller.</returns>
        </member>
        <member name="T:Roslyn.Utilities.OneOrMany`1">
            <summary>
            Represents a single item or many items.
            </summary>
            <remarks>
            Used when a collection usually contains a single item but sometimes might contain multiple.
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.PerformanceSensitiveAttribute">
            <summary>
            Indicates that a code element is performance sensitive under a known scenario.
            </summary>
            <remarks>
            <para>When applying this attribute, only explicitly set the values for properties specifically indicated by the
            test/measurement technique described in the associated <see cref="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Uri">
            <summary>
            Gets the location where the original problem is documented, likely with steps to reproduce the issue and/or
            validate performance related to a change in the method.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.Constraint">
            <summary>
            Gets or sets a description of the constraint imposed by the original performance issue.
            </summary>
            <remarks>
            <para>Constraints are normally specified by other specific properties that allow automated validation of the
            constraint. This property supports documenting constraints which cannot be described in terms of other
            constraint properties.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowCaptures">
            <summary>
            Gets or sets a value indicating whether captures are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowImplicitBoxing">
            <summary>
            Gets or sets a value indicating whether implicit boxing of value types is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowGenericEnumeration">
            <summary>
            Gets or sets a value indicating whether enumeration of a generic <see cref="T:System.Collections.Generic.IEnumerable`1"/> is allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.AllowLocks">
            <summary>
            Gets or sets a value indicating whether locks are allowed.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.OftenCompletesSynchronously">
            <summary>
            Gets or sets a value indicating whether the asynchronous state machine typically completes synchronously.
            </summary>
            <remarks>
            <para>When <see langword="true"/>, validation of this performance constraint typically involves analyzing
            the method to ensure synchronous completion of the state machine does not require the allocation of a
            <see cref="T:System.Threading.Tasks.Task"/>, either through caching the result or by using <see cref="T:System.Threading.Tasks.ValueTask`1"/>.</para>
            </remarks>
        </member>
        <member name="P:Roslyn.Utilities.PerformanceSensitiveAttribute.IsParallelEntry">
            <summary>
            Gets or sets a value indicating whether this is an entry point to a parallel algorithm.
            </summary>
            <remarks>
            <para>Parallelization APIs and algorithms, e.g. <c>Parallel.ForEach</c>, may be efficient for parallel entry
            points (few direct calls but large amounts of iterative work), but are problematic when called inside the
            iterations themselves. Performance-sensitive code should avoid the use of heavy parallelization APIs except
            for known entry points to the parallel portion of code.</para>
            </remarks>
        </member>
        <member name="T:Roslyn.Utilities.PlatformInformation">
            <summary>
            This class provides simple properties for determining whether the current platform is Windows or Unix-based.
            We intentionally do not use System.Runtime.InteropServices.RuntimeInformation.IsOSPlatform(...) because
            it incorrectly reports 'true' for 'Windows' in desktop builds running on Unix-based platforms via Mono.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ReferenceEqualityComparer">
            <summary>
            Compares objects based upon their reference identity.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.RoslynString.IsNullOrWhiteSpace(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrWhiteSpace(System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.TryReadAll(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Attempts to read all of the requested bytes from the stream into the buffer
            </summary>
            <returns>
            The number of bytes read. Less than <paramref name="count" /> will
            only be returned if the end of stream is reached before all bytes can be read.
            </returns>
            <remarks>
            Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)"/> it is not guaranteed that
            the stream position or the output buffer will be unchanged if an exception is
            returned.
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.StreamExtensions.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads all bytes from the current position of the given stream to its end.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.IsValidClrNamespaceName(System.String)">
            <summary>
            Checks if the given name is a sequence of valid CLR names separated by a dot.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.StringExtensions.Unquote(System.String)">
            <summary>
            Remove one set of leading and trailing double quote characters, if both are present.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.StringTable">
            <summary>
            This is basically a lossy cache of strings that is searchable by
            strings, string sub ranges, character array ranges or string-builder.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.ResolveRelativePath(System.String,System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Func{System.String,System.Boolean})">
            <summary>
            Resolves relative path and returns absolute path.
            The method depends only on values of its parameters and their implementation (for fileExists).
            It doesn't itself depend on the state of the current process (namely on the current drive directories) or 
            the state of file system.
            </summary>
            <param name="path">
            Path to resolve.
            </param>
            <param name="basePath">
            Base file path to resolve CWD-relative paths against. Null if not available.
            </param>
            <param name="baseDirectory">
            Base directory to resolve CWD-relative paths against if <paramref name="basePath"/> isn't specified. 
            Must be absolute path.
            Null if not available.
            </param>
            <param name="searchPaths">
            Sequence of paths used to search for unqualified relative paths.
            </param>
            <param name="fileExists">
            Method that tests existence of a file.
            </param>
            <returns>
            The resolved path or null if the path can't be resolved or does not exist.
            </returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.NormalizeAbsolutePath(System.String)">
            <summary>
            Normalizes an absolute path.
            </summary>
            <param name="path">Path to normalize.</param>
            <exception cref="T:System.IO.IOException"/>
            <returns>Normalized path.</returns>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.CreateFileStreamChecked(System.Func{System.String,System.IO.Stream},System.String,System.String)">
            <summary>
            Used to create a file given a path specified by the user.
            paramName - Provided by the Public surface APIs to have a clearer message. Internal API just rethrow the exception
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileTimeStamp(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.FileUtilities.GetFileLength(System.String)">
            <exception cref="T:System.IO.IOException"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDirectorySeparator(System.Char)">
            <summary>
            True if the character is the platform directory separator character or the alternate directory separator.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAnyDirectorySeparator(System.Char)">
            <summary>
            True if the character is any recognized directory separator character.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.TrimTrailingSeparators(System.String)">
            <summary>
            Removes trailing directory separator characters
            </summary>
            <remarks>
            This will trim the root directory separator:
            "C:\" maps to "C:", and "/" maps to ""
            </remarks>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.EnsureTrailingSeparator(System.String)">
            <summary>
            Ensures a trailing directory separator character
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetDirectoryName(System.String)">
            <summary>
            Get directory name from path.
            </summary>
            <remarks>
            Unlike <see cref="M:System.IO.Path.GetDirectoryName(System.String)"/> it doesn't check for invalid path characters
            </remarks>
            <returns>Prefix of path that represents a directory</returns>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathRoot(System.String)">
            <summary>
            Gets the root part of the path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetPathKind(System.String)">
            <summary>
            Gets the specific kind of relative or absolute path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsAbsolute(System.String)">
            <summary>
            True if the path is an absolute path (rooted to drive or network share)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsDriveRootedAbsolutePath(System.String)">
            <summary>
            Returns true if given path is absolute and starts with a drive specification ("C:\").
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)">
            <summary>
            Combines an absolute path with a relative.
            </summary>
            <param name="root">Absolute root path.</param>
            <param name="relativePath">Relative path.</param>
            <returns>
            An absolute combined path, or null if <paramref name="relativePath"/> is 
            absolute (e.g. "C:\abc", "\\machine\share\abc"), 
            relative to the current root (e.g. "\abc"), 
            or relative to a drive directory (e.g. "C:abc\def").
            </returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.CombinePossiblyRelativeAndRelativePaths(System.String,System.String)">
            <summary>
            Combine two paths, the first of which may be absolute.
            </summary>
            <param name="rootOpt">First path: absolute, relative, or null.</param>
            <param name="relativePath">Second path: relative and non-null.</param>
            <returns>null, if <paramref name="rootOpt"/> is null; a combined path, otherwise.</returns>
            <seealso cref="M:Roslyn.Utilities.PathUtilities.CombineAbsoluteAndRelativePaths(System.String,System.String)"/>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsFilePath(System.String)">
            <summary>
            Determines whether an assembly reference is considered an assembly file path or an assembly name.
            used, for example, on values of /r and #r.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.ContainsPathComponent(System.String,System.String,System.Boolean)">
            <summary>
            Determines if "path" contains 'component' within itself.
            i.e. asking if the path "c:\goo\bar\baz" has component "bar" would return 'true'.
            On the other hand, if you had "c:\goo\bar1\baz" then it would not have "bar" as a
            component.
            
            A path contains a component if any file name or directory name in the path
            matches 'component'.  As such, if you had something like "\\goo" then that would
            not have "goo" as a component. That's because here "goo" is the server name portion
            of the UNC path, and not an actual directory or file name.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.GetRelativePath(System.String,System.String)">
            <summary>
            Gets a path relative to a directory.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsChildPath(System.String,System.String)">
            <summary>
            True if the child path is a child of the parent path.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String)">
            <summary>
            True if the two paths are the same.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.PathsEqual(System.String,System.String,System.Int32)">
            <summary>
            True if the two paths are the same.  (but only up to the specified length)
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.IsValidFilePath(System.String)">
            <summary>
            Unfortunately, we cannot depend on Path.GetInvalidPathChars() or Path.GetInvalidFileNameChars()
            From MSDN: The array returned from this method is not guaranteed to contain the complete set of characters
            that are invalid in file and directory names. The full set of invalid characters can vary by file system.
            https://msdn.microsoft.com/en-us/library/system.io.path.getinvalidfilenamechars.aspx
            
            Additionally, Path.GetInvalidPathChars() doesn't include "?" or "*" which are invalid characters,
            and Path.GetInvalidFileNameChars() includes ":" and "\" which are valid characters.
            
            The more accurate way is to let the framework parse the path and throw on any errors.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.PathUtilities.NormalizeWithForwardSlash(System.String)">
            <summary>
            If the current environment uses the '\' directory separator, replaces all uses of '\'
            in the given string with '/'. Otherwise, returns the string.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ReflectionUtilities.GetTypeFromEither(System.String,System.String)">
            <summary>
            Find a <see cref="T:System.Type"/> instance by first probing the contract name and then the name as it
            would exist in mscorlib.  This helps satisfy both the CoreCLR and Desktop scenarios. 
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectReader"/> that deserializes objects from a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader.VersionByte1">
            <summary>
            We start the version at something reasonably random.  That way an older file, with 
            some random start-bytes, has little chance of matching our version.  When incrementing
            this version, just change VersionByte2.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._objectReferenceMap">
            <summary>
            Map of reference id's to deserialized objects.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectReader._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
            <param name="stream">The stream to read objects from.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken"></param>
        </member>
        <member name="M:Roslyn.Utilities.ObjectReader.TryGetReader(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Attempts to create a <see cref="T:Roslyn.Utilities.ObjectReader"/> from the provided <paramref name="stream"/>.
            If the <paramref name="stream"/> does not start with a valid header, then <see langword="null"/> will
            be returned.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectReader.ReaderReferenceMap`1">
            <summary>
            An reference-id to object map, that can share base data efficiently.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter">
            <summary>
            An <see cref="T:Roslyn.Utilities.ObjectWriter"/> that serializes objects to a byte stream.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._objectReferenceMap">
            <summary>
            Map of serialized object's reference ids.  The object-reference-map uses reference equality
            for performance.  While the string-reference-map uses value-equality for greater cache hits 
            and reuse.
            
            These are not readonly because they're structs and we mutate them.
            
            When we write out objects/strings we give each successive, unique, item a monotonically 
            increasing integral ID starting at 0.  I.e. the first object gets ID-0, the next gets 
            ID-1 and so on and so forth.  We do *not* include these IDs with the object when it is
            written out.  We only include the ID if we hit the object *again* while writing.
            
            During reading, the reader knows to give each object it reads the same monotonically 
            increasing integral value.  i.e. the first object it reads is put into an array at position
            0, the next at position 1, and so on.  Then, when the reader reads in an object-reference
            it can just retrieved it directly from that array.
            
            In other words, writing and reading take advantage of the fact that they know they will
            write and read objects in the exact same order.  So they only need the IDs for references
            and not the objects themselves because the ID is inferred from the order the object is
            written or read in.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter._binderSnapshot">
            <summary>
            Copy of the global binder data that maps from Types to the appropriate reading-function
            for that type.  Types register functions directly with <see cref="T:Roslyn.Utilities.ObjectBinder"/>, but 
            that means that <see cref="T:Roslyn.Utilities.ObjectBinder"/> is both static and locked.  This gives us 
            local copy we can work with without needing to worry about anyone else mutating.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectWriter.#ctor(System.IO.Stream,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Creates a new instance of a <see cref="T:Roslyn.Utilities.ObjectWriter"/>.
            </summary>
            <param name="stream">The stream to write to.</param>
            <param name="leaveOpen">True to leave the <paramref name="stream"/> open after the <see cref="T:Roslyn.Utilities.ObjectWriter"/> is disposed.</param>
            <param name="cancellationToken">Cancellation token.</param>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.GuidAccessor">
            <summary>
            Used so we can easily grab the low/high 64bits of a guid for serialization.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectWriter.WriterReferenceMap">
            <summary>
            An object reference to reference-id map, that can share base data efficiently.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.s_reverseTypeMap">
            <summary>
            Indexed by EncodingKind.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.ByteMarkerMask">
            <summary>
            byte marker mask for encoding compressed uint 
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte1Marker">
            <summary>
            byte marker bits for uint encoded in 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte2Marker">
            <summary>
            byte marker bits for uint encoded in 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.Byte4Marker">
            <summary>
            byte marker bits for uint encoded in 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Null">
            <summary>
            The null value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Type">
            <summary>
            A type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Object">
            <summary>
            An object with member values encoded as variants
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_1Byte">
            <summary>
            An object reference with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_2Bytes">
            <summary>
            An object reference with the id encode as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.ObjectRef_4Bytes">
            <summary>
            An object reference with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf8">
            <summary>
            A string encoded as UTF8 (using BinaryWriter.Write(string))
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringUtf16">
            <summary>
            A string encoded as UTF16 (as array of UInt16 values)
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_1Byte">
            <summary>
            A reference to a string with the id encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_2Bytes">
            <summary>
            A reference to a string with the id encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringRef_4Bytes">
            <summary>
            A reference to a string with the id encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_True">
            <summary>
            The boolean value true.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Boolean_False">
            <summary>
            The boolean value char.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Char">
            <summary>
            A character value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int8">
            <summary>
            An Int8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int16">
            <summary>
            An Int16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32">
            <summary>
            An Int32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1Byte">
            <summary>
            An Int32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2Bytes">
            <summary>
            An Int32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_0">
            <summary>
            The Int32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_1">
            <summary>
            The Int32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_2">
            <summary>
            The Int32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_3">
            <summary>
            The Int32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_4">
            <summary>
            The Int32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_5">
            <summary>
            The Int32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_6">
            <summary>
            The Int32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_7">
            <summary>
            The Int32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_8">
            <summary>
            The Int32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_9">
            <summary>
            The Int32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int32_10">
            <summary>
            The Int32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Int64">
            <summary>
            An Int64 value encoded as 8 bytes
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt8">
            <summary>
            A UInt8 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt16">
            <summary>
            A UIn16 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32">
            <summary>
            A UInt32 value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1Byte">
            <summary>
            A UInt32 value encoded as 1 byte.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2Bytes">
            <summary>
            A UInt32 value encoded as 2 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_0">
            <summary>
            The UInt32 value 0
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_1">
            <summary>
            The UInt32 value 1
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_2">
            <summary>
            The UInt32 value 2
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_3">
            <summary>
            The UInt32 value 3
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_4">
            <summary>
            The UInt32 value 4
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_5">
            <summary>
            The UInt32 value 5
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_6">
            <summary>
            The UInt32 value 6
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_7">
            <summary>
            The UInt32 value 7
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_8">
            <summary>
            The UInt32 value 8
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_9">
            <summary>
            The UInt32 value 9
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt32_10">
            <summary>
            The UInt32 value 10
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.UInt64">
            <summary>
            A UInt64 value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float4">
            <summary>
            A float value encoded as 4 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Float8">
            <summary>
            A double value encoded as 8 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Decimal">
            <summary>
            A decimal value encoded as 12 bytes.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.DateTime">
            <summary>
            A DateTime value
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array">
            <summary>
            An array with length encoded as compressed uint
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_0">
            <summary>
            An array with zero elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_1">
            <summary>
            An array with one element
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_2">
            <summary>
            An array with 2 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.Array_3">
            <summary>
            An array with 3 elements
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.BooleanType">
            <summary>
            The boolean type
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectWriter.EncodingKind.StringType">
            <summary>
            The string type
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.UnicodeCharacterUtilities">
            <summary>
            Defines a set of helper methods to classify Unicode characters.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of an identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid Unicode identifier.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Roslyn.Utilities.UnicodeCharacterUtilities.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="T:Roslyn.Utilities.IObjectWritable">
            <summary>
            Objects that implement this interface know how to write their contents to an <see cref="T:Roslyn.Utilities.ObjectWriter"/>,
            so they can be reconstructed later by an <see cref="T:Roslyn.Utilities.ObjectReader"/>.
            </summary>
        </member>
        <member name="P:Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization">
            <summary>
            Returns 'true' when the same instance could be used more than once.
            Instances that return 'false' should not be tracked for the purpose 
            of de-duplication while serializing/deserializing.
            </summary>
        </member>
        <member name="T:Roslyn.Utilities.ObjectBinder">
            <summary>
            <see cref="T:Roslyn.Utilities.ObjectBinder"/> is a registry that maps between arbitrary <see cref="T:System.Type"/>s and 
            the 'reader' function used to deserialize serialized instances of those types.  Registration
            must happen ahead of time using the <see cref="M:Roslyn.Utilities.ObjectBinder.RegisterTypeReader(System.Type,System.Func{Roslyn.Utilities.ObjectReader,Roslyn.Utilities.IObjectWritable})"/> method.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_gate">
            <summary>
            Lock for all data in this type.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_lastSnapshot">
            <summary>
            Last created snapshot of our data.  We hand this out instead of exposing our raw
            data so that <see cref="T:Roslyn.Utilities.ObjectReader"/> and <see cref="T:Roslyn.Utilities.ObjectWriter"/> do not need to
            take any locks while processing.
            </summary>
        </member>
        <member name="F:Roslyn.Utilities.ObjectBinder.s_typeToIndex">
            <summary>
            Map from a <see cref="T:System.Type"/> to the corresponding index in <see cref="F:Roslyn.Utilities.ObjectBinder.s_types"/> and
            <see cref="F:Roslyn.Utilities.ObjectBinder.s_typeReaders"/>.  <see cref="T:Roslyn.Utilities.ObjectWriter"/> will write out the index into
            the stream, and <see cref="T:Roslyn.Utilities.ObjectReader"/> will use that index to get the reader used
            for deserialization.
            </summary>
        </member>
        <member name="M:Roslyn.Utilities.ObjectBinder.GetSnapshot">
            <summary>
            Gets an immutable copy of the state of this binder.  This copy does not need to be
            locked while it is used.
            </summary>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2">
            <summary>
            An immutable unordered hash map implementation.
            </summary>
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._root">
            <summary>
            The root node of the tree that stores this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._keyComparer">
            <summary>
            The comparer used to sort keys in this map.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2._valueComparer">
            <summary>
            The comparer used to detect equivalent values in this map.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket,System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="root">The root.</param>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> class.
            </summary>
            <param name="comparer">The comparer.</param>
            <param name="valueComparer">The value comparer.</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Empty">
            <summary>
            Gets an empty map with default equality comparers.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Clear">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Add(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItem(`0,`1)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.SetItems(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">
            <summary>
            Applies a given set of key=value pairs to an immutable dictionary, replacing any conflicting keys in the resulting dictionary.
            </summary>
            <param name="items">The key=value pairs to set on the map.  Any keys that conflict with existing keys will overwrite the previous values.</param>
            <returns>An immutable dictionary.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Remove(`0)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.RemoveRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Returns a hash map that uses the specified key and value comparers and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <param name="valueComparer">The value comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.WithComparers(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Returns a hash map that uses the specified key comparer and current value comparer and has the same contents as this map.
            </summary>
            <param name="keyComparer">The key comparer.  A value of <c>null</c> results in using the default equality comparer for the type.</param>
            <returns>The hash map with the new comparers.</returns>
            <remarks>
            In the event that a change in the key equality comparer results in a key collision, an exception is thrown.
            </remarks>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsValue(`1)">
            <summary>
            Determines whether the ImmutableSortedMap&lt;TKey,TValue&gt;
            contains an element with the specified value.
            </summary>
            <param name="value">
            The value to locate in the ImmutableSortedMap&lt;TKey,TValue&gt;.
            The value can be null for reference types.
            </param>
            <returns>
            true if the ImmutableSortedMap&lt;TKey,TValue&gt; contains
            an element with the specified value; otherwise, false.
            </returns>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Count">
            <summary>
            Gets the number of elements in this collection.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.IsEmpty">
            <summary>
            Gets a value indicating whether this instance is empty.
            </summary>
            <value>
              <c>true</c> if this instance is empty; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Keys">
            <summary>
            Gets the keys in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Values">
            <summary>
            Gets the values in the map.
            </summary>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.Item(`0)">
            <summary>
            Gets the <typeparamref name="TValue"/> with the specified key.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ContainsKey(`0)">
            <summary>
            Determines whether the specified key contains key.
            </summary>
            <param name="key">The key.</param>
            <returns>
              <c>true</c> if the specified key contains key; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Determines whether this map contains the specified key-value pair.
            </summary>
            <param name="keyValuePair">The key value pair.</param>
            <returns>
              <c>true</c> if this map contains the key-value pair; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetValue(`0,`1@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryGetKey(`0,`0@)">
            <summary>
            See the <see cref="T:System.Collections.Immutable.IImmutableDictionary`2"/> interface.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"/> that can be used to iterate through the collection.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryExchangeKey(`0,`0@)">
            <summary>
            Exchanges a key for the actual key instance found in this map.
            </summary>
            <param name="key">The key to search for.</param>
            <param name="existingKey">Receives the equal key found in the map.</param>
            <returns>A value indicating whether an equal and existing key was found in the map.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.TryCastToImmutableMap(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}@)">
            <summary>
            Attempts to discover an <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> instance beneath some enumerable sequence
            if one exists.
            </summary>
            <param name="sequence">The sequence that may have come from an immutable map.</param>
            <param name="other">Receives the concrete <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2"/> typed value if one can be found.</param>
            <returns><c>true</c> if the cast was successful; <c>false</c> otherwise.</returns>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.AddRange(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Boolean,System.Boolean)">
            <summary>
            Bulk adds entries to the map.
            </summary>
            <param name="pairs">The entries to add.</param>
            <param name="overwriteOnCollision"><c>true</c> to allow the <paramref name="pairs"/> sequence to include duplicate keys and let the last one win; <c>false</c> to throw on collisions.</param>
            <param name="avoidToHashMap"><c>true</c> when being called from ToHashMap to avoid StackOverflow.</param>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.Hash">
            <summary>
            The hash for this bucket.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueOrListBucket"/> class.
            </summary>
            <param name="hash">The hash.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket.#ctor(`0,`1,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ValueBucket"/> class.
            </summary>
            <param name="key">The key.</param>
            <param name="value">The value.</param>
            <param name="hashcode">The hashcode.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueBucket[])">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.ListBucket"/> class.
            </summary>
            <param name="buckets">The buckets.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,System.UInt32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.Bucket[],System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="hashRoll">The hash roll.</param>
            <param name="used">The used.</param>
            <param name="buckets">The buckets.</param>
            <param name="count">The count.</param>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket.#ctor(System.Int32,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket,Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1}.ValueOrListBucket)">
            <summary>
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.HashBucket"/> class.
            </summary>
            <param name="suggestedHashRoll">The suggested hash roll.</param>
            <param name="bucket1">The bucket1.</param>
            <param name="bucket2">The bucket2.</param>
        </member>
        <member name="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy">
            <summary>
            A simple view of the immutable collection that the debugger can show to the developer.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy._map">
            <summary>
            The collection to be enumerated.
            </summary>
        </member>
        <member name="F:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy._contents">
            <summary>
            The simple view of the collection.
            </summary>
        </member>
        <member name="M:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.#ctor(Roslyn.Collections.Immutable.ImmutableHashMap{`0,`1})">
            <summary>   
            Initializes a new instance of the <see cref="T:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy"/> class.
            </summary>
            <param name="map">The collection to display in the debugger</param>
        </member>
        <member name="P:Roslyn.Collections.Immutable.ImmutableHashMap`2.DebuggerProxy.Contents">
            <summary>
            Gets a simple debugger-viewable collection.
            </summary>
        </member>
        <member name="T:System.Linq.EnumerableExtensions">
            <summary>
            Declare the following extension methods in System.Linq namespace to avoid accidental boxing of ImmutableArray{T} that implements IEnumerable{T}.
            The boxing would occur if the methods were defined in Roslyn.Utilities and the file calling these methods has <c>using Roslyn.Utilities</c>
            but not <c>using System.Linq</c>.
            </summary>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
    </members>
</doc>
